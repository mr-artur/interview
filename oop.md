## Что такое _ООП_?
__Объектно-ориентированное программирование (ООП)__ — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования. 

+ объектно-ориентированное программирование использует в качестве основных логических конструктивных элементов объекты, а не алгоритмы;
+ каждый объект является экземпляром определенного класса 
+ классы образуют иерархии. 

Программа считается объектно-ориентированной, только если выполнены все три указанных требования. В частности, программирование, не использующее наследование, называется не объектно-ориентированным, а программированием с помощью абстрактных типов данных.

Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием, единственный способ изменить состояние объекта - послать ему сообщение, в ответ на которое, объект может изменить собственное состояние. 

## Основные понятия ООП: _«класс», «объект», «интерфейс»_
__Класс__ – это элемент ПО, описывающий абстрактный тип данных и его частичную или полную реализацию.
Простыми словами, это шаблон, по которому будут создаваться объекты.

С точки зрения программирования класс можно рассматривать как набор данных (полей, атрибутов, членов класса) и функций для работы с ними (методов).

С точки зрения структуры программы, класс является сложным типом данных.

__Объект (экземпляр)__ – это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом. Каждый объект имеет конкретные значения атрибутов и методы, работающие с этими значениями на основе правил, заданных в классе.

__Интерфейс__ – это набор методов класса, доступных для использования. Интерфейсом класса будет являться набор всех его публичных методов в совокупности с набором публичных атрибутов. По сути, интерфейс специфицирует класс, чётко определяя все возможные действия над ним.

## Основные принципы _ООП_
+ _Инкапсуляция_ - сокрытие реализации.
+ _Наследование_ - создание новой сущности на базе уже существующей.
+ _Полиморфизм_ - возможность иметь разные формы для одной и той же сущности.
+ _Абстракция_ - выделение во внешний интерфейс наиболее важных характеристик сущности

##  Что такое _«инкапсуляция»_?
__Инкапсуляция__ – это скрытие внутренних данных компонента и деталей его реализации от других компонентов программы и предоставление набора методов для взаимодействия с ним (API).

Цель инкапсуляции — уйти от зависимости внешнего интерфейса класса (то, что могут использовать другие классы) от реализации. Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса.

В языке _Java_ инкапсуляция реализована _с помощью_: 
+ _системы классов_, которые позволяют собрать информацию про объект в одном месте
+ _пакетов_, которые группируют классы по некоему критерию
+ _модификаторов доступа_, которыми можно обозначить весь класс, его поле или метод

## _Проблемы, которые решает инкапсуляция_
+ Уменьшает зависимость внешнего интерфейса класса от деталей его реализации

## _Преимущества инкапсуляции_
+ _Она способствует повторному использованию компонентов_.

Поскольку в этом случае компоненты взаимодействуют между собой только через их API и являются нечувствительными к изменениям внутренней структуры, они могут использоваться в более широком контексте.

+ _Инкапсуляция ускоряет процесс разработки_.

Слабо связанные между собой компоненты(то есть, компоненты, чей код как можно меньше обращается или использует код других компонентов) могут разрабатываться, тестироваться и дополняться независимо.

+ _Упрощает поддержку программы_.

Правильно инкапсулированые компоненты более понятны и легче настраиваются, что позволяет легче поддерживать программу.

## _Пример инкапсуляции_
```java
public class Person {
    
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }       

    public int getAge() {
        return age;
    }   

    public void setAge(int age) {
        if (age <= 0) {
            throw new IllegalArgumentException("Age should be positive");
        }
        this.age = age;
    }   
}
```
В приведенном выше примере значение поля name задается при создании объекта и не может быть изменено, так как сеттер для данного поля отсутствует. В сеттере для переменной age реализована проверка на корректность параметра, который передается, и выброс эксепшена при неверном значении.

##  Что такое _«наследование»_?
__Наследование__ – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.

Класс, от которого производится наследование, называется предком, базовым или родительским. Новый класс – потомком, наследником или производным классом.

Наследование реализует отношение «IS-A» между суперклассом и подклассом.

## _Проблемы, которые решает наследование_
+ Наследование позволяет создавать иерархические структуры объектов.

Используя его, можно создать общий класс, который будет определять характеристики и поведение, свойственны некоему набору связанных объектов. В дальнейшем этот класс может наследоваться другими, второстепенными классами, каждый из которых будет добавлять уникальные, свойственные только ему характеристики и будет дополнять или изменять поведение базового класса.

## _Преимущества наследования_

+ _Повторное использование программ_.

При наследовании поведения от другого класса программный код не переписывается. Другое преимущество повторно используемого кода – в его надежности (чем в большем числе ситуаций используется код, тем больше возможностей обнаружения ошибок) и низкой стоимости, так как она делится на всех пользователей кода.

## _Недостатки наследования_

+ _Размер программ_.

Использование любой программной библиотеки часто приводит к увеличению размера программ. Этого не происходит в специально разработанных системах. Хотя такие затраты могут быть существенными, по мере уменьшения стоимости памяти размер программы перестает быть критичным. Снизить затраты на разработку и быстро выдать качественный и свободный от ошибок программный код иногда значит гораздо больше, чем малый размер приложения.

+ _Сложность программ_.

Необдуманное использование наследования может вместо разрешения проблемы сложности подействовать наоборот. Для понимания программы, использующей наследование, может потребоваться несколько сложных переходов вверх и вниз в иерархическом дереве.

## _Пример наследования_
```java
class Employee {
    
    private String name;
    private double salary;

    // constructors

    public String getSalary() {
        return salary;
    }       
}

class Manager extends Employee {
    
    private double bonusPercentage;

    // constructors

    public double getSalary() {
        return super.salary * (100 + bonusPercentage) / 100;
    }
}
```
В этом примере Employee является базовым классом для Manager, а класс Manager - подклассом класса Employee. Класс Employee абстрагирует базовые характеристики для всех сотрудников компании - имя и зарплату, а класс Manager дополняет эти характеристики процентом премии для менеджеров и меняет поведение метода getSalary() базового класса, используя полиморфизм.

## _Композиция или Наследование_
Главное отличие между композицией и наследованием заключается в том, что композиция даёт возможность переиспользовать код без расширения существующего класса, как это происходит в случае с наследованием.

#### _Причины выбрать Композицию_
+ _Гибкость_

Одно из первых отличий связано с гибкостью кода. Используя наследование, мы должны описывать, какой класс расширяем, причём мы не сможем заменить его в процессе выполнения программы. Иначе обстоит дело с композицией: мы можем определить используемый тип, а он, в свою очередь, может включать несколько разных реализаций. В результате __композиция предоставляет нам больше гибкости__.

+ _Ограниченное повторное применение кода при наследовании_

Унаследоваться в Java возможно лишь от одного класса, т. е. мы можем повторно использовать только один класс. Если же нам нужна функциональность нескольких классов, необходимо использовать композицию. Например, если код должен использовать аутентификацию, то нужно унаследовать класс Authenificator, а при авторизации — Autorizer и т. п. Но т. к. множественное наследование не поддерживается, нам опять остаётся композиция.

+ _Юнит-тесты_

Следующий важнейший аргумент заключается в том, что классы, которые расширены посредством композиции, тестировать легче, ведь всегда можно предоставить для используемого класса заглушку. Что касается наследования, то нам для тестирования потребуется родительский класс, ведь его заменить заглушкой не выйдет.

+ _Final-классы_

Очередное ограничение наследования — нельзя расширить final-классы. В языке программирования Java отсутствует возможность унаследования от final-классов, в результате чего мы опять приходим к тому, что для повторного использования кода больше подходит композиция.

+ _Инкапсуляция_

Теперь поговорим об отношении композиции и наследования к инкапсуляции. С одной стороны, можно сказать, что обе техники дают возможность повторно использовать код. Так-то оно так, но __наследование нарушает принцип инкапсуляции__, и всё дело в том, что подкласс имеет зависимость от поведения класса-родителя. Если же родительский класс поменяет свой поведение, это отразится и на его потомках. Например, если классы будут плохо документированы, а класс-потомок будет неправильно использовать родительский класс, при любом изменении класса-родителя __функциональность потомка будет поломана__. Об этом, кстати, можно почитать в книге «Effective Java», в главах 16 и 17.  

#### _Итог_
Обе техники служат одной цели — для повторного применения протестированных и проверенных участков Java-кода. Только вот делают они это по-разному. Композиция даёт нам возможность защитить повторно используемый класс от клиентов, в то время как наследование это не гарантирует. Но несмотря на это, __в некоторых случаях наследование просто необходимо__. Например, если вы создаёте классы из одного семейства.

##  Что такое _«полиморфизм»_?
__Полиморфизм__ – это свойство системы, которое позволяет с помощью вызова переопределенного метода через переменную родительского класса получить поведение, которое будет соответствовать реальному производному классу, на объект которого ссылается эта переменная.

Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного и того же интерфейса для задания единого набора действий. Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор языка программирования. Отсюда следует ключевая особенность полиморфизма - использование объекта производного класса, вместо объекта базового (потомки могут изменять родительское поведение, даже если обращение к ним будет производиться по ссылке родительского типа).

## _Проблемы, которые решает полиморфизм_
+ Уменьшение связанности клиентского класса с реализацией.

Большим преимуществом и целью использования полиморфизма является уменьшение связанности клиентского класса с реализацией. Вместо того чтобы хардкодить, клиентский класс получает реализацию зависимости для выполнения необходимого действия. Таким образом, клиентский класс знает минимум для выполнения своих действий, что является примером слабого связывания.

## _Пример полиморфизма_
```java
public abstract class SweetProducer {
  public abstract void produceSweet();
}

public class CakeProducer extends SweetProducer {
  @Override
  public void produceSweet() {
    System.out.println("Cake produced");
  }
}

public class ChocolateProducer extends SweetProducer {
  @Override
  public void produceSweet() {
    System.out.println("Chocolate produced");
  }
}

public class CookieProducer extends SweetProducer {
  @Override
  public void produceSweet() {
    System.out.println("Cookie produced");
  }
}

public class SweetCreator {
  private List<SweetProducer> sweetProducer;

  public SweetCreator(List<SweetProducer> sweetProducer) {
    this.sweetProducer = sweetProducer;
  }

  public void createSweets() {
    sweetProducer.forEach(sweet -> sweet.produceSweet());
  }
}

public class SweetCreatorTest {
  public static void main(String... args) {
    SweetCreator sweetCreator = new SweetCreator(Arrays.asList(
      new CakeProducer(),
      new ChocolateProducer(), 
      new CookieProducer()));

     sweetCreator.createSweets();
  }
}
```
В данном примере класс SweetCreator знает только о классе SweetProducer. Он не знает реализации каждого Sweet. Такое разделение дает нам гибкость для обновления и повторного использования наших классов, а это делает код намного проще в сопровождении.

## _Виды полиморфизма_
Различают __статический__ и __динамический__ полиморфизм.

_Статический_ -  это полиморфизм, проявляющийся во время компиляции. Здесь компилятор Java знает, какой метод вызывается.

Перегрузка метода является примером времени компиляции / статического полиморфизма, поскольку привязка метода между вызовом метода и определением метода происходит во время компиляции и зависит от ссылки на класс (ссылка создается во время компиляции и отправляется в стек).

#### _Пример статического полиморфизма_
```java
class Calculation { 
 
    void sum(int a, int b) {
        System.out.println(a + b);
    }  

     void sum(int a, int b, int c) {
        System.out.println(a + b + c);
    }  

    public static void main(String[] args) {  
        Calculation obj = new Calculation();  
        obj.sum(10, 10, 10);
        obj.sum(20, 20);
  }  
} 
```

_Динамический_ - это полиморфизм, существовавший во время выполнения. Здесь компилятор Java не понимает, какой метод вызывается во время компиляции. Только JVM решает, какой метод вызывается во время выполнения. 

Переопределение метода является примером динамического полиморфизма во время выполнения, потому что привязка метода между вызовом метода и определением метода происходит во время выполнения и зависит от объекта класса (объект создается во время выполнения и перемещается в кучу).

#### _Пример динамического полиморфизма_
```java
class Animal {    
   public void move() {
      System.out.println("Animals can move");
   }
}

class Dog extends Animal {
   public void move() {
      System.out.println("Dogs can walk and run");
   }
}

public class TestDog {
   public static void main(String args[]) {
      Animal a = new Animal();
      Animal b = new Dog();

      a.move();// output: Animals can move

      b.move();// output: Dogs can walk and run
   }
}
```

#### Статичекий и динамический полифорфизм в байт-коде
Создадим такие классы :
```java
class Mammal {
    public void speak() { 
        System.out.println("ohlllalalalalalaoaoaoa");
     }
}

class Human extends Mammal {

    @Override
    public void speak() { 
        System.out.println("Hello"); 
    }

    public void speak(String language) {
        if (language.equals("Hindi")) {
            System.out.println("Namaste");
        }
        else System.out.println("Hello");
    }
}
```
Вывод и байт-код :
```java
Mammal anyMammal = new Mammal();
anyMammal.speak();  // Output - ohlllalalalalalaoaoaoa
// 10: invokevirtual #4 // Method org/programming/mitra/exercises/OverridingInternalExample$Mammal.speak:()V

Mammal humanMammal = new Human();
humanMammal.speak(); // Output - Hello
// 23: invokevirtual #4 // Method org/programming/mitra/exercises/OverridingInternalExample$Mammal.speak:()V

Human human = new Human();
human.speak(); // Output - Hello
// 36: invokevirtual #7 // Method org/programming/mitra/exercises/OverridingInternalExample$Human.speak:()V

human.speak("Hindi"); // Output - Namaste
// 42: invokevirtual #9 // Method org/programming/mitra/exercises/OverridingInternalExample$Human.speak:(Ljava/lang/String;)V
```
И, взглянув на приведенный выше код, мы можем видеть, что байт-коды humanMammal.speak (), human.speak () и human.speak ("хинди") совершенно разные, потому что компилятор может различать их на основе списка аргументов и ссылка на класс. И именно поэтому перегрузка метода известна как статический полиморфизм .

Но байт-код для anyMammal.speak () и humanMammal.speak () одинаков, потому что согласно компилятору оба метода вызываются по ссылке Mammal, но выходные данные для обоих вызовов метода различны, поскольку во время выполнения JVM знает, какой объект содержит ссылка, и вызовы JVM метод на объекте, и именно поэтому метод переопределения известен как динамический полиморфизм.

Итак, из приведенного выше кода и байт-кода ясно, что на этапе компиляции вызов метода рассматривается из ссылочного типа. Но во время выполнения метод будет вызываться из объекта, который содержит ссылка.