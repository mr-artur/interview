# ООП
+ [Что такое _ООП_?](#Что-такое-ООП)
+ [Основные понятия ООП: _«класс», «объект», «интерфейс»_](#Основные-понятия-ООП-класс-объект-интерфейс)
+ [Основные принципы _ООП_](#Основные-принципы-ООП)
+ [Что такое _«инкапсуляция»_?](#Что-такое-инкапсуляция)
    + [_Проблемы, которые решает инкапсуляция_](#Проблемы-которые-решает-инкапсуляция)
    + [_Преимущества инкапсуляции_](#Преимущества-инкапсуляции)
    + [_Пример инкапсуляции_](#Пример-инкапсуляции)
+ [Что такое _«наследование»_?](#Что-такое-наследование)
    + [_Проблемы, которые решает наследование_](#Проблемы-которые-решает-наследование)
    + [_Преимущества наследования_](#Преимущества-наследования)
    + [_Недостатки наследования_](#Недостатки-наследования)
    + [_Пример наследования_](#Пример-наследования)
+ [_Композиция или Наследование_](#Композиция-или-наследование)
    + [_Причины выбрать Композицию_](#Причины-выбрать-композицию)
    + [_Итог_](#Итог)
+ [Что такое _«полиморфизм»_?](#Что-такое-полиморфизм)
    + [_Проблемы, которые решает полиморфизм_](#Проблемы-которые-решает-полиморфизм)
    + [_Пример полиморфизма_](#Пример-полиморфизма)
        + [_Пример статического полиморфизма_](#Пример-статического-полиморфизма)
        + [_Пример динамического полиморфизма_](#Пример-динамического-полиморфизма)
        + [_Статический и динамический полифорфизм в байт-коде_](#Статический-и-динамический-полиморфизм-в-байт-коде)
+ [Что такое _«абстракция»_?](#Что-такое-абстракция)
    + [_Проблемы, которые решает абстракция_](#Проблемы-которые-решает-абстракция)
    + [_Пример абстракции_](#Пример-абстракции)
+ [_Преимущества ООП_](#Преимущества-ООП)
+ [_Недостатки ООП_](#Недостатки-ООП)
+ [Что такое _статическое_ и _динамическое связывание_?](#Что-такое-статическое-и-динамическое-связывание)
+ [_ООП vs Процедурное программирование_](#ООП-vs-Процедурное-программирование)
+ [_Абстрактный класс vs Интерфейс_](#Абстрактный-класс-vs-Интерфейс)
+ [_Method Overriding (Переопределение методов)_](#Method-Overriding-Переопределение-методов)
    + [_Пример переопределения метода_](#Пример-переопределения-метода)
+ [_Hiding (Скрытие)_](#Hiding-Скрытие)
    + [_Пример скрытия метода_](#Пример-скрытия-метода)
    + [_Пример скрытия переменной_](#Пример-скрытия-переменной)
+ [_Overloading (Перегрузка)_](#Overloading-Перегрузка)
    + [_Пример перегрузки метода_](#Пример-перегрузки-метода)

## Что такое _ООП_?
__Объектно-ориентированное программирование (ООП)__ — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования. 

+ объектно-ориентированное программирование использует в качестве основных логических конструктивных элементов объекты, а не алгоритмы;
+ каждый объект является экземпляром определенного класса 
+ классы образуют иерархии. 

Программа считается объектно-ориентированной, только если выполнены все три указанных требования. В частности, программирование, не использующее наследование, называется не объектно-ориентированным, а программированием с помощью абстрактных типов данных.

Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием, единственный способ изменить состояние объекта - послать ему сообщение, в ответ на которое, объект может изменить собственное состояние. 

## Основные понятия ООП: _«класс», «объект», «интерфейс»_
__Класс__ – это элемент ПО, описывающий абстрактный тип данных и его частичную или полную реализацию.
Простыми словами, это шаблон, по которому будут создаваться объекты.

С точки зрения программирования класс можно рассматривать как набор данных (полей, атрибутов, членов класса) и функций для работы с ними (методов).

С точки зрения структуры программы, класс является сложным типом данных.

__Объект (экземпляр)__ – это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом. Каждый объект имеет конкретные значения атрибутов и методы, работающие с этими значениями на основе правил, заданных в классе.

__Интерфейс__ – это набор методов класса, доступных для использования. Интерфейсом класса будет являться набор всех его публичных методов в совокупности с набором публичных атрибутов. По сути, интерфейс специфицирует класс, чётко определяя все возможные действия над ним.

## Основные принципы _ООП_
+ _Инкапсуляция_ - сокрытие реализации.
+ _Наследование_ - создание новой сущности на базе уже существующей.
+ _Полиморфизм_ - возможность иметь разные формы для одной и той же сущности.
+ _Абстракция_ - выделение во внешний интерфейс наиболее важных характеристик сущности

##  Что такое _«инкапсуляция»_?
__Инкапсуляция__ – это скрытие внутренних данных компонента и деталей его реализации от других компонентов программы и предоставление набора методов для взаимодействия с ним (API).

Цель инкапсуляции — уйти от зависимости внешнего интерфейса класса (то, что могут использовать другие классы) от реализации. Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса.

В языке _Java_ инкапсуляция реализована _с помощью_: 
+ _системы классов_, которые позволяют собрать информацию про объект в одном месте
+ _пакетов_, которые группируют классы по некоему критерию
+ _модификаторов доступа_, которыми можно обозначить весь класс, его поле или метод
+ _модулей_, новых программных компонентов, появившихся в Java 9

## _Проблемы, которые решает инкапсуляция_
+ Уменьшает зависимость внешнего интерфейса класса от деталей его реализации

## _Преимущества инкапсуляции_
+ _Она способствует повторному использованию компонентов_.

Поскольку в этом случае компоненты взаимодействуют между собой только через их API и являются нечувствительными к изменениям внутренней структуры, они могут использоваться в более широком контексте.

+ _Инкапсуляция ускоряет процесс разработки_.

Слабо связанные между собой компоненты(то есть, компоненты, чей код как можно меньше обращается или использует код других компонентов) могут разрабатываться, тестироваться и дополняться независимо.

+ _Упрощает поддержку программы_.

Правильно инкапсулированые компоненты более понятны и легче настраиваются, что позволяет легче поддерживать программу.

## _Пример инкапсуляции_
```java
public class Person {
    
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }       

    public int getAge() {
        return age;
    }   

    public void setAge(int age) {
        if (age <= 0) {
            throw new IllegalArgumentException("Age should be positive");
        }
        this.age = age;
    }   
}
```
В приведенном выше примере значение поля name задается при создании объекта и не может быть изменено, так как сеттер для данного поля отсутствует. В сеттере для переменной age реализована проверка на корректность параметра, который передается, и выброс эксепшена при неверном значении.

##  Что такое _«наследование»_?
__Наследование__ – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.

Класс, от которого производится наследование, называется предком, базовым или родительским. Новый класс – потомком, наследником или производным классом.

Наследование реализует отношение «IS-A» между суперклассом и подклассом.

## _Проблемы, которые решает наследование_
+ Наследование позволяет создавать иерархические структуры объектов.

Используя его, можно создать общий класс, который будет определять характеристики и поведение, свойственны некоему набору связанных объектов. В дальнейшем этот класс может наследоваться другими, второстепенными классами, каждый из которых будет добавлять уникальные, свойственные только ему характеристики и будет дополнять или изменять поведение базового класса.

## _Преимущества наследования_

+ _Повторное использование программ_.

При наследовании поведения от другого класса программный код не переписывается. Другое преимущество повторно используемого кода – в его надежности (чем в большем числе ситуаций используется код, тем больше возможностей обнаружения ошибок) и низкой стоимости, так как она делится на всех пользователей кода.

## _Недостатки наследования_

+ _Размер программ_.

Использование любой программной библиотеки часто приводит к увеличению размера программ. Этого не происходит в специально разработанных системах. Хотя такие затраты могут быть существенными, по мере уменьшения стоимости памяти размер программы перестает быть критичным. Снизить затраты на разработку и быстро выдать качественный и свободный от ошибок программный код иногда значит гораздо больше, чем малый размер приложения.

+ _Сложность программ_.

Необдуманное использование наследования может вместо разрешения проблемы сложности подействовать наоборот. Для понимания программы, использующей наследование, может потребоваться несколько сложных переходов вверх и вниз в иерархическом дереве.

## _Пример наследования_
```java
class Employee {
    
    private String name;
    private double salary;

    // constructors

    public String getSalary() {
        return salary;
    }       
}

class Manager extends Employee {
    
    private double bonusPercentage;

    // constructors

    public double getSalary() {
        return super.salary * (100 + bonusPercentage) / 100;
    }
}
```
В этом примере Employee является базовым классом для Manager, а класс Manager - подклассом класса Employee. Класс Employee абстрагирует базовые характеристики для всех сотрудников компании - имя и зарплату, а класс Manager дополняет эти характеристики процентом премии для менеджеров и меняет поведение метода getSalary() базового класса, используя полиморфизм.

## _Композиция или Наследование_
Главное отличие между композицией и наследованием заключается в том, что композиция даёт возможность переиспользовать код без расширения существующего класса, как это происходит в случае с наследованием.

#### _Причины выбрать Композицию_
+ _Гибкость_

Одно из первых отличий связано с гибкостью кода. Используя наследование, мы должны описывать, какой класс расширяем, причём мы не сможем заменить его в процессе выполнения программы. Иначе обстоит дело с композицией: мы можем определить используемый тип, а он, в свою очередь, может включать несколько разных реализаций. В результате __композиция предоставляет нам больше гибкости__.

+ _Ограниченное повторное применение кода при наследовании_

Унаследоваться в Java возможно лишь от одного класса, т. е. мы можем повторно использовать только один класс. Если же нам нужна функциональность нескольких классов, необходимо использовать композицию. Например, если код должен использовать аутентификацию, то нужно унаследовать класс Authenificator, а при авторизации — Autorizer и т. п. Но т. к. множественное наследование не поддерживается, нам опять остаётся композиция.

+ _Юнит-тесты_

Следующий важнейший аргумент заключается в том, что классы, которые расширены посредством композиции, тестировать легче, ведь всегда можно предоставить для используемого класса заглушку. Что касается наследования, то нам для тестирования потребуется родительский класс, ведь его заменить заглушкой не выйдет.

+ _Final-классы_

Очередное ограничение наследования — нельзя расширить final-классы. В языке программирования Java отсутствует возможность унаследования от final-классов, в результате чего мы опять приходим к тому, что для повторного использования кода больше подходит композиция.

+ _Инкапсуляция_

Теперь поговорим об отношении композиции и наследования к инкапсуляции. С одной стороны, можно сказать, что обе техники дают возможность повторно использовать код. Так-то оно так, но __наследование нарушает принцип инкапсуляции__, и всё дело в том, что подкласс имеет зависимость от поведения класса-родителя. Если же родительский класс поменяет свой поведение, это отразится и на его потомках. Например, если классы будут плохо документированы, а класс-потомок будет неправильно использовать родительский класс, при любом изменении класса-родителя __функциональность потомка будет поломана__. Об этом, кстати, можно почитать в книге «Effective Java», в главах 16 и 17.  

#### _Итог_
Обе техники служат одной цели — для повторного применения протестированных и проверенных участков Java-кода. Только вот делают они это по-разному. Композиция даёт нам возможность защитить повторно используемый класс от клиентов, в то время как наследование это не гарантирует. Но несмотря на это, __в некоторых случаях наследование просто необходимо__. Например, если вы создаёте классы из одного семейства.

##  Что такое _«полиморфизм»_?
__Полиморфизм__ – это свойство системы, которое позволяет с помощью вызова переопределенного метода через переменную родительского класса получить поведение, которое будет соответствовать реальному производному классу, на объект которого ссылается эта переменная.

Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного и того же интерфейса для задания единого набора действий. Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор языка программирования. Отсюда следует ключевая особенность полиморфизма - использование объекта производного класса, вместо объекта базового (потомки могут изменять родительское поведение, даже если обращение к ним будет производиться по ссылке родительского типа).

## _Проблемы, которые решает полиморфизм_
+ Уменьшение связанности клиентского класса с реализацией.

Большим преимуществом и целью использования полиморфизма является уменьшение связанности клиентского класса с реализацией. Вместо того чтобы хардкодить, клиентский класс получает реализацию зависимости для выполнения необходимого действия. Таким образом, клиентский класс знает минимум для выполнения своих действий, что является примером слабого связывания.

## _Пример полиморфизма_
```java
public abstract class SweetProducer {
  public abstract void produceSweet();
}

public class CakeProducer extends SweetProducer {
  @Override
  public void produceSweet() {
    System.out.println("Cake produced");
  }
}

public class ChocolateProducer extends SweetProducer {
  @Override
  public void produceSweet() {
    System.out.println("Chocolate produced");
  }
}

public class CookieProducer extends SweetProducer {
  @Override
  public void produceSweet() {
    System.out.println("Cookie produced");
  }
}

public class SweetCreator {
  private List<SweetProducer> sweetProducer;

  public SweetCreator(List<SweetProducer> sweetProducer) {
    this.sweetProducer = sweetProducer;
  }

  public void createSweets() {
    sweetProducer.forEach(sweet -> sweet.produceSweet());
  }
}

public class SweetCreatorTest {
  public static void main(String... args) {
    SweetCreator sweetCreator = new SweetCreator(Arrays.asList(
      new CakeProducer(),
      new ChocolateProducer(), 
      new CookieProducer()));

     sweetCreator.createSweets();
  }
}
```
В данном примере класс SweetCreator знает только о классе SweetProducer. Он не знает реализации каждого Sweet. Такое разделение дает нам гибкость для обновления и повторного использования наших классов, а это делает код намного проще в сопровождении.

## _Виды полиморфизма_
Различают __статический__ и __динамический__ полиморфизм.

_Статический_ - это полиморфизм, проявляющийся во время компиляции. Здесь компилятор Java знает, какой метод вызывается.

Перегрузка метода является примером времени компиляции / статического полиморфизма, поскольку привязка метода между вызовом метода и определением метода происходит во время компиляции и зависит от ссылки на класс (ссылка создается во время компиляции и отправляется в стек).

#### _Пример статического полиморфизма_
```java
class Calculation { 
 
    void sum(int a, int b) {
        System.out.println(a + b);
    }  

     void sum(int a, int b, int c) {
        System.out.println(a + b + c);
    }  

    public static void main(String[] args) {  
        Calculation obj = new Calculation();  
        obj.sum(10, 10, 10);
        obj.sum(20, 20);
  }  
} 
```

_Динамический_ - это полиморфизм, существовавший во время выполнения. Здесь компилятор Java не понимает, какой метод вызывается во время компиляции. Только JVM решает, какой метод вызывается во время выполнения. 

Переопределение метода является примером динамического полиморфизма во время выполнения, потому что привязка метода между вызовом метода и определением метода происходит во время выполнения и зависит от объекта класса (объект создается во время выполнения и перемещается в кучу).

#### _Пример динамического полиморфизма_
```java
class Animal {    
   public void move() {
      System.out.println("Animals can move");
   }
}

class Dog extends Animal {
   public void move() {
      System.out.println("Dogs can walk and run");
   }
}

public class TestDog {
   public static void main(String args[]) {
      Animal a = new Animal();
      Animal b = new Dog();

      a.move();// output: Animals can move

      b.move();// output: Dogs can walk and run
   }
}
```

#### _Статический и динамический полифорфизм в байт-коде_
Создадим такие классы :
```java
class Mammal {
    public void speak() { 
        System.out.println("ohlllalalalalalaoaoaoa");
     }
}

class Human extends Mammal {

    @Override
    public void speak() { 
        System.out.println("Hello"); 
    }

    public void speak(String language) {
        if (language.equals("Hindi")) {
            System.out.println("Namaste");
        }
        else System.out.println("Hello");
    }
}
```
Вывод и байт-код :
```java
Mammal anyMammal = new Mammal();
anyMammal.speak();  // Output - ohlllalalalalalaoaoaoa
// 10: invokevirtual #4 // Method org/programming/mitra/exercises/OverridingInternalExample$Mammal.speak:()V

Mammal humanMammal = new Human();
humanMammal.speak(); // Output - Hello
// 23: invokevirtual #4 // Method org/programming/mitra/exercises/OverridingInternalExample$Mammal.speak:()V

Human human = new Human();
human.speak(); // Output - Hello
// 36: invokevirtual #7 // Method org/programming/mitra/exercises/OverridingInternalExample$Human.speak:()V

human.speak("Hindi"); // Output - Namaste
// 42: invokevirtual #9 // Method org/programming/mitra/exercises/OverridingInternalExample$Human.speak:(Ljava/lang/String;)V
```
И, взглянув на приведенный выше код, мы можем видеть, что байт-коды humanMammal.speak (), human.speak () и human.speak ("хинди") совершенно разные, потому что компилятор может различать их на основе списка аргументов и ссылка на класс. И именно поэтому перегрузка метода известна как статический полиморфизм .

Но байт-код для anyMammal.speak () и humanMammal.speak () одинаков, потому что согласно компилятору оба метода вызываются по ссылке Mammal, но выходные данные для обоих вызовов метода различны, поскольку во время выполнения JVM знает, какой объект содержит ссылка, и вызовы JVM метод на объекте, и именно поэтому метод переопределения известен как динамический полиморфизм.

Итак, из приведенного выше кода и байт-кода ясно, что на этапе компиляции вызов метода рассматривается из ссылочного типа. Но во время выполнения метод будет вызываться из объекта, который содержит ссылка.

##  Что такое _«абстракция»_?
__Абстракция__ – это выделение во внешний интерфейс наиболее важных характеристик сущности. Таким образом, фокусирование разработчика на конкретных характеристиках объекта зависит от тех задач, которые должен решать объект.
 
 В языке Java абстракция реализовуется с помощью абстрактных классов и интерфейсов.
 
## _Проблемы, которые решает абстракция_
 + Уменьшает видимую снаружи сложность
 + Помогает избежать дубликации кода
 + Помогает в переиспользовании компонентов
 + Помогает улучшить защиту программы, так как только нужные детали показываются пользователю
  
## _Пример абстракции_
 ```java
abstract class Animal {
    public abstract void animalSound();

    public void sleep() {
        System.out.println("Zzz");
    }
}

class Pig extends Animal {
    public void animalSound() {
        // The body of animalSound() is provided here
        System.out.println("The pig says: wee wee");
    }
}

class MyMainClass {
    public static void main(String[] args) {
        Pig myPig = new Pig();
        myPig.animalSound();
        myPig.sleep();
    }
}
 ```
 В данном примере абстракция выносится в класс Animal, который содержит как абстрактный метод animalSound, так и уже реализованный метод sleep, который будет наследоваться всеми потомками класса Animal.
 
## _Преимущества ООП_

 + Ориентация на предметную область, а не на компьютерную реализацию
 + Возможность создания расширяемой системы
 + Данные и операции над ними образуют определенную сущность, и они не разносятся по всей программе, как нередко бывает в случае процедурного программирования, а описываются вместе. Локализация кода и данных улучшает наглядность и удобство сопровождения программного обеспечения.
 + Инкапсуляция позволяет привнести свойство модульности, что облегчает распараллеливание выполнения задачи между несколькими исполнителями и обновление версий отдельных компонентов.
 + Использование полиморфизма оказывается полезным при:
     + Обработке разнородных структур данных. Программы могут работать, не различая вида объектов, что существенно упрощает код. Новые виды могут быть добавлены в любой момент.
     + Изменении поведения во время исполнения. На этапе исполнения один объект может быть заменен другим, что позволяет легко, без изменения кода, адаптировать алгоритм в зависимости от того, какой используется объект.
     + Реализации работы с наследниками. Алгоритмы можно обобщить настолько, что они уже смогут работать более чем с одним видом объектов.
     + Возможности описать независимые от приложения части предметной области в виде набора универсальных классов, или фреймворка, который в дальнейшем будет расширен за счет добавления частей, специфичных для конкретного приложения.
 + Повторное использование кода:
     + Сокращается время на разработку, которое может быть отдано другим задачам.
     + Компоненты многоразового использования обычно содержат гораздо меньше ошибок, чем вновь разработанные, ведь они уже не раз подвергались проверке.
     + Когда некий компонент используется сразу несколькими клиентами, улучшения, вносимые в его код, одновременно оказывают положительное влияние и на множество работающих с ним программ.
     + Если программа опирается на стандартные компоненты, ее структура и пользовательский интерфейс становятся более унифицированными, что облегчает ее понимание и упрощает использование.
     
## _Недостатки ООП_
  + В сложных иерархиях классов поля и методы обычно наследуются с разных уровней. И не всегда легко определить, какие поля и методы фактически относятся к данному классу.
  + Код для обработки сообщения иногда «размазан» по многим методам (иначе говоря, обработка сообщения требует не одного, а многих методов, которые могут быть описаны в разных классах).
  + Документирование классов - задача более трудная, чем это было в случае процедур и модулей. Поскольку любой метод может быть переопределен, в документации должно говориться не только о том, что делает данный метод, но и о том, в каком контексте он вызывается.
  + Неэффективность и неэкономное распределения памяти на этапе выполнения (по причине издержек на динамическое связывание и проверки типов на этапе выполнения).
  + Излишняя универсальность. Часто содержится больше методов, чем это реально необходимо текущей программе. А поскольку лишние методы не могут быть удалены, они становятся мертвым грузом.   
  
 ## Что такое _статическое_ и _динамическое связывание_?
 Присоединение вызова метода к телу метода называется связыванием. Если связывание проводится компилятором (компоновщиком) перед запуском программы, то оно называется _статическим_ или _ранним связыванием (early binding)_.
 
 В свою очередь, _позднее связывание (late binding)_ это связывание, проводимое непосредственно во время выполнения программы, в зависимости от типа объекта. Позднее связывание также называют _динамическим (dynamic)_ или _связыванием на стадии выполнения (runtime binding)_. В языках, реализующих позднее связывание, должен существовать механизм определения фактического типа объекта во время работы программы, для вызова подходящего метода. Иначе говоря, компилятор не знает тип объекта, но механизм вызова методов определяет его и вызывает соответствующее тело метода. Механизм позднего связывания зависит от конкретного языка, но нетрудно предположить, что для его реализации в объекты должна включаться какая-то дополнительная информация.
 
 Для всех методов Java используется механизм позднего (динамического) связывания, если только метод не был объявлен как `final` (приватные методы являются `final` по умолчанию).
 
## _ООП vs Процедурное программирование_
_Процедурное программирование_ можно использовать, когда задача состоит из последовательности действий, которые при этом не будут сильно изменяться в перспективе.
 
_ООП_ же можно использовать для решения более сложных задач. Благодаря разделению ответственности между объектами программы, большая программа, написанная с использованием ООП, будет более устойчива к изменениям.
 
[Пример с проектом по недвижимости](http://artanovy.com/2011/03/procedurnoe-protiv-obyektno-orientirovannogo/)
 
В данном примере описываются два варианта построения системы - с помощью ПП и ООП и насколько второй оказывается устойчивее к изменениям.
 
Как вывод можно сказать :
1. ООП хорошо подходит для создания больших систем, в которые будет необходимо вносить изменения
2. В проекте с ООП возможность повторного использования кода будет встречаться чаще
3. Проект с ООП будет легче поддаваться автоматическому тестированию
 
## _Абстрактный класс vs Интерфейс_
_Отличия_ между абстрактным классом и интерфейсом :
1. Интерфейс описывает только поведение, но не хранит состояние(у него могут быть только статические поля). Абстрактный класс же может описывать и состояние, и поведение.
2. Абстрактный класс связывает классы, близкие по содержанию, интерфейс же может быть реализован вообще никак не связанными между собой классами.
3. Классы могут реализовывать сколько угодно интерфейсов, но наследоваться можно только от одного класса.
4. Методы в интерфейсе могут быть только public и abstract - по умолчанию они уже такие. В абстрактным классам же к неабстрактным методам применымы любые модификаторы, а абстрактные методы могут быть public и protected.

_Использовать абстрактный класс_ следует когда :
1. Собираемся использовать наследование, чтобы например вынести общую логику или данные в базовый класс.
2. Если мы считаем, что в будущем надо будет добавлять новые общие методы (В случае интерфейса надо будет их реализовывать в каждой имплементации).

_Использовать интерфейс_ следует когда :
1. Нам необходимо создать общий интерфейс для работы с объектами абсолютно разных классов. При этом работа эта будет выполняться в каждом классе по своему. Например, интерфейс Serializable или Cloneable.
2. Нам необходимо создать множественное наследование
3. Нам необходимо создать контракт для работы с какой-то абстракцией, чтобы в будущем можно было заменить имплементацию без изменений в клиентском коде. Пример - интерфейсы дао / сервисов
 
## _Method Overriding (Переопределение методов)_
_Method overriding_ - это изменение non-static, non-final метода в классе-наследнике, который он унаследовал от класса-родителя

Переопределение методов является примером динамического полиморфизма.

+ Понятия variable overriding __не существует__.
+ При оверрайдинге происходит __runtime binding__
 
Метод считается _overrided_, если :
1. Имя в классе-наследнике такое-же, что и в классе-родителе
2. Список аргументов в классе-наследнике такой же, что и в классе-родителе
3. Возвращаемый тип в классе-наследнике такой же, что и в классе-родителе, или возвращаемый тип в классе-наследнике - тип-наследник возвращаемого типа из класса-родителя(ковариантный возвращаемый тип)
4. Модификатор доступа в классе-наследнике такой же или менее строгий, чем в классе-родителе
5. Метод в классе-наследнике тоже должен быть non-static

#### Пример переопределения метода
```java
class Parent { 

    void show() { 
        System.out.println("Parent's show()"); 
    } 
} 
  
class Child extends Parent { 

    @Override
    void show() { 
        System.out.println("Child's show()"); 
    } 
} 

// где-то в клиентском коде
Child.printMessage(); // child static method
```
 
## _Hiding (Скрытие)_
Существуют 2 вида хайдинга - _method hiding_ и _variable hiding_.

+ В отличии от оверрайдинга, при хайдинге происходит __compile time binding__.

_Method hiding_ - это перекрытие статических методов из родительского класса в классе-наследнике.

Метод считается _hidden_, если :
1. Имя в классе-наследнике такое-же, что и в классе-родителе
2. Список аргументов в классе-наследнике такой же, что и в классе-родителе
3. Возвращаемый тип в классе-наследнике такой же, что и в классе-родителе, или возвращаемый тип в классе-наследнике - тип-наследник возвращаемого типа из класса-родителя(ковариантный возвращаемый тип)
4. Модификатор доступа в классе-наследнике такой же или менее строгий, чем в классе-родителе
5. Метод в классе-наследнике тоже должен быть статическим

#### Пример скрытия метода
```java
public class Parent {
 
    public static void printMessage() {
        System.out.println("parent static method");
    }
}

public class Child extends Parent {
 
    public static void printMessage() {
        System.out.println("child static method");
    }
}

// где-то в клиентском коде
Parent parent = new Parent(); 
parent.show(); // parent static method
Parent child = new Child(); 
child.show(); // child static method
```

_Variable hiding_ - объявление в классе-наследнике переменной с таким же именем (не обязательно типом), что и в классе-родителе.

#### Пример скрытия переменной
```java
public class Parent {
 
    String instanceVariable = "parent variable";
}

public class Child extends Parent {
 
    String instanceVariable = "child variable";
 
    public void printInstanceVariable() {
        System.out.println(instanceVariable);
    }
}

// где-то в клиентском коде
Parent parent = new Parent();
Parent child= = new Child();
 
parent.printInstanceVariable(); // parent variable
child.printInstanceVariable(); // child variable
```

## _Overloading (Перегрузка)_
_Overloading_ - это механизм, который позволяет создавать методы с одним и тем же именем, но с разными типами и/или количеством параметров.

Перегрузка является примером статического полиморфизма.

#### Пример перегрузки метода
```java
public class Program {
      
    public static void main(String[] args) {
        System.out.println(sum(2, 3));
        System.out.println(sum(4.5, 3.2)); 
        System.out.println(sum(4, 3, 7));
    }

    static int sum(int x, int y) {
        return x + y;
    }

    static double sum(double x, double y) {
        return x + y;
    }

    static int sum(int x, int y, int z) {
        return x + y + z;
    }
}
```
Стоит отметить, что на перегрузку методов влияют количество и типы параметров. Однако различие в типе возвращаемого значения для перегрузки не имеют никакого значения.
Пример ниже не считается перегрузкой.
##### Пример ниже перегрузкой не считается 
```java
public class Program {
      
    public static void main(String[] args) {
        System.out.println(sum(2, 3));
        System.out.println(sum(4, 3));
    }

    static int sum(int x, int y) {
        return x + y;
    }

    static double sum(int x, int y) {
        return x + y;
    }
}
```
 