## Что такое _ООП_?
__Объектно-ориентированное программирование (ООП)__ — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования. 

+ объектно-ориентированное программирование использует в качестве основных логических конструктивных элементов объекты, а не алгоритмы;
+ каждый объект является экземпляром определенного класса 
+ классы образуют иерархии. 

Программа считается объектно-ориентированной, только если выполнены все три указанных требования. В частности, программирование, не использующее наследование, называется не объектно-ориентированным, а программированием с помощью абстрактных типов данных.

Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием, единственный способ изменить состояние объекта - послать ему сообщение, в ответ на которое, объект может изменить собственное состояние. 

## Основные понятия ООП: _«класс», «объект», «интерфейс»_
__Класс__ – это элемент ПО, описывающий абстрактный тип данных и его частичную или полную реализацию.
Простыми словами, это шаблон, по которому будут создаваться объекты.

С точки зрения программирования класс можно рассматривать как набор данных (полей, атрибутов, членов класса) и функций для работы с ними (методов).

С точки зрения структуры программы, класс является сложным типом данных.

__Объект (экземпляр)__ – это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом. Каждый объект имеет конкретные значения атрибутов и методы, работающие с этими значениями на основе правил, заданных в классе.

__Интерфейс__ – это набор методов класса, доступных для использования. Интерфейсом класса будет являться набор всех его публичных методов в совокупности с набором публичных атрибутов. По сути, интерфейс специфицирует класс, чётко определяя все возможные действия над ним.

## Основные принципы _ООП_
+ _Инкапсуляция_ - сокрытие реализации.
+ _Наследование_ - создание новой сущности на базе уже существующей.
+ _Полиморфизм_ - возможность иметь разные формы для одной и той же сущности.
+ _Абстракция_ - выделение во внешний интерфейс наиболее важных характеристик сущности

##  Что такое _«инкапсуляция»_?
__Инкапсуляция__ – это скрытие внутренних данных компонента и деталей его реализации от других компонентов программы и предоставление набора методов для взаимодействия с ним (API).

Цель инкапсуляции — уйти от зависимости внешнего интерфейса класса (то, что могут использовать другие классы) от реализации. Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса.

В языке _Java_ инкапсуляция реализована _с помощью_: 
+ _системы классов_, которые позволяют собрать информацию про объект в одном месте
+ _пакетов_, которые группируют классы по некоему критерию
+ _модификаторов доступа_, которыми можно обозначить весь класс, его поле или метод

## _Проблемы, которые решает инкапсуляция_
+ Уменьшает зависимость внешнего интерфейса класса от деталей его реализации

## _Преимущества инкапсуляции_
+ _Она способствует повторному использованию компонентов_.

Поскольку в этом случае компоненты взаимодействуют между собой только через их API и являются нечувствительными к изменениям внутренней структуры, они могут использоваться в более широком контексте.

+ _Инкапсуляция ускоряет процесс разработки_.

Слабо связанные между собой компоненты(то есть, компоненты, чей код как можно меньше обращается или использует код других компонентов) могут разрабатываться, тестироваться и дополняться независимо.

+ _Упрощает поддержку программы_.

Правильно инкапсулированые компоненты более понятны и легче настраиваются, что позволяет легче поддерживать программу.

## _Пример инкапсуляции_
```java
public class Person {
    
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }       

    public int getAge() {
        return age;
    }   

    public void setAge(int age) {
        if (age <= 0) {
            throw new IllegalArgumentException("Age should be positive");
        }
        this.age = age;
    }   
}
```
В приведенном выше примере значение поля name задается при создании объекта и не может быть изменено, так как сеттер для данного поля отсутствует. В сеттере для переменной age реализована проверка на корректность параметра, который передается, и выброс эксепшена при неверном значении.

##  Что такое _«наследование»_?
__Наследование__ – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.

Класс, от которого производится наследование, называется предком, базовым или родительским. Новый класс – потомком, наследником или производным классом.

Наследование реализует отношение «IS-A» между суперклассом и подклассом.

## _Проблемы, которые решает наследование_
+ Наследование позволяет создавать иерархические структуры объектов.

Используя его, можно создать общий класс, который будет определять характеристики и поведение, свойственны некоему набору связанных объектов. В дальнейшем этот класс может наследоваться другими, второстепенными классами, каждый из которых будет добавлять уникальные, свойственные только ему характеристики и будет дополнять или изменять поведение базового класса.

## _Преимущества наследования_

+ _Повторное использование программ_.

При наследовании поведения от другого класса программный код не переписывается. Другое преимущество повторно используемого кода – в его надежности (чем в большем числе ситуаций используется код, тем больше возможностей обнаружения ошибок) и низкой стоимости, так как она делится на всех пользователей кода.

## _Недостатки наследования_

+ _Размер программ_.

Использование любой программной библиотеки часто приводит к увеличению размера программ. Этого не происходит в специально разработанных системах. Хотя такие затраты могут быть существенными, по мере уменьшения стоимости памяти размер программы перестает быть критичным. Снизить затраты на разработку и быстро выдать качественный и свободный от ошибок программный код иногда значит гораздо больше, чем малый размер приложения.

+ _Сложность программ_.

Необдуманное использование наследования может вместо разрешения проблемы сложности подействовать наоборот. Для понимания программы, использующей наследование, может потребоваться несколько сложных переходов вверх и вниз в иерархическом дереве.

## _Пример наследования_
```java
class Employee {
    
    private String name;
    private double salary;

    // constructors

    public String getSalary() {
        return salary;
    }       
}

class Manager extends Employee {
    
    private double bonusPercentage;

    // constructors

    public double getSalary() {
        return super.salary * (100 + bonusPercentage) / 100;
    }
}
```
В этом примере Employee является базовым классом для Manager, а класс Manager - подклассом класса Employee. Класс Employee абстрагирует базовые характеристики для всех сотрудников компании - имя и зарплату, а класс Manager дополняет эти характеристики процентом премии для менеджеров и меняет поведение метода getSalary() базового класса, используя полиморфизм.
