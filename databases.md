# Базы данных
+ [Что такое база данных?](#Что-такое-база-данных)
+ [Что такое СУБД ?](#Что-такое-СУБД)
+ [Типы баз данных](#Типы-баз-данных)
+ [Реляционные базы данных](#Реляционные-базы-данных)
    + [Пример структуры реляционной базы данных](#Пример-структуры-реляционной-базы-данных)
    + [Главные аспекты реляционной базы данных](#Главные-аспекты-реляционной-базы-данных)
    + [Реляционные базы данных](#Примеры-реляционных-баз-данных)
+ [Нереляционные базы данных](#Нереляционные-базы-данных)
    + [Базы данных _ключ-значение_](#Базы-данных-ключ-значение)
        + [Пример структуры базы данных _ключ-значение_](#Пример-структуры-базы-данных-ключ-значение)
        + [Преимущества баз данных _ключ-значение_](#Преимущества-баз-данных-ключ-значение)
        + [Недостатки баз данных _ключ-значение_](#Недостатки-баз-данных-ключ-значение)
        + [Примеры баз данных _ключ-значение_](#Примеры-баз-данных-ключ-значение)
    + [_Документные_ базы данных](#Документные-базы-данных)
        + [Пример структуры _документной_ базы данных](#Пример-структуры-документной-базы-данных)
        + [Преимущества _документных_ баз данных](#Преимущества-документных-баз-данных)
        + [Недостатки _документных_ баз данных](#Недостатки-документных-баз-данных)
        + [Примеры _документных_ баз данных](#Примеры-документных-баз-данных)
    + [_Колоночные_ базы данных ](#Колоночные-базы-данных)
        + [Пример структуры _колоночной_ базы данных](#Пример-структуры-колоночной-базы-данных)
        + [Преимущества _колоночных_ баз данных](#Преимущества-колоночных-баз-данных)
        + [Недостатки _колоночных_ баз данных](#Недостатки-колоночных-баз-данных)
        + [Примеры _колоночных_ баз данных](#Примеры-колоночных-баз-данных)
    + [_Графовые_ базы данных](#_Графовые-базы-данных)
        + [Пример 1 структуры _графовой_ базы данных](#Пример-1-структуры-графовой-базы-данных)
        + [Пример 2 структуры _графовой_ базы данных](#Пример-2-структуры-графовой-базы-данных)
        + [Преимущества _графовых_ баз данных](#Преимущества-графовых-баз-данных)
        + [Недостатки _графовых_ баз данных](#Недостатки-графовых-баз-данных)	
        + [Примеры _графовых_ баз данных](#Примеры-графовых-баз-данных)	
    + [Базы данных _временных рядов_](#Базы-данных-временных-рядов)
        + [Пример структуры базы данных _временных рядов_](#Пример-структуры-базы-данных-временных-рядов)
        + [Преимущества баз данных _временных рядов_](#Преимущества-баз-данных-временных-рядов)
        + [Недостатки баз данных _временных рядов_](#Недостатки-баз-данных-временных-рядов)
        + [Примеры баз данных _временных рядов_](#Примеры-баз-данных-временных-рядов)		
+ [Когда нужно использовать _SQL_ базы данных, а когда _NoSQL_?](#Когда-нужно-использовать-SQL-базы-данных-а-когда-NoSQL)
    + [Причины выбрать _SQL_ базу данных](#Причины-выбрать-SQL-базу-данных)
    + [Причины выбрать _NoSQL_ базу данных](#Причины-выбрать-NoSQL-базу-данных)
    + [Свойства проектов, для которых подойдут _SQL_ базы данных](#Свойства-проектов-для-которых-подойдут-SQL-базы-данных)  		
	+ [Свойства проектов, для которых подойдут _NoSQL_ базы данных](#Свойства-проектов-для-которых-подойдут-NoSQL-базы-данных)
+ [_Race condition_](#Race-condition)
    + [Пример _Race condition_](#Пример-Race-condition)
+ [_ACID_](#ACID)
    + [Atomicity](#Atomicity)
    + [Consistency](#Consistency)
    + [Isolation](#Isolation)
    + [Durability](#Durability)

## Что такое база данных?
_База данных_ - это организованная структура, которая служит для хранения информации, в основном, в больших объемах.

[к оглавлению](#Базы-данных)

## Что такое СУБД ?
_СУБД_ (Система управления базами данных) - это высокоуровневое программное обеспечение, работающее с низкоуровневыми API. 

Примеры СУБД : MySQL, PostgreSQL, Redis и т.д.

[к оглавлению](#Базы-данных)

## Типы баз данных
Базы данных можно поделить на `4` типа :
+ Простейшие базы данных. Их подтипами являются :
    + Текстовые файлы - самые простые структуры данных
    + Иерархические базы данных
    + Сетевые базы данных
+ _SQL_ (Реляционные базы данных)
+ _NoSQL_ базы данных. Их подтипами являются :
    + Базы данных "ключ-значение"
    + Документные базы данных
    + Графовые базы данных
    + Колоночные базы данных
    + Базы данных временных рядов
+ Комбинированные базы данных. Их подтипами являются :
    + NewSQL базы данных
    + Многомодельные базы данных
    
[к оглавлению](#Базы-данных)

## Реляционные базы данных
+ _Реляционные базы данных_ (SQL) - это структуры данных, в которых данные и связи между ними организованы в виде таблиц, состоящих из столбцов и строк. 
+ Каждый столбец в таблице имеет имя и тип.
+ Каждая строка представляет отдельную запись таблицы.
+ Каждая строка может быть помечена уникальным идентификатором, который называется первичный ключ (_primary key_).
+ Строки из нескольких таблиц могут быть связаны с помощью первичных ключей. Когда в одной таблице находится ссылка на первичный ключ из другой таблицы, он в ней называется вторичный ключ (_foreign key_).
    
[к оглавлению](#Базы-данных)
    
### Пример структуры реляционной базы данных

![alt text](https://media.proglib.io/posts/2020/01/06/f709d081e7f944f3a35431ad8c371d6c.png)

[к оглавлению](#Базы-данных)

### Главные аспекты реляционной базы данных

Главными аспектами реляционной базы данных являются :
+ SQL (Structured Query Language) - язык структурированных запросов, с помощью которого происходят все действия с базой данных, такие как например добавление, чтение, модификация, удаление строк и т.д.
+ Целостность данных - это их корректность и непротиворечивость. Для ее поддержания в реляционных БД используются разные инструменты :
    + первичные ключи (_primary keys_)
    + вторичные ключи (_foreign keys_)
    + _constraints_ :
        + `NOT NULL`
        + `UNIQUE`
        + `DEFAULT`
        + `CHECK`
  
 Все они помогают гарантировать корректность и непротиворечивость данных в базе.
+ Транзакции - это один или несколько SQL операторов, которые выполняются как единое целое. Если хотя бы в одной из этих операций произойдет ошибка, все изменения, внесенные остальными, отменяются. Таким образом, транзакция может завершиться двумя действиями : либо `COMMIT`, либо `ROLLBACK`.
+ Соответствие требованиям _ACID_. Для соблюдения целостности данных в базе все транзакции должны соответствовать следующим требованиям :
    + Atomicity
    + Consistency
    + Isolation
    + Durability

[к оглавлению](#Базы-данных)

### Примеры реляционных баз данных
+ PostgreSQL
+ MySQL
+ Oracle
+ MariaDB
+ SQLite

[к оглавлению](#Базы-данных)

## Нереляционные базы данных
+ _Нереляционные базы данных (NoSQL)_ - это такие базы данных, в которых нету четкой структуры хранимых данных, от которой нельзя было бы отклоняться при сохранении новых записей.
+ _NoSQL_ базы данных, как правило, не работают с _SQL_, и как правило, у каждой такой БД своя структура запросов.
+ Структура нереляционных баз данных от одной базы к другой может сильно различаться.

[к оглавлению](#Базы-данных)

### Базы данных _ключ-значение_
+ Базы данных _ключ-значение_ являются подвидом нереляционных баз данных.
+ В основе таких баз данных обычно лежит большая хеш-таблица, содержащая пары ключей со значениями.

[к оглавлению](#Базы-данных)

### Пример структуры базы данных _ключ-значение_
![alt text](https://media.proglib.io/wp-uploads/2018/01/1swUK-eLWsk-wudXSXRgyYQ.png)

[к оглавлению](#Базы-данных)

### Преимущества баз данных _ключ-значение_
+ Простая реализация.
+ Высокая производительность за счет хеширования.

[к оглавлению](#Базы-данных)

### Недостатки баз данных _ключ-значение_
+ Нету ни транзакций, ни соответствия _ACID_, то есть фактически, нет и гарантий сохранения целостности данных в базе.
+ При увеличении объемов данных может стать проблемой поддержание уникальности ключей.
+ Не подходит для поиска значений по больше чем одному атрибуту.
+ Плоха при сложных параметрах запросов.

[к оглавлению](#Базы-данных)

### Примеры баз данных _ключ-значение_
+ Redis
+ memcached
+ DynamoDB
+ etcd
+ Riak

[к оглавлению](#Базы-данных)

### _Документные_ базы данных
+ _Документные_ базы данных являются подвидом нереляционных баз данных.
+ Похожи на базы данных _ключ-значение_, но только в значении тут могут храниться только структурированные документы в формате _JSON_, _BSON_ или _XML_.
+ В отличии от баз данных _ключ-значение_, в них можно делать запросы на основе содержимого, то есть например найти все машины, в которых город производства равен определенному.

[к оглавлению](#Базы-данных)

### Пример структуры _документной_ базы данных
![alt text](https://media.proglib.io/wp-uploads/2018/01/1gdxUo2ojiTX2JQIkA2hxcQ.png)

[к оглавлению](#Базы-данных)

### Преимущества _документных_ баз данных
+ Хороши для быстрой разработки
+ БОльшая гибкость при доступе к данным, чем в базах данных _ключ-значение_.

[к оглавлению](#Базы-данных)

### Недостатки _документных_ баз данных
+ Нету ни транзакций, ни соответствия _ACID_, то есть фактически, нет и гарантий сохранения целостности данных в базе.

[к оглавлению](#Базы-данных)

### Примеры _документных_ баз данных
+ MongoDB
+ Apache CouchDB
+ RethinkDB

[к оглавлению](#Базы-данных)

### _Колоночные_ базы данных    
+ _Колоночные_ базы данных являются подвидом нереляционных баз данных.
+ Также называются базами данных с широкими столбцами.
+ Внешне похожи на реляционные БД.
+ Как и в реляционных бд, тут данные хранятся строках с колонками, но отличие в том, что строки тут выступают тоже как колонки на дополнительном уровне.
+ Вместо таблиц тут присутствуют структуры - "колоночные семейства". Они содержат строки, которые определяют собственный формат. Строка состоит из уникального идентификатора, используемого для поиска, за которым следуют наборы имен и значений столбцов.

[к оглавлению](#Базы-данных)

### Пример структуры _колоночной_ базы данных
На схеме изображена структура колоночного семейства Фруктов :
![alt text](https://media.proglib.io/posts/2020/01/06/c63913ef4765d8fb604418f4c293faea.png)

[к оглавлению](#Базы-данных)

### Преимущества _колоночных_ баз данных
+ Предоставляют высокую производительность.
+ Данные и метаданные записи доступны по одному идентификатору.
+ Гарантировано размещение всех данных из строки в одном кластере, что упрощает сегментацию и масштабирование данных.
+ Неограниченное количество столбцов.

[к оглавлению](#Базы-данных)

### Недостатки _колоночных_ баз данных
+ Слегка более высокая сложность, чем у БД, ориентированных на документы.
+ Нету ни транзакций, ни соответствия _ACID_, то есть фактически, нет и гарантий сохранения целостности данных в базе.

[к оглавлению](#Базы-данных)

### Примеры _колоночных_ баз данных
+ Cassandra
+ HBase
+ RethinkDB

[к оглавлению](#Базы-данных)

### _Графовые_ базы данных
+ _Графовые_ базы данных являются подвидом нереляционных баз данных.
+ В них вместо того, чтобы устанавливать связь по ключам, она устанавливается с помощью узлов, ребер и свойств в графе.
+ Данные в такой базе представляются в виде отдельных узлов, которые могут иметь любое количество связанных между с ними свойств.
+ В реляционной базе можно скопировать поведение графовой, но это обойдется кучей JOIN-ов, что очень дорого.

[к оглавлению](#Базы-данных)

### Пример 1 структуры _графовой_ базы данных
![alt text](https://media.proglib.io/posts/2020/01/06/b24ee335f9c4f1ae5a20588ed9bfb83a.png)

[к оглавлению](#Базы-данных)

### Пример 2 структуры _графовой_ базы данных
![alt text](https://s3.tproger.ru/uploads/2018/10/graph3.jpg)

[к оглавлению](#Базы-данных)

### Преимущества _графовых_ баз данных
+ Отлично подходят для хранения данных с большим количеством связей, в том числе циклических.
+ Отлично подходят для масштабируемости.
+ Легкий переход с одной модели на другую.
+ Нет ограничений в типах представляемых связей.

[к оглавлению](#Базы-данных)

### Недостатки _графовых_ баз данных
+ Нету ни транзакций, ни соответствия _ACID_, то есть фактически, нет и гарантий сохранения целостности данных в базе.

[к оглавлению](#Базы-данных)

### Примеры _графовых_ баз данных
+ Neo4j
+ InfoGrid
+ Infinite Graph
+ JanusGraph
+ DGraph

[к оглавлению](#Базы-данных)

### Базы данных _временных рядов_
+ Базы данных _временных рядов_ являются подвидом нереляционных баз данных.
+ Созданы для сбора и управления элементами, меняющимися с течением времени.
+ Большинство таких БД организованы в структуры, которые записывают значения для одного элемента.
+ Производительность такой БД зависит от количества отслеживаемых элементов, интервала опроса между записью новых значений и фактической полезной нагрузки данных.

[к оглавлению](#Базы-данных)

### Пример структуры базы данных _временных рядов_
Пример - таблица для отслеживания температуры процессора :
![alt text](https://media.proglib.io/posts/2020/01/06/0ef94dc3811e1c3a688819767cd703ed.png)

[к оглавлению](#Базы-данных)

### Преимущества баз данных _временных рядов_
+ Хорошо справляются с постоянным потоком входных данных.

[к оглавлению](#Базы-данных)

### Недостатки баз данных _временных рядов_
+ Нету ни транзакций, ни соответствия _ACID_, то есть фактически, нет и гарантий сохранения целостности данных в базе.

[к оглавлению](#Базы-данных)

### Примеры баз данных _временных рядов_
+ Prometheus
+ OpenTSDB
+ InfluxDB
+ TimescaleDB

[к оглавлению](#Базы-данных)

## Когда нужно использовать _SQL_ базы данных, а когда _NoSQL_?
Занимаясь разработкой какой-либо системы, можно выбрать сначала одну технологию БД, а потом при необходимости сменить ее на другую. Но разумное планирование с самого начала позволит сэкономить кучу времени и средств.

[к оглавлению](#Базы-данных)

### Причины выбрать _SQL_ базу данных
##### 1. Соответствие базы данных требованиям _ACID_ - Атомарность, Непротиворечивость, Изолированность, Долговечность. 

Это о целостности базы данных, а не о гибкости и скорости, которая лежит в основе _NoSQL_ баз. Это свойство позволяет программисту не отвечать за такие операции низкого уровня как :
+ Блокировки
+ Непротиворечивость данных
+ Обработка устаревших данных
+ Разрешение коллизий
##### 2. Данные, с которыми мы работаем, структурированы, и при этом эта структура не подвержена частым изменениям.

[к оглавлению](#Базы-данных)

### Причины выбрать _NoSQL_ базу данных
##### 1. Хранение больших объемов неструктурированной информации.
    
База данных _NoSQL_ не накладывает ограничений на типы хранимых данных. Более того, при необходимости в процессе работы можно добавлять новые типы данных.

##### 2. Использование облачных вычислений и хранилищ.

Облачные хранилища - это отличное решение, но они требуют, чтобы данные можно было распараллелить между несколькими серверами для обеспечения масштабирования. А _NoSQL_ базы данных как и были созданы для тестирования и локальной разработки, а потом переноса системы в облако, где она и будет работать.

##### 3. Быстрая скорость разработки.
    
Если система разрабатывается с применением _agile_, применение реляционной БД способно замедлить работу. Напротив, _NoSQL_ база позволяет избежать такого объема подготовительных действий.

[к оглавлению](#Базы-данных)

### Свойства проектов, для которых подойдут _SQL_ базы данных
+ Имеются логические требования к данным, которые могут быть определены заранее.
+ Очень важна целостность данных.
+ Нужна хорошо поддерживаемая, устоявшаяся технология, которую хорошо знают разработчики.

[к оглавлению](#Базы-данных)

### Свойства проектов, для которых подойдут _NoSQL_ базы данных
+ Требования к данным нечеткие, неопределенные, или развивающиеся с развитием проекта.
+ Одни из основных требований к базе данных - скорость обработки данных и масштабируемость.
+ Цель проекта может корректироваться со временем, и при этом важна возможность немедленного начала разработки.

[к оглавлению](#Базы-данных)

## _Race condition_
+ _Race condition_ (Состояние гонки) - это ошибка проектирования работы многопоточной системы, при которой работа системы зависит от того, в каком порядке выполняются части кода.
+ _Race condition_ является плавающей ошибкой, которая может проявляться в случайные моменты времени и пропадать при попытках ее локализовать.
+ _Race condition_ возникает как в многопоточных приложениях, так и в базах данных.

[к оглавлению](#Базы-данных)

### Пример _Race Condition_
Написана система перевода денег, которая считывает определенную сумму с одного баланса и переводит ее на другой.

Предположим, что работа с многопоточностью в данной системе очень плоха. Тогда может быть следующая ситуация :

Вася (тот, кто переводит деньги), каким-то образом `3` раза нажал по кнопке отправить `100` рублей, при этом имея на балансе всего `100` рублей. При этом эти его `3` запроса обрабатываются в приложении в `3` потоках одновременно. Все три потока проверяют, существует ли такой пользователь Вася, существует ли пользователь - адресат Петя, и достаточно ли у Васи денег на счету для перевода. В тот момент, когда каждый поток проверяет баланс, он все еще равен `100`. Как только проверки проходят, из баланса Васи вычисляется `3` раза по `100` рублей, и добавляется Пете.

Что мы имеем в итоге ? У Васи баланс `-200` рублей, у Пети - прибавилось `300` рублей, хотя должно было прибавиться `100`. Это и есть типичный пример состояния гонки.

Пример аналогичной ситуации изображен на скрине ниже :

![alt text](https://habrastorage.org/webt/qp/px/l2/qppxl2frreqvbhf6ehxgt0it-vi.png)

[к оглавлению](#Базы-данных)

## _ACID_
_ACID_ - это основные принципы транзакций.
+ `A` - Atomicity (Атомарность) - любая транзакция или целиком выполняется, или целиком отклоняется.
+ `C` - Consistency (Согласованность, консистентность или целостность) - информация в базе должна оставаться согласованной после транзакции. Все `constraint` - ы должны выполняться как до, так и после транзакции.
+ `I` - Isolation (Изолированность) - результат любой транзакции не должен каким-либо образом зависеть от других транзакций.
+ `D` - Durability (Долговечность, Надежность) - если транзакция была закоммичена, то ее результаты не должны пропасть.

[к оглавлению](#Базы-данных)

## Atomicity
+ Принцип атомарности гарантирует, что транзакция выполняется как единое целое, то есть либо все изменения, внесенные транзакцией, будут применены, либо все они будут отклонены.
+ Например, если транзакция содержит `10` `insert` - ов, то либо все они будут выполнены (осуществится `commit`), либо ни один из них не будет выполнен (осуществится `rollback`).
+ Атомарность достигается за счет того, что при выполнении операций транзакции данные не начинают изменяться. Вместо этого транзакция сначала пишется в специальный журнал, в котором фиксируются все изменения. С помощью этого журнала проверяется возможность осуществления транзакции и принимается решение о ее коммите или роллбеке.
+ Из механизма с журналом следует правило, что транзакцию необходимо закрывать как можно скорее. Причина в том, что зачастую базы данных запрещают чистить журнал пока какая-либо транзакция открыта, поэтому он может забиваться, что может иметь не самые приятные последствия.

[к оглавлению](#Базы-данных)

## Consistency
+ Принцип согласованности гарантирует, что после выполнения транзакции данные в БД останутся согласованны, то есть, должны все так же выполняться все `constraint`-ы.
+ Принцип согласованности на уровне БД является довольно спорным, так как выходит, что часть бизнес-логики переходит на уровень БД.

[к оглавлению](#Базы-данных)

## Isolation
+ Принцип изолированности гарантирует, что на результат транзакции не повлияют другие транзакции.
+ Изолированность помогает выполнять параллельные транзакции как последовательные.
+ Фактически, именно изоляция решает проблему доступа к данным в многопоточной среде, например, ту же проблему _race condition_.
+ В полной мере изоляция обеспечивается лишь на уровне `serializable`, который очень тяжело реализовать и который редко действительно нужен.
+ Изоляция обладает разными уровнями, каждый из которых предоставляет свой уровень защиты от _race condition_, так как цена транзакционности как правило сводится к цене изоляции.

[к оглавлению](#Базы-данных)

## Durability
+ Принцип надежности гарантирует, что, если транзакция была применена, то ее результаты не должны пропасть.
+ Фактически этот принцип означает, что если БД ответила, что был совершен `commit` транзакции, то транзакция была зафиксирована в энергонезависимой памяти. Это в свою очередь означает, что произошел системный вызов `fsync`, т.е., буфферы были сброшены на жесткий диск, и он ответил `ok` - ом.
+ Принцип надежности на данный момент не может быть обеспечен прям на 100 процентов по `2` - м причинам :
    + С помощью `fsync` данные попадают в контроллер жесткого диска, но при этом все равно проходят через энергозависимый буффер. Время пребывания в нем мало, но не равно `0`.
    + Всегда есть возможность физического уничтожения / повреждения машины.
    
[к оглавлению](#Базы-данных)   
