# Java 8
+ [Что нового появилось в Java 8?](#Что-нового-появилось-в-Java-8)
+ [Методы интерфейсов по умолчанию](#Методы-интерфейсов-по-умолчанию)
    + [Пример метода интерфейса по умолчанию](#Пример-метода-интерфейса-по-умолчанию)
+ [Лямбда-выражение](#Лямбда-выражение)
    + [Пример использования лямбда-выражения](#Пример-использования-лямбда-выражения)
+ [Функциональный интерфейс](#Функциональный-интерфейс)
    + [Аннотация `@FunctionalInterface`](#Аннотация-FunctionalInterface)
    + [Пример `@FunctionalInterface`](#Пример-FunctionalInterface)    
    + [`Predicate`](#Predicate)  
        + [Пример `Predicate`](#Пример-Predicate)  
        + [Пример `Predicate` с `negate()`](#Пример-Predicate-с-negate)  
    + [`Function`](#Function)   
        + [Пример `Function`](#Пример-Function)  
        + [Пример `Function` с `andThen()`](#Пример-Function-с-andThen)
    + [`Supplier`](#Supplier)   
        + [Пример `Supplier`](#Пример-Supplier) 
    + [`Consumer`](#Consumer)  
        + [Пример `Consumer`](#Пример-Consumer) 
    + [`Comparator`](#Comparator)  
        + [Пример `Comparator`](#Пример-Comparator)   
+ [`Optional`](#Optional)
    + [Пример `Optional`](#Пример-Optional)
    + [Пример `Optional` с `orElseThrow()`](#Пример-Optional-с-orElseThrow)
+ [Streams](#Streams)
    + [`Filter`](#Filter)
    + [`Sorted`](#Sorted)
    + [`Map`](#Map)
    + [`FlatMap`](#FlatMap)
    + [`Match`](#Match)
    + [`Count`](#Count)
    + [`Reduce`](#Reduce)
    + [`Collect`](#Collect)
    + [Метод `Collection.stream()`](#Метод-Collection-stream)
    + [Метод `Collection.parallelStream()`](#Метод-Collection-parallel-stream) 

## Что нового появилось в Java 8?
+ Методы интерфейсов по умолчанию ([_перейти_](#Методы-интерфейсов-по-умолчанию))
+ Лямбда-выражения ([_перейти_](#Лямбда-выражения)) со своими ограничениями доступа к переменным ([_перейти_](#Ограничения-доступа-к-переменным-из-лямбд)) и методам ([_перейти_](#Ограничения-доступа-к-методам-из-лямбд)) 
+ Функциональные интерфейсы ([_перейти_](#Функциональный-интерфейс)), в т.ч., встроенные функциональные интерфейсы :
    + `Predicate` ([_перейти_](#Predicate))
    + `Function` ([_перейти_](#Function))
    + `Supplier` ([_перейти_](#Supplier))
    + `Consumer` ([_перейти_](#Consumer))
    + `Comparator` (стал функциональным) ([_перейти_](#Comparator))
    + `Runnable` (стал функциональным)
+ Ссылки на методы и конструкторы ([_перейти_](#Ссылки-на-методы-и-конструкторы))
+ _Optionals_ - опциональные значения ([_перейти_](#Optional))
+ Потоки элементов - Streams ([_перейти_](#Streams)), как последовательные, так и параллельные ([_перейти_](#Parallel-Streams)), и имеющие большой набор методов, основные из которых :
    + `filter` ([_перейти_](#Filter))
    + `sorted` ([_перейти_](#Sorted))
    + `map` ([_перейти_](#Map))
    + `flatMap` ([_перейти_](#FlatMap))
    + `match` ([_перейти_](#Match))
    + `count` ([_перейти_](#Count))
    + `reduce` ([_перейти_](#Reduce))
    + `collect` ([_перейти_](#Collect))

    Также у коллекций появились такие методы для создания потока элементов как :
    + `stream` ([_перейти_](#Метод-Collection-stream))
    + `parallelStream` ([_перейти_](#Метод-Collection-parallelStream))
+ Новые методы для `Map` - ассоциативных массивов ([_перейти_](#Новые-методы-Map))
+ Новый API для работы с временем и датами :
    + `Clock` и `Instant` - работа с текущими датой и временем ([_перейти_](#Сlock-и-Instant))
    + `ZoneId` - часовые пояса ([_перейти_](#ZoneId))
    + `LocalTime` - работа со временем с учетом часового пояса ([_перейти_](#LocalTime))
    + `LocalDate` - работа с конкретными датами ([_перейти_](#LocalDate))
    + `LocalDateTime` - работа и с временем, и с датой ([_перейти_](#LocalDateTime))
+ Повторяемые аннотации ([_перейти_](#Повторяемые-аннотации))

[к оглавлению](#Java-8)

## Методы интерфейсов по умолчанию
В Java 8 появилась поддержка методов по умолчанию для интерфейсов.

_Методы по умолчанию_ - это такие методы, которые в интерфейсе имеют реализацию. Обозначаются они ключевым словом `default`. Также они известны, как методы расширения.

[к оглавлению](#Java-8)

#### Пример метода интерфейса по умолчанию
Объявление интерфейса с дефолтным методом :
```java
interface Formula {

    double calculate(int a);

    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}
```
В данном интерфейсе `Formula`, помимо абстрактного метода `calculate(int a)`, также определен метод по умолчанию `sqrt`. Таким образом, классы, реализующие этот интерфейс, должны будут переопределить только первый метод, а второй уже будет присутствовать в их экземплярах.

Использование такого интерфейса :
```java
Formula formula = new Formula() {
    @Override
    public double calculate(int a) {
        return sqrt(a * 100);
    }
};

formula.calculate(100);     // 100.0
formula.sqrt(16);           // 4.0
```
Как видно в данном примере использования интерфейса с методом по умолчанию, мы создаем анонимную его реализацию, переопределяя только первый метод таким образом, что он использует дефолтный метод реализуемого интерфейса. Этот код является довольно избыточным, поэтому далее будет рассмотрен способ короткой записи анонимных реализаций, введенный в Java 8.

[к оглавлению](#Java-8)

## Лямбда-выражение
_Лямбда выражение_ - это реализация метода, сигнатура которого находится в функциональном интерфейсе. Простыми словами - это набор действий, который можно сохранить в переменную и использовать много раз. Также можно сказать, что это ссылка на метод, которая теперь записыватеся более коротко. То есть, это по сути то же создание объекта анонимной реализации функционального интерфейса.

[к оглавлению](#Java-8)

#### Пример использования лямбда-выражения
Возьмем пример сортировки строк, который использовался в предыдущих версиях языка :
```java
List<String> names = Arrays.asList("peter", "anna", "mike", "ksenia");

Collections.sort(names, new Comparator<String>() {
    @Override
    public int compare(String a, String b) {
        return b.compareTo(a);
    }
});
```
Тут мы создаем анонимный компаратор, для того чтобы передать его вторым аргументов в функцию сортировки.

В Java 8 же с помощью лямбды мы можем записать тоже самое в более коротком виде :
```java
Collections.sort(names, (String a, String b) -> {
    return b.compareTo(a);
});
```
Как видим, метод стал короче и читабельнее. Далее, можно сделать его еще короче, так как в реализации всего одна строка, можно записать ее без фигурных скобок и оператора `return`.
```java
Collections.sort(names, (String a, String b) -> b.compareTo(a));
```
Также можно не писать типы аргументов. Итоговая запись будет выглядеть вот так :
```java
Collections.sort(names, (a, b) -> b.compareTo(a));
```
Как видим, эта запись намного понятнее, короче и читабельнее чем та, что использовалась в предыдущих версиях.

[к оглавлению](#Java-8)

## Функциональный интерфейс
_Функциональный интерфейс_ - это такой интерфейс, который может иметь __только один__ абстрактный метод и сколько угодно неабстрактных.
Каждый такой интерфейс может использоваться для лямбда-выражений и таким образом каждой лямбде будет соответствовать тип, представленный таким интерфейсом.

[к оглавлению](#Java-8)

## Аннотация `@FunctionalInterface`
Используется для того, чтобы гарантировать, что наш интерфейс соответствует требованию функционального. 

Работает очень просто - если в интерфейс, аннотированный этой аннотацией, добавить второй абстрактный метод, то компилятор выдаст ошибку.

[к оглавлению](#Java-8)

#### Пример `@FunctionalInterface`
Функциональный интерфейс :
```java
@FunctionalInterface
interface Converter<F, T> {
    T convert(F from);
}
```
Создание и использование лямбды :
```java
Converter<String, Integer> converter = (from) -> Integer.valueOf(from);
Integer converted = converter.convert("123");
System.out.println(converted);      // 123
```
Стоит также заметить, что код работать будет и без аннотации `@FunctionalInterface`. Но она просто дает гарантию, что в интерфейсе всего один абстрактный метод.

[к оглавлению](#Java-8)

## `Predicate`
_Предикаты_ - это функции, принимающие один аргумент любого типа и возвращающие значение типа `boolean`. 

Интерфейс `Predicate` является функциональным, внутри лежит один абстрактный метод `test`.

[к оглавлению](#Java-8)

#### Пример `Predicate`
```java
Predicate<String> predicate = (s) -> s.length() > 0;

predicate.test("foo");              // true
```

[к оглавлению](#Java-8)

Интерфейс `Predicate` также имеет`default` - методы, которые позволяют строить сложные условия. Примерами таких методов являются `or()`, `and()`, `negate()`.

#### Пример `Predicate` с `negate()`
```java
Predicate<String> predicate = (s) -> s.length() > 0;

predicate.negate().test("foo");     // false
```

[к оглавлению](#Java-8)

## `Function`
_Функции_ - это такие лямбда-выражения, которые принимают один аргумент и возвращают результат некоего типа. 

Интерфейс `Function` является функциональным, внутри лежит один абстрактный метод `apply`.

[к оглавлению](#Java-8)

#### Пример `Function`
```java
Function<String, Integer> toInteger = Integer::valueOf;

backToString.apply("123");     // 123
```

[к оглавлению](#Java-8)

Интерфейс `Function` также имеет`default` - методы, которые позволяют строить цепочки функций. Примерами таких методов являются `compose`, `andThen`.

#### Пример `Function` с `andThen()`
```java
Function<String, Integer> toInteger = Integer::valueOf;
Function<String, String> backToString = toInteger.andThen(String::valueOf);

backToString.apply("123");     // "123"
```

[к оглавлению](#Java-8)

## `Supplier`
_Поставщики_ - это такие функции, которые не принимают аргументов и возвращают результат некоего типа. 

Интерфейс `Supplier` является функциональным, внутри лежит один абстрактный метод `get`.

[к оглавлению](#Java-8)

#### Пример `Supplier`
```java
Supplier<Person> personSupplier = Person::new;
personSupplier.get();           // new Person
```

[к оглавлению](#Java-8)

## `Consumer`
_Потребители_ - это такие функции, которые принимают один аргумент некоего типа и не возвращают ничего. 

Интерфейс `Consumer` является функциональным, внутри лежит один абстрактный метод `accept`.

[к оглавлению](#Java-8)

#### Пример `Consumer`
```java
Consumer<Person> greeter = (p) -> System.out.println("Hello, " + p.firstName);
greeter.accept(new Person("Luke", "Skywalker"));
```

[к оглавлению](#Java-8)

## `Comparator`
_Компараторы_ существовали и в предыдущих версиях Java. В Java 8 же на интерфейс `Comparator` навесили аннотацию `@FunctionalInterface` и добавили ему методы по умолчанию, самые интересные из которых `thenComparing()`, который позволяет строить цепочки компараторов и `reversed()`, который возвращает противоположный компаратор.

В интерфейсе `Comparator` единственный абстрактный метод называется `compare`.

[к оглавлению](#Java-8)

#### Пример `Comparator`
```java
Comparator<Person> comparator = (p1, p2) -> p1.firstName.compareTo(p2.firstName);

Person p1 = new Person("John", "Doe");
Person p2 = new Person("Alice", "Wonderland");

comparator.compare(p1, p2);             // > 0
comparator.reversed().compare(p1, p2);  // < 0
```

[к оглавлению](#Java-8)

## `Optional`
`Optional` - это новый класс, добавленный в Java 8, который помогает упростить работу с _nullable_ значениями. Опциональные значения являются удобным способом предотвращения `NullPointerException`. 

По сути это контейнер для значения, которое может быть равно `null`. Например, нам нужен метод, который возвращает какое-то значение, но иногда оно может быть пустым. Раньше надо было бы возвращать null, но это всегда риск попасть в каком-то месте на `NPE`, а поэтому использования `Optional` тут будет очень кстати.

`Optional` является `final` классом, `value` внутри него тоже `final`, но при этом он не совсем _immutable_, так как не все условия иммутабельности соблюдены. Например, геттер возвращает просто `value`, а не копию.

[к оглавлению](#Java-8)

#### Пример `Optional`
```java
Optional<String> optional = Optional.of("bam");

optional.isPresent();           // true
optional.get();                 // "bam"
optional.orElse("fallback");    // "bam"

optional.ifPresent((s) -> System.out.println(s.charAt(0)));     // "b"
```

[к оглавлению](#Java-8)

#### Пример `Optional` с `orElseThrow()`
Одним из частых применений `Optional` является работа с БД, так как, например, при запросе на получение элемента по `id` он не будет обязательно найден. Таким образом возвращается опциональное значение, которые мы можем обработать в сервисе и выбросить исключение, если оно пустое.
```java
@Override
public UserVO findByUsername(String username) {
    return userGateway.findByLogin(username)
        .orElseThrow(() -> new UsernameNotFoundException(String.format("Can't find user with username: %s",
                                                                       username)));
}
```

[к оглавлению](#Java-8)

## Streams
+ _Поток_ - это последовательность элементов, над которой мы можем производить различные операции. Эти операции могут быть промежуточными или терминальными. 
+ Промежуточные операции возвращают поток в качестве результата, а терминальные - что-либо другое или вообще ничего, поэтому они всегда находятся в конце цепочки вызовов.
+ Потоки представлены интерфейсом `Stream`, находящийся в `java.util`. Его расширяют такие интерфейсы, как например `IntStream`, `LongStream`, `DoubleStream`, а также его реализует класс `AbstractPipeline`.
+ Есть такие реализации потока, как `ReferencedPipeline`, `IntPipeline`, `DoublePipeline`, `LongPipeline`.
+ Внутри потоки работают на основе `Spliterator`, у которого есть метод `tryAdvance()`, а также `trySplit()`, который используется для параллельных потоков.
+ Операции над потоками могут выполняться как последовательно, так и параллельно.
+ В Java 8 можно создать поток дефолтными методами `Collection.stream() или Collection.parallelStream()`

Далее будут рассмотрены основные методы потоков.

[к оглавлению](#Java-8)

### `Filter`
Метод `filter` принимает один аргумент - предикат, который фильтрует элементы потока. Те элементы, для которых предикат вернет `true`, останутся в потоке. 

Эта операция является промежуточной, так как позволяет после себя вызвать следующую операцию. 

В данном примере мы используем `filter` вместе с терминальной операцией `forEach`.
```java
List.of("ddd2", "aaa2", "bbb1", "aaa1", "bbb3", "ccc", "bbb2", "ddd1")
    .stream()
    .filter((s) -> s.startsWith("a"))
    .forEach(System.out::println);

// "aaa2", "aaa1"
```

[к оглавлению](#Java-8)

### `Sorted`
Метод `sorted` имеет две перегруженные версии :
+ без параметров, в ней элементы сортируются в натуральном порядке 
+ с параметром - компаратором, используя который и будет происходить сортировка

Эта операция является промежуточной, так как позволяет после себя вызвать следующую операцию. 

Также можно заметить, что `sorted` не меняет последовательность элементов в изначальной коллекции, а меняет только порядок элементов в потоке.

Ниже приведен пример использования`sorted`.
```java
List.of("ddd2", "aaa2", "bbb1", "aaa1", "bbb3", "ccc", "bbb2", "ddd1")
    .stream()
    .sorted()
    .filter((s) -> s.startsWith("a"))
    .forEach(System.out::println);

// "aaa1", "aaa2"
```

[к оглавлению](#Java-8)

### `Map`
Метод `map` преобразовывает каждый элемент потока в другой объект при помощи переданной функции. Новый объект в этом случае может быть как того же, так и другого типа.

Эта операция является промежуточной, так как позволяет после себя вызвать следующую операцию. 

Ниже приведен пример использования `map`.
```java
List.of("ddd2", "aaa2", "bbb1", "aaa1", "bbb3", "ccc", "bbb2", "ddd1")
    .stream()
    .map(String::toUpperCase)
    .sorted((a, b) -> b.compareTo(a))
    .forEach(System.out::println);

// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"
```

[к оглавлению](#Java-8)

### `FlatMap`
Метод `map` преобразовывает каждый элемент потока в 0 или больше других объектов при помощи переданной функции.

Эта операция является промежуточной, так как позволяет после себя вызвать следующую операцию. 

Ниже приведен пример использования `flatMap`.
```java
List<List<Integer>> listOfListofInts = Arrays.asList(Arrays.asList(5, 7, 11,13), 
                                                     Arrays.asList(1, 3, 5), 
                                                     Arrays.asList(2, 4, 6, 8)); 

// [[5, 7, 11, 13], [1, 3, 5], [2, 4, 6, 8]]
          
List<Integer> listofInts  = listOfListofInts.stream() 
    .flatMap(list -> list.stream()) 
    .collect(Collectors.toList()); 

// [5, 7, 11, 13, 1, 3, 5, 2, 4, 6, 8]
```

[к оглавлению](#Java-8)

### `Match`
Методы `match` проверяют поток на соответствие предикату. Есть такие матчеры :
+ `anyMatch()` - возвращает `true`, если хотя бы один элемент потока соответствует требованиям предиката.
+ `allMatch()` - возвращает `true`, если каждый элемент потока соответствует требованиям предиката.
+ `noneMatch()` - возаращает `true`, если ни один элемент потока не соответствует требованиям предиката.

Эти операции являются терминальными, так как они возвращают `boolean`. 

Ниже приведены примеры использования матчеров.
```java
boolean anyStartsWithA = List.of("ddd2", "aaa2", "bbb1", "aaa1", "bbb3", "ccc", "bbb2", "ddd1")
        .stream()
        .anyMatch((s) -> s.startsWith("a"));

System.out.println(anyStartsWithA);      // true

boolean allStartsWithA = List.of("ddd2", "aaa2", "bbb1", "aaa1", "bbb3", "ccc", "bbb2", "ddd1")
        .stream()
        .allMatch((s) -> s.startsWith("a"));

System.out.println(allStartsWithA);      // false

boolean noneStartsWithZ = List.of("ddd2", "aaa2", "bbb1", "aaa1", "bbb3", "ccc", "bbb2", "ddd1")
        .stream()
        .noneMatch((s) -> s.startsWith("z"));

System.out.println(noneStartsWithZ);      // true
```

[к оглавлению](#Java-8)

### `Count`
Метод `count` возвращает точное количество элементов в потоке. Типом возвращаемого значения является long`.

Эта операция является терминальной, так как возвращает примитивный тип - `long`.

Ниже приведен пример использования `count`.
```java
long startsWithB = List.of("ddd2", "aaa2", "bbb1", "aaa1", "bbb3", "ccc", "bbb2", "ddd1")
        .stream()
        .filter((s) -> s.startsWith("b"))
        .count();

System.out.println(startsWithB);    // 3
```

[к оглавлению](#Java-8)

### `Reduce`
Метод `reduce` сворачивает элементы потока в один согласно заданной функции. Результатом является значение типа `Optional`.

Эта операция является терминальной, так как возвращает `Optional`.

Ниже приведен пример использования `reduce`.
```java
Optional<String> reduced = List.of("ddd2", "aaa2", "bbb1", "aaa1", "bbb3", "ccc", "bbb2", "ddd1")
        .stream()
        .sorted()
        .reduce((s1, s2) -> s1 + "#" + s2);

reduced.ifPresent(System.out::println);
// "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"
```

### `Collect`
Метод `collect` собирает элементы нашего потока в коллекцию, строку, число и т.д. Для этого он использует параметр типа `Collector`, который как правило берется из одного из статических методов класса `Collectors`. 

Эта операция является терминальной, так как возвращает сущность, отличную от потока.

Ниже приведен пример использования `collect`.
```java
List<String> = List.of("ddd2", "aaa2", "bbb1", "aaa1", "bbb3", "ccc", "bbb2", "ddd1")
        .stream()
        .sorted()
        .collect(Collectors.toList());
```

[к оглавлению](#Java-8)

#### Метод `Collection.stream()`
Данный дефолтный метод создает поток - объект `ReferencePipeline`, в котором операции будут выполняться последовательно с помощью одного сплитератора.
```java
default Stream<E> stream() {
    return StreamSupport.stream(spliterator(), false);
}
```

[к оглавлению](#Java-8)

#### Метод `Collection.parallelStream()`
Данный дефолтный метод создает поток - объект `ReferencePipeline`, в котором операции будут выполняться параллельно с помощью нескольких сплитераторов.
```java
default Stream<E> parallelStream() {
    return StreamSupport.stream(spliterator(), true);
}
```

[к оглавлению](#Java-8)
