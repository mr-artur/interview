# Java 8
+ [Что нового появилось в Java 8?](#Что-нового-появилось-в-Java-8)
+ [Методы интерфейсов по умолчанию](#Методы-интерфейсов-по-умолчанию)
    + [Пример интерфейса по умолчанию](#Пример-интерфейса-по-умолчанию)
+ [Лямбда-выражение](#Лямбда-выражение)
    + [Пример использования лямбда-выражения](#Пример-использования-лямбда-выражения)
+ [Функциональный интерфейс](#Функциональный-интерфейс)
    + [Аннотация `@FunctionalInterface`](#Аннотация-FunctionalInterface)
    + [Пример `@FunctionalInterface`](#Пример-FunctionalInterface)    
    + [`Predicate`](#Predicate)  
        + [Пример `Predicate`](#Пример-Predicate)  
        + [Пример `Predicate` с `negate()`](#Пример-Predicate-с-negate)  
    + [`Function`](#Function)   
        + [Пример `Function`](#Пример-Function)  
        + [Пример `Function` с `andThen()`](#Пример-Function-с-andThen)
    + [`Supplier`](#Supplier)   
        + [Пример `Supplier`](#Пример-Supplier) 
    + [`Consumer`](#Consumer)  
        + [Пример `Consumer`](#Пример-Consumer) 
    + [`Comparator`](#Comparator)  
        + [Пример `Comparator`](#Пример-Comparator)   
    
## Что нового появилось в Java 8?
+ Методы интерфейсов по умолчанию ([_перейти_](#Методы-интерфейсов-по-умолчанию))
+ Лямбда-выражения ([_перейти_](#Лямбда-выражения)) со своими ограничениями доступа к переменным ([_перейти_](#Ограничения-доступа-к-переменным-из-лямбд)) и методам ([_перейти_](#Ограничения-доступа-к-методам-из-лямбд)) 
+ Функциональные интерфейсы ([_перейти_](#Функциональный-интерфейс)), в т.ч., встроенные функциональные интерфейсы :
    + `Predicate` ([_перейти_](#Predicate))
    + `Function` ([_перейти_](#Function))
    + `Supplier` ([_перейти_](#Supplier))
    + `Consumer` ([_перейти_](#Consumer))
    + `Comparator` (стал функциональным) ([_перейти_](#Comparator))
    + `Runnable` (стал функциональным)
+ Ссылки на методы и конструкторы ([_перейти_](#Ссылки-на-методы-и-конструкторы))
+ _Optionals_ - опциональные значения ([_перейти_](#Optional))
+ Потоки элементов - Streams ([_перейти_](#Streams)), как последовательные, так и параллельные ([_перейти_](#Parallel-Streams)), и имеющие большой набор методов, основные из которых :
    + `filter` ([_перейти_](#Filter))
    + `sorted` ([_перейти_](#Sorted))
    + `map` ([_перейти_](#Map))
    + `match` ([_перейти_](#Match))
    + `count` ([_перейти_](#Count))
    + `reduce` ([_перейти_](#Reduce))
    + `collect` ([_перейти_](#Collect))

    Также у коллекций появились такие методы для создания потока элементов как :
    + `stream` ([_перейти_](#Метод-Collection-stream))
    + `parallelStream` ([_перейти_](#Метод-Collection-parallelStream))
+ Новые методы для `Map` - ассоциативных массивов ([_перейти_](#Новые-методы-Map))
+ Новый API для работы с временем и датами :
    + `Clock` и `Instant` - работа с текущими датой и временем ([_перейти_](#Сlock-и-Instant))
    + `ZoneId` - часовые пояса ([_перейти_](#ZoneId))
    + `LocalTime` - работа со временем с учетом часового пояса ([_перейти_](#LocalTime))
    + `LocalDate` - работа с конкретными датами ([_перейти_](#LocalDate))
    + `LocalDateTime` - работа и с временем, и с датой ([_перейти_](#LocalDateTime))
+ Повторяемые аннотации ([_перейти_](#Повторяемые-аннотации))

[к оглавлению](#Java-8)

## Методы интерфейсов по умолчанию
В Java 8 появилась поддержка методов по умолчанию для интерфейсов.

_Методы по умолчанию_ - это такие методы, которые в интерфейсе имеют реализацию. Обозначаются они ключевым словом `default`. Также они известны, как методы расширения.

[к оглавлению](#Java-8)

#### Пример интерфейса по умолчанию
Объявление интерфейса с дефолтным методом :
```java
interface Formula {

    double calculate(int a);

    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}
```
В данном интерфейсе `Formula`, помимо абстрактного метода `calculate(int a)`, также определен метод по умолчанию `sqrt`. Таким образом, классы, реализующие этот интерфейс, должны будут переопределить только первый метод, а второй уже будет присутствовать в их экземплярах.

Использование такого интерфейса :
```java
Formula formula = new Formula() {
    @Override
    public double calculate(int a) {
        return sqrt(a * 100);
    }
};

formula.calculate(100);     // 100.0
formula.sqrt(16);           // 4.0
```
Как видно в данном примере использования интерфейса с методом по умолчанию, мы создаем анонимную его реализацию, переопределяя только первый метод таким образом, что он использует дефолтный метод реализуемого интерфейса. Этот код является довольно избыточным, поэтому далее будет рассмотрен способ короткой записи анонимных реализаций, введенный в Java 8.

[к оглавлению](#Java-8)

## Лямбда-выражение
_Лямбда выражение_ - это реализация метода, сигнатура которого находится в функциональном интерфейсе. Простыми словами - это набор действий, который можно сохранить в переменную и использовать много раз. Также можно сказать, что это ссылка на метод, которая теперь записыватеся более коротко. То есть, это по сути то же создание объекта анонимной реализации функционального интерфейса.

[к оглавлению](#Java-8)

#### Пример использования лямбда-выражения
Возьмем пример сортировки строк, который использовался в предыдущих версиях языка :
```java
List<String> names = Arrays.asList("peter", "anna", "mike", "ksenia");

Collections.sort(names, new Comparator<String>() {
    @Override
    public int compare(String a, String b) {
        return b.compareTo(a);
    }
});
```
Тут мы создаем анонимный компаратор, для того чтобы передать его вторым аргументов в функцию сортировки.

В Java 8 же с помощью лямбды мы можем записать тоже самое в более коротком виде :
```java
Collections.sort(names, (String a, String b) -> {
    return b.compareTo(a);
});
```
Как видим, метод стал короче и читабельнее. Далее, можно сделать его еще короче, так как в реализации всего одна строка, можно записать ее без фигурных скобок и оператора `return`.
```java
Collections.sort(names, (String a, String b) -> b.compareTo(a));
```
Также можно не писать типы аргументов. Итоговая запись будет выглядеть вот так :
```java
Collections.sort(names, (a, b) -> b.compareTo(a));
```
Как видим, эта запись намного понятнее, короче и читабельнее чем та, что использовалась в предыдущих версиях.

[к оглавлению](#Java-8)

## Функциональный интерфейс
_Функциональный интерфейс_ - это такой интерфейс, который может иметь __только один__ абстрактный метод и сколько угодно неабстрактных.
Каждый такой интерфейс может использоваться для лямбда-выражений и таким образом каждой лямбде будет соответствовать тип, представленный таким интерфейсом.

[к оглавлению](#Java-8)

## Аннотация `@FunctionalInterface`
Используется для того, чтобы гарантировать, что наш интерфейс соответствует требованию функционального. 

Работает очень просто - если в интерфейс, аннотированный этой аннотацией, добавить второй абстрактный метод, то компилятор выдаст ошибку.

[к оглавлению](#Java-8)

#### Пример `@FunctionalInterface`
Функциональный интерфейс :
```java
@FunctionalInterface
interface Converter<F, T> {
    T convert(F from);
}
```
Создание и использование лямбды :
```java
Converter<String, Integer> converter = (from) -> Integer.valueOf(from);
Integer converted = converter.convert("123");
System.out.println(converted);      // 123
```
Стоит также заметить, что код работать будет и без аннотации `@FunctionalInterface`. Но она просто дает гарантию, что в интерфейсе всего один абстрактный метод.

[к оглавлению](#Java-8)

## `Predicate`
_Предикаты_ - это функции, принимающие один аргумент любого типа и возвращающие значение типа `boolean`. 

Интерфейс `Predicate` является функциональным, внутри лежит один абстрактный метод `test`.

[к оглавлению](#Java-8)

#### Пример `Predicate`
```java
Predicate<String> predicate = (s) -> s.length() > 0;

predicate.test("foo");              // true
```

[к оглавлению](#Java-8)

Интерфейс `Predicate` также имеет`default` - методы, которые позволяют строить сложные условия. Примерами таких методов являются `or()`, `and()`, `negate()`.

#### Пример `Predicate` с `negate()`
```java
Predicate<String> predicate = (s) -> s.length() > 0;

predicate.negate().test("foo");     // false
```

[к оглавлению](#Java-8)

## `Function`
_Функции_ - это такие лямбда-выражения, которые принимают один аргумент и возвращают результат некоего типа. 

Интерфейс `Function` является функциональным, внутри лежит один абстрактный метод `apply`.

[к оглавлению](#Java-8)

#### Пример `Function`
```java
Function<String, Integer> toInteger = Integer::valueOf;

backToString.apply("123");     // 123
```

[к оглавлению](#Java-8)

Интерфейс `Function` также имеет`default` - методы, которые позволяют строить цепочки функций. Примерами таких методов являются `compose`, `andThen`.

#### Пример `Function` с `andThen()`
```java
Function<String, Integer> toInteger = Integer::valueOf;
Function<String, String> backToString = toInteger.andThen(String::valueOf);

backToString.apply("123");     // "123"
```

[к оглавлению](#Java-8)

## `Supplier`
_Поставщики_ - это такие функции, которые не принимают аргументов и возвращают результат некоего типа. 

Интерфейс `Supplier` является функциональным, внутри лежит один абстрактный метод `get`.

[к оглавлению](#Java-8)

#### Пример `Supplier`
```java
Supplier<Person> personSupplier = Person::new;
personSupplier.get();           // new Person
```

[к оглавлению](#Java-8)

## `Consumer`
_Потребители_ - это такие функции, которые принимают один аргумент некоего типа и не возвращают ничего. 

Интерфейс `Consumer` является функциональным, внутри лежит один абстрактный метод `accept`.

[к оглавлению](#Java-8)

#### Пример `Consumer`
```java
Consumer<Person> greeter = (p) -> System.out.println("Hello, " + p.firstName);
greeter.accept(new Person("Luke", "Skywalker"));
```

[к оглавлению](#Java-8)

## `Comparator`
_Компараторы_ существовали и в предыдущих версиях Java. В Java 8 же на интерфейс `Comparator` навесили аннотацию `@FunctionalInterface` и добавили ему методы по умолчанию, самые интересные из которых `thenComparing()`, который позволяет строить цепочки компараторов и `reversed()`, который возвращает противоположный компаратор.

В интерфейсе `Comparator` единственный абстрактный метод называется `compare`.

[к оглавлению](#Java-8)

#### Пример `Comparator`
```java
Comparator<Person> comparator = (p1, p2) -> p1.firstName.compareTo(p2.firstName);

Person p1 = new Person("John", "Doe");
Person p2 = new Person("Alice", "Wonderland");

comparator.compare(p1, p2);             // > 0
comparator.reversed().compare(p1, p2);  // < 0
```

[к оглавлению](#Java-8)
