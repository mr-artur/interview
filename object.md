# Класс ```Object```
+ [Определение](#Определение)
+ [Методы Object](#Методы-Object)
+ [Зачем нужен ```equals()```. Чем он отличается от операции ```==```?](#Зачем-нужен-equals-Чем-он-отличается-от-операции-)
+ [Какие условия должны выполняться при переопределении `equals()`?](#Какие-условия-должны-выполняться-при-переопределении-equals)
+ [Правила переопределения метода `Object.equals()`](#Правила-переопределения-метода-Objectequals)
+ [Какая связь между `hashCode()` и `equals()`?](#Какая-связь-между-hashCode-и-equals)
+ [Каким образом реализованы методы `hashCode()` и `equals()` в классе `Object`?](#Каким-образом-реализованы-методы-hashcode-и-equals-в-классе-object)
+ [Для чего нужен метод `hashCode()`?](#Для-чего-нужен-метод-hashCode)
+ [Каковы правила переопределения метода `Object.hashCode()`?](#Каковы-правила-переопределения-метода-ObjecthashCode)
+ [Могут ли у разных объектов быть одинаковые `hashCode()`?](#Могут-ли-у-разных-объектов-быть-одинаковые-hashCode)
+ [Что будет, если переопределить только один из `equals()` и`hashCode()`? Какие могут возникнуть проблемы?](#Что-будет-если-переопределить-только-один-из-equals-и-hashcode-Какие-могут-возникнуть-проблемы)
+ [Метод `finalize()`](#Метод-finalize)
    + [Почему не стоит его использовать](#Почему-не-стоит-его-использовать)

## Определение
```Object``` - базовый класс для всех остальных в Java. То есть, любой класс наследуется от Object, и, соответственно, наследует его методы.

## Методы Object
##### 1. ```protected Object clone()```
Создает новый объект, не отличающийся от клонируемого
##### 2. ```public boolean equals(Object o)```
Определяет, равен ли один объект другому
##### 3. ```protected void finalize()```
Вызывается перед удалением неиспользуемого объекта
##### 4. ```public final Class<?> getClass()```
Возвращает класс объекта во время исполнения
##### 5. ```public int hashCode()```
Возвращает хеш-код вызывающего объекта
##### 6. ```public final void notify()```
Пробуждает только один из потоков, в которых был вызван wait() на данном объекте. Если потоков несколько, то выбор будет зависеть от от системной реализации управления потоками.
##### 7. ```public final void notifyAll()```
Пробуждает все потоки, в которых был вызван wait() на данном объекте. Порядок, в котором они будут пробуждаться, зависит от реализации ОС.
##### 8. ```public String toString```
Возвращает символьную строку, описывающую объект
##### 9. ```public final void wait()```
Переводит поток в ожидание того что на этом же объекте в другом потоке будет вызван один из notify методов
##### 10. ```public final void wait(long timeout)```
Переводит поток в ожидание на указанное количество миллисекунд
##### 11. ```public final void wait(long timeout, int nanos)```
Переводит поток в ожидание на указанное количество миллисекунд + наносекунд

Методы ```getClass()```, ```notify()```, ```notifyAll()```, ```wait()``` являются финальными и их нельзя  переопределять.

[к оглавлению](#Класс-Object)

## Зачем нужен ```equals()```. Чем он отличается от операции ```==```?
Метод ```equals()``` - определяет отношение эквивалентности объектов.

При использовании операции ```==``` сравнение происходит по ссылкам объектов. При сравнении по переопределенному разработчиком ```equals()``` - по внутреннему состоянию объектов.

[к оглавлению](#Класс-Object)

## Какие условия должны выполняться при переопределении `equals()`?
+ _Рефлексивность_: для любой ссылки на значение `x`, `x.equals(x)` вернет `true`;
+ _Симметричность_: для любых ссылок на значения `x` и `y`, `x.equals(y)` должно вернуть `true`, тогда и только тогда, когда `y.equals(x)` возвращает `true`.
+ _Транзитивность_: для любых ссылок на значения `x`, `y` и `z`, если `x.equals(y)` и `y.equals(z)` возвращают `true`, тогда и `x.equals(z)` вернёт `true`;
+ _Непротиворечивость_: для любых ссылок на значения `х` и `у`, если несколько раз вызвать `х.equals(y)`, постоянно будет возвращаться значение `true` либо постоянно будет возвращаться значение `false` при условии, что никакая информация, используемая при сравнении объектов, не поменялась.
+ Для любой ненулевой ссылки на значение `х` выражение `х.equals(null)` должно возвращать `false`.

[к оглавлению](#Класс-Object)

## Правила переопределения метода `Object.equals()`
1. Использование оператора `==` для проверки, является ли аргумент ссылкой на указанный объект. Если является, возвращается `true`. Если сравниваемый объект `== null`, должно вернуться `false`.
2. Использование оператор `instanceof` и вызова метода `getClass()` для проверки, имеет ли аргумент правильный тип. Если не имеет, возвращается `false`.
3. Приведение аргумента к правильному типу. Поскольку эта операция следует за проверкой `instanceof` она гарантированно будет выполнена.
4. Обход всех значимых полей класса и проверка того, что значение поля в текущем объекте и значение того же поля в проверяемом на эквивалентность аргументе соответствуют друг другу. Если проверки для всех полей прошли успешно, возвращается результат `true`, в противном случае - `false`.

По окончанию переопределения метода `equals()` следует проверить: является ли порождаемое отношение эквивалентности рефлексивным, симметричным, транзитивным и непротиворечивым? Если ответ отрицательный, метод подлежит соответствующей правке.

[к оглавлению](#Класс-Object)

## Какая связь между `hashCode()` и `equals()`?
Равные объекты должны возвращать одинаковые хэш коды. При переопределении `equals()` нужно обязательно переопределять и метод `hashCode()`.

[к оглавлению](#Класс-Object)

## Каким образом реализованы методы `hashCode()` и `equals()` в классе `Object`?
Реализация метода `Object.equals()` сводится к проверке на равенство двух ссылок:

```java
public boolean equals(Object obj) {
  return (this == obj);
}
```

Реализация метода `Object.hashCode()` описана как `native`, т.е. определенной не с помощью Java кода и обычно возвращает адрес объекта в памяти:

```java 
public native int hashCode();
```

[к оглавлению](#Класс-Object)

## Для чего нужен метод `hashCode()`?
Метод `hashCode()` необходим для вычисления хэш кода переданного в качестве входного параметра объекта. В Java это целое число Этот метод реализован таким образом, что для одного и того же входного объекта, хэш код всегда будет одинаковым. Следует понимать, что в Java множество возможных хэш кодов ограничено типом `int`, а множество объектов ничем не ограничено. Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть:

+ если хэш коды разные, то и объекты гарантированно разные;
+ если хэш коды равны, то объекты могут не обязательно равны.

[к оглавлению](#Класс-Object)

## Каковы правила переопределения метода `Object.hashCode()`?
Общий совет: выбирать поля, которые с большой долью вероятности будут различаться. Для этого необходимо использовать уникальные, лучше всего примитивные поля, например такие как `id`, `uuid`. При этом нужно следовать правилу, если поля задействованы при вычислении `hashCode()`, то они должны быть задействованы и при выполнении `equals()`.

[к оглавлению](#Класс-Object)

## Могут ли у разных объектов быть одинаковые `hashCode()`?
Да, могут. Метод `hashCode()` не гарантирует уникальность возвращаемого значения. Ситуация, когда у разных объектов одинаковые хэш коды называется _коллизией_. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хэш кода.

[к оглавлению](#Класс-Object)

## Что будет, если переопределить только один из `equals()` и`hashCode()`? Какие могут возникнуть проблемы?
Классы и методы, которые используют правила этого контракта могут работать некорректно. 

Так для `HashMap` это может привести к тому, что пара «ключ-значение», которая была в неё помещена при использовании нового экземпляра ключа не будет в ней найдена.

1. `equals()` есть, `hashcode()` нету

Мы не найдем помещенный в хеш-таблицу элемент.

1. `hashcode()` есть, `equals()` нету

Сможем найти корзину хеш-таблицы, но не сам элемент. Без переопределенного equals это невозможно.

[к оглавлению](#Класс-Object)

## Метод `finalize()`

Метод `finalize()` вызывается перед удалением неиспользуемого объекта garbage collector'ом.

+ Предназначен для автоматической очистки ресурсов, занимаемых объектом, на котором он вызван.
+ Может использоваться, например, для последней попытки закрытия ресурсов, если клиент не сделал это в коде (пример - FileInputStream)
+ Объекты с переопределенным `finalize()` попадают в специальную очередь финализированных объектов, которая обрабатывается специально созданным для нее потоком. 
+ Замедляет работу GC по удалению объекта в 430 раз

[к оглавлению](#Класс-Object)

#### Почему не стоит его использовать
1. Нет гарантии, что он будет вызван, потому что где-то может остаться ссылка на объект
2. Нет гарантии, в какое именно время будет вызван метод
3. Есть вероятность, что метод не будет вызван совсем, если например программа закончится к моменту, когда подойдет очередь выполнения метода на этом объекте
4. Исключения, брошенные в `finalize()`, не отслеживаются потоком-финализатором
5. Если наследовать класс с переопределенным `finalize()` и не переопределить его, то объекты класса-наследника будут попадать в финализированную очередь, а не будут сразу уничтожаться

[к оглавлению](#Класс-Object)
