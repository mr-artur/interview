# Hibernate
+ [Что такое _«Hibernate»_?](#Что-такое-Hibernate)
+ [Какие преимущества использования _Hibernate_?](#Какие-преимущества-использования-Hibernate)
+ [Какие преимущества _Hibernate_ над _JDBC_?](#Какие-преимущества-Hibernate-над-JDBC)
+ [Способы конфигурации Hibernate](#Способы-конфигурации-Hibernate)
+ [Основные интерфейсы в Hibernate](#Основные-интерфейсы-в-Hibernate)
+ [`SessionFactory`](#SessionFactory)
+ [`Session`](#Session) 
    + [Методы `Session`](#Session) 
+ [Состояния _Entity_](#Состояния-Entity) 
+ [Переходы между состояниями _Entity_](#Переходы-между-состояниями-Entity) 

## Что такое _«Hibernate»_?
_Hibernate_ - это фреймворк-провайдер _JPA_, который соответственно предназначен для решения задач объектно-реляционного отображения.

[к оглавлению](#Hibernate)

## Какие преимущества использования _Hibernate_?
Hibernate является одним из самых используемых ORM-фреймворков в Java. И вот по каким причинам :
1. Hibernate помогает избежать множества boilerplate кода, который постоянно предследует разработчика в работе в JDBC. Это происходит благодаря тому, что он скрывает от разработчка множество кода, необходимого для управления ресурсами и позволяет сосредоточиться таким образом на бизнес логике.
2. Hibernate поддерживает как XML, так и JPA аннотации, что позволяет сделать реализацию кода независимой.
3. Hibernate предоставляет собственный мощный язык запросов HQL, который похож на SQL, но при этом полностью объектно ориентирован и работает с такими принципами, как наследование, полиморфизм и ассоциация(связи).
4. Hibernate - это широко распространенный open-source проект, благодаря этому доступно очень много статей, примеров и документации по его использованию.
5. Hibernate легко интегрируется с другими Java EE фреймворками, такими как например Spring - он поддерживает встроенную интеграцию с Hibernate.
6. Hibernate поддерживает ленивую инициализацию с использованием proxy объектов и выполняет запросы к базе данных только по необходимости.
7. Hibernate поддерживает разные уровни cache, а следовательно благодаря этому также повышает производительность.
8. Hibernate также может использовать чистый QL, а значит, и поддерживает возможность оптимизации запросов и работы с любым сторонним вендором БД и его фичами.

[к оглавлению](#Hibernate)

## Какие преимущества _Hibernate_ над _JDBC_?
1. Hibernate убирает множество повторяющегося кода из JDBC API, а следовательно, его легче читать, писать и поддерживать.
2. Hibernate поддерживает наследование, наследование, ассоциации и коллекции, что не доступно в JDBC API.
3. Hibernate неявно использует управление транзакциями. Большинство запросов нельзя выполнить без транзакции. При использовании JDBC API для управления транзакциями же нужно явно использовать `commit` и `rollback`.
4. JDBC API выбрасывает `SQLException`, которое относится к checked-исключениям, а значит необходимо постоянно писать множество блоков `try-catch`. Hibernate же оборачивает исключения JDBC в непроверяемые `JDBCException` и `HibernateException`, а значит нет необходимости их проверять в коде каждый раз. Встроенная поддержка управления транзакциями в Hibernate убирает блоки `try-catch`.
5. HQL более объектно-ориентированный и близкий к Java язык запросов, чем SQL в JDBC.
6. Hibernate поддерживает кеширование, а JDBC - нет, что может понизить производительность.
7. Конфигурация Hibernate позволяет использовать JDBC вроде соединения по типу JNDI DataSource для пула соединений. Это важная фича для энтерпрайз приложений, которая полностью отсутствует в JDBC API.
8. Hibernate поддерживает аннотации JPA, а значит код является переносимым на другие фреймворки, реализующие стандарт, в то время как код JDBC сильно привязан к приложению.

[к оглавлению](#Hibernate)

## Способы конфигурации Hibernate
Существует `4` способа конфигурации работы с Hibernate : 
+ Используя аннотации
+ hibernate.cgf.xml
+ hibernate.properties
+ persistence.xml

Самый частый способ конфигурации - через аннотации и файл persistence.xml, что касается файлов hibernate.properties и hibernate.cfg.xml, то hibernate.cfg.xml главнее(перекрывает первый файл). Конфигурация файлами хоть и удобна, но не всегда возможна. Например, если для разных баз данных или для разных ситуаций мы хотим иметь разные конфигурации сущностей, то следует использовать xml файлы конфигураций.

[к оглавлению](#Hibernate)

## Основные интерфейсы в Hibernate
В Hibernate есть такие основные интерфейсы :
+ `SessionFactory` - фабрика сессий, неизменяемый потокобезопасный объект со скомпилированным маппингом для одной базы данных. `SessionFactory` является очень тяжелым объектом и инициализируется обычно один раз. Используется для получения `Session` - объектов, которые используются для операций с базами данных.
+ `Session` - однопоточный короткоживущий объект, который позволяет проводить операции с БД. Оборачивает JDBC `Connection` и работает как фабрика для `Transaction`. 
+ `Transaction` - однопоточный короткоживущий объект, используемый для атомарных операций. В `Hibernate` транзакции обрабатываются менеджером транзакций.
+ `Query` - это объект, используемый для работы с запросами. Он использует `HQL` или `SQL` для чтения/записи данных из/в БД. Экземпляр `Query` используется для связывания параметров запроса, ограничения количества результатов, который будут возвращены и для выполнения запроса. Является _Deprecated_.
+ `Configuration` - этот объект используется для создания объекта `SessionFactory` и конфигурирует сам `Hibernate` с помощью конфигурационного xml-файла, который объясняет, как обрабатывать объект `Session`.
+ `Criteria` - используется для создания и выполнения объектно-ориентированных запросов для получения объектов.

[к оглавлению](#Hibernate)

## `SessionFactory`
+ `SessionFactory` является фабрикой сессий и используется для получения объектов `Session`.
+ `SessionFactory` отвечает за считывание параметров конфигурации Hibernate и подключение к базе данных.
+ `SessionFactory` - очень тяжелый объект, поэтому обычно в приложении имеется только один экземпляр `SessionFactory` и потоки, обслуживающие клиентские запросы, получают экземпляры `Session` с помощью этого объекта фабрики сессий.
+ Необходима как минимум одна `SessionFactory` для каждой БД, с которой мы работаем в приложении, и каждая из них будет со своим конфигурационным файлом.
+ `SessionFactory` является _immutable_ классом, внутреннее состояние экземпляра задается при его создании и включает в себя все метаданные об Object-relational Mapping.
+ `SessionFactory` также предоставляет методы для получения метаданных класса и статистики, такой как данные про второй уровень кеша, выполняемые запросы и т.д.
+ `SessionFactory` является потокобезопасным, так как его объекты _immutable_. Таким образом, множество потоков могут обращаться к одному объекту одновременно.

[к оглавлению](#Hibernate)

## `Session`
+ Объекты `Session` руководят проведением всех операций с объектами в БД, таких как чтение, запись, удаление и обновление.
+ `Session` является однопоточной, поэтому она не потокобезопасна, и каждый поток должен иметь свой собственный объект `Session` и закрывать его по окончанию работы.
+ `Session` является легковесным объектом, поэтому она может создаваться и закрываться много раз за время работы приложения.
+ Сессия используется для физического соединения с БД.
+ `Session` внутри оборачивает объект JDBC `Connection` и проводит операции через него.
+ `Session` является фабрикой для `Transaction` (есть метод `session.beginTransaction()`).
+ Сессия хранит и управляет кешом первого уровня.

[к оглавлению](#Hibernate)

## Методы `Session`
Сессия имеет такие методы :
##### 1. Для взаимодействия с конкретным _Entity_ :
+ `persist (Object object) -> void` - преобразует объект из состояния _transient_ в _persistent_, то есть, присоединяет к сессии. 
    + Если передать ему объект с `Id`, то выбросит `PersistentObjectException`, так как посчитает, что объект в состоянии _detached_.
    + Выполняет сразу `INSERT`, без `SELECT`. 
+ `save (Object object) -> Serializable` - сохраняет объект в БД, всегда генерируя новый `Id`, даже если он установлен. 
    + `Object` может быть в состоянии _transient_ или _detached_.
+ `saveOrUpdate (Object object) -> void` - вызывает `save()` или `update()` в зависимости от того, сохранен ли уже объект.
+ `merge (Object object) -> Object` - преобразует объект из _detached_ или _transient_ в _persistent_.
    + Если переданный объект _transient_, то работает аналогично `save()` - в любом случае генерирует новый `Id`.
    + Если переданный объект _detached_, то загружает его из БД, присоединяет к сессии, а при сохранении выполняет запрос `UPDATE`.
+ `replicate (Object object, ReplicationMode mode) -> void` - преобразует объект из _detached_ в _persistent_, при этом у объекта обязательно должен быть `Id`.
    + Данный метод предназначен для сохранения в БД объекта с заданным `Id`, чего не позволяют сделать `persist()` и `merge()`.
    + Если данный объект уже существует в БД, то поведение определяется согласно правилу из перечисления `ReplicationMode` :
        + `ReplicationMode.IGNORE` - ничего не меняется в базе.
        + `ReplicationMode.OVERWRITE` - объект сохраняется в базу вместо существующего
        + `ReplicationMode.LATEST_VERSION` - в базе сохраняется объект последней версии
        + `ReplicationMode.EXCEPTION` - генерирует исключение
+ `delete (Object object) -> void` - удаляет объект, переводя его из _persistent_ в _removed_. Аналог JPA-шного `remove`.
+ `update (Object object) -> void` - обновляет объект, переводя его из _detached_ в _persistent_.
+ `refresh (Object object) -> void` - обновляет объект состояния _persistent_ или _detached_ данными из БД и приводит его к состоянию _persistent_.
+ `evict (Object object) -> void` - аналог JPA-шного `detach`. Переводит объект из _persistent_ в _detached_.
+ `get (Class<T> clazz, Serializable id) -> T` - возвращает объект класса `clazz` по `id`, возвращает `null`, если объект не найден. Загружает объект сразу, без использования прокси.
+ `load (Clatt<T> clazz, Serializable id) -> T` - возвращает объект класса `clazz` по `id`, бросает исключение если объект не найден. Использует прокси-объект для ленивой загрузки данных.
##### 2. Вспомогательные полезные методы :
+ `beginTransaction() -> Transaction` - создает транзакцию и возвращает ее.
+ `getTransaction() -> Transaction` - возвращает транзакцию, ассоциированную с данной сессией.
+ `close() -> void` - закрывает сессию, освобождает JDBC - соединение и выполняет очистку.
+ `clear() -> void` - освобождает сессию, вызывает `evict()` для всех _managed_ объектов.
+ `flush() -> void` - синхронизирует изменения _persistent store_ Hibernate и базы данных.
+ `getSessionFactory () -> SessionFactory` - возвращает `SessionFactory`, с помощью которой была создана данная `Session`.
+ `getIndentifier (Object object) -> Serializable` - возвращает идентификатор, связанный с переданным объектом.
+ `cancelQuery () -> void` - отменяет выполнение текущего запроса.
+ `createCriteria (String entityName) -> Criteria` - _deprecated_ - создание нового экземпляра `Criteria` для объекта с указанным именем.
+ `createCriteria (Class persistentClass) -> Criteria` - _deprecated_ - создание нового экземпляра `Criteria` для указанного класса.
+ `createSQLQuery(String queryString) -> SQLQuery` - создает новый экземпляр SQL-запроса для данной SQL-строки.
+ `createQuery (String queryString) -> Query` - создает новый экземпляр запроса для данной HQL-строки.
+ `createFilter (Object collection, String queryString) -> Query` - создает новый экземпляр запроса для данной коллекции и фильтра-строки.
+ `isOpen () -> boolean` - проверяет, открыта ли сессия.
+ `isDirty () -> boolean` - проверяет, есть ли в данной сессии какие-то изменения, которые должны быть синхронизированы с БД.
+ `isConnected () -> boolean` - проверяет, подключена ли сессия в данный момент.

[к оглавлению](#Hibernate)

## Состояния _Entity_
В Hibernate у _Entity_ так же, как и в JPA, `4` возможных состояния :
1. _new_ или _transient_ - новый объект без `Id`, который не сохранен в БД и не управляется Hibernate-ом.
2. _managed_ или _persistent_ - управляемый Hibernate-ом объект, изменения в котором повлекут за собой автоматические изменения в БД. Такой объект уже сохранен в БД и имеет `Id`.
3. _detached_ - отсоединенный от управления Hibernate-а объект, имеет `Id` и сохраненный в базе. Отсоединенным объект становится или после вызова с ним-аргументом метода сессии `evict()`, или после очистки или закрытия сессии.
4. _removed_ - объект, который будет удален при ближайшем `flush()` или закрытии транзакции.

[к оглавлению](#Hibernate)

## Переходы между состояниями _Entity_
В JPA была такая схема переходов между состояниями _Entity_ :

![alt text](https://vladmihalcea.com/wp-content/uploads/2014/07/jpaentitystates.png)

В Hibernate схема довольно похожа, но более advanced за счет большего количества методов :

![alt text](https://vladmihalcea.com/wp-content/uploads/2014/07/hibernateentitystates1.png)

