# Hibernate
+ [Что такое _«Hibernate»_?](#Что-такое-Hibernate)
+ [Какие преимущества использования _Hibernate_?](#Какие-преимущества-использования-Hibernate)
+ [Какие преимущества _Hibernate_ над _JDBC_?](#Какие-преимущества-Hibernate-над-JDBC)
+ [Способы конфигурации Hibernate](#Способы-конфигурации-Hibernate)
+ [Основные интерфейсы в Hibernate](#Основные-интерфейсы-в-Hibernate)
+ [`SessionFactory`](#SessionFactory)
    + [Какая разница между `openSession()` и `getCurrentSession()`?](#Какая-разница-между-openSession-и-getCurrentSession)
+ [`Session`](#Session) 
    + [Методы `Session`](#Методы-Session) 
    + [В чем разница между `session.get()` и `session.load()`?](#В-чем-разница-между-sessionget-и-sessionload) 
    + [В чем разница между `session.save()`, `session.persist()` и `session.saveOrUpdate()`?](#В-чем-разница-между-sessionsave-sessionpersist-и-sessionsaveOrUpdate) 
    + [В чем разница между `session.merge()` и `session.replicate()`?](#В-чем-разница-между-sessionmerge-и-sessionreplicate) 
+ [Состояния _Entity_](#Состояния-Entity) 
+ [Переходы между состояниями _Entity_](#Переходы-между-состояниями-Entity) 
+ [Почему нельзя делать _Entity_ final-классом в Hibernate](#Почему-нельзя-делать-Entity-final-классом-в-Hibernate) 
+ [HQL](#HQL) 
+ [Преимущества поддержки нативного SQL в Hibernate](#Преимущества-поддержки-нативного-SQL-в-Hibernate) 
+ [Cascade Types в Hibernate](#Cascade-Types-в-Hibernate) 
+ [Какие паттерны применяются в Hibernate?](#Какие-паттерны-применяются-в-Hibernate) 
+ [Типы коллекций в Hibernate](#Типы-коллекций-в-Hibernate) 
+ [Что лучше - _Sorted Collection_ или _Ordered_ Collection?](#Что-лучше-Sorted-Collection-или-Ordered-Collection) 
+ [Кеширование в Hibernate](#Кеширование-в-Hibernate) 
    + [Типы стратегий кеширования](#Типы-стратегий-кеширования) 

## Что такое _«Hibernate»_?
_Hibernate_ - это ORM-фреймворк, реализующий _JPA_, который соответственно предназначен для решения задач объектно-реляционного отображения.

[к оглавлению](#Hibernate)

## Какие преимущества использования _Hibernate_?
Hibernate является одним из самых используемых ORM-фреймворков в Java. И вот по каким причинам :
1. Hibernate помогает избежать множества boilerplate кода, который постоянно предследует разработчика в работе в JDBC. Это происходит благодаря тому, что он скрывает от разработчка множество кода, необходимого для управления ресурсами и позволяет сосредоточиться таким образом на бизнес логике.
2. Hibernate поддерживает как XML, так и JPA аннотации, что позволяет сделать реализацию кода независимой.
3. Hibernate предоставляет собственный мощный язык запросов HQL, который похож на SQL, но при этом полностью объектно ориентирован и работает с такими принципами, как наследование, полиморфизм и ассоциация(связи).
4. Hibernate - это широко распространенный open-source проект, благодаря этому доступно очень много статей, примеров и документации по его использованию.
5. Hibernate легко интегрируется с другими Java EE фреймворками, такими как например Spring - он поддерживает встроенную интеграцию с Hibernate.
6. Hibernate поддерживает ленивую инициализацию с использованием proxy объектов и выполняет запросы к базе данных только по необходимости.
7. Hibernate поддерживает разные уровни cache, а следовательно благодаря этому также повышает производительность.
8. Hibernate также может использовать чистый SQL, а значит, и поддерживает возможность оптимизации запросов и работы с любым сторонним вендором БД и его фичами.
9. Hibernate позволяет автоматически генерировать и обновлять таблицы в БД.

[к оглавлению](#Hibernate)

## Какие преимущества _Hibernate_ над _JDBC_?
1. Hibernate убирает множество повторяющегося кода из JDBC API, а следовательно, его легче читать, писать и поддерживать.
2. Hibernate поддерживает наследование, наследование, ассоциации и коллекции, что не доступно в JDBC API.
3. Hibernate неявно использует управление транзакциями. Большинство запросов нельзя выполнить без транзакции. При использовании JDBC API для управления транзакциями же нужно явно использовать `commit` и `rollback`.
4. JDBC API выбрасывает `SQLException`, которое относится к checked-исключениям, а значит необходимо постоянно писать множество блоков `try-catch`. Hibernate же оборачивает исключения JDBC в непроверяемые `JDBCException` и `HibernateException`, а значит нет необходимости их проверять в коде каждый раз. Встроенная поддержка управления транзакциями в Hibernate убирает блоки `try-catch`.
5. HQL более объектно-ориентированный и близкий к Java язык запросов, чем SQL в JDBC.
6. Hibernate поддерживает кеширование, а JDBC - нет, что может понизить производительность.
7. Конфигурация Hibernate позволяет использовать JDBC вроде соединения по типу JNDI DataSource для пула соединений. Это важная фича для энтерпрайз приложений, которая полностью отсутствует в JDBC API.
8. Hibernate поддерживает аннотации JPA, а значит код является переносимым на другие фреймворки, реализующие стандарт, в то время как код JDBC сильно привязан к приложению.

[к оглавлению](#Hibernate)

## Способы конфигурации Hibernate
Существует `4` способа конфигурации работы с Hibernate : 
+ Используя аннотации
+ hibernate.cfg.xml
+ hibernate.properties
+ persistence.xml

Самый частый способ конфигурации - через аннотации и файл persistence.xml, что касается файлов hibernate.properties и hibernate.cfg.xml, то hibernate.cfg.xml главнее(перекрывает первый файл). Конфигурация файлами хоть и удобна, но не всегда возможна. Например, если для разных баз данных или для разных ситуаций мы хотим иметь разные конфигурации сущностей, то следует использовать xml файлы конфигураций.

[к оглавлению](#Hibernate)

## Основные интерфейсы в Hibernate
В Hibernate есть такие основные интерфейсы :
+ `SessionFactory` - фабрика сессий, неизменяемый потокобезопасный объект со скомпилированным маппингом для одной базы данных. `SessionFactory` является очень тяжелым объектом и инициализируется обычно один раз. Используется для получения `Session` - объектов, которые используются для операций с базами данных.
+ `Session` - однопоточный короткоживущий объект, который позволяет проводить операции с БД. Оборачивает JDBC `Connection` и работает как фабрика для `Transaction`. 
+ `Transaction` - однопоточный короткоживущий объект, используемый для атомарных операций. В `Hibernate` транзакции обрабатываются менеджером транзакций.
+ `Query` - это объект, используемый для работы с запросами. Он использует `HQL` или `SQL` для чтения/записи данных из/в БД. Экземпляр `Query` используется для связывания параметров запроса, ограничения количества результатов, который будут возвращены и для выполнения запроса. Является _Deprecated_.
+ `Configuration` - этот объект используется для создания объекта `SessionFactory` и конфигурирует сам `Hibernate` с помощью конфигурационного xml-файла, который объясняет, как обрабатывать объект `Session`.
+ `Criteria` - используется для создания и выполнения объектно-ориентированных запросов для получения объектов.

[к оглавлению](#Hibernate)

## `SessionFactory`
+ `SessionFactory` является фабрикой сессий и используется для получения объектов `Session`.
+ `SessionFactory` отвечает за считывание параметров конфигурации Hibernate и подключение к базе данных.
+ `SessionFactory` - очень тяжелый объект, поэтому обычно в приложении имеется только один экземпляр `SessionFactory` и потоки, обслуживающие клиентские запросы, получают экземпляры `Session` с помощью этого объекта фабрики сессий.
+ Необходима как минимум одна `SessionFactory` для каждой БД, с которой мы работаем в приложении, и каждая из них будет со своим конфигурационным файлом.
+ `SessionFactory` является _immutable_ классом, внутреннее состояние экземпляра задается при его создании и включает в себя все метаданные об Object-relational Mapping.
+ `SessionFactory` также предоставляет методы для получения метаданных класса и статистики, такой как данные про второй уровень кеша, выполняемые запросы и т.д.
+ `SessionFactory` является потокобезопасным, так как его объекты _immutable_. Таким образом, множество потоков могут обращаться к одному объекту одновременно.
+ `SessionFactory` конфигурируется таким образом :
![alt text](https://1.bp.blogspot.com/-6A70f1Nh_fM/VsFosVVcFjI/AAAAAAAAAO0/bkaCi_aqxd0/s640/SessionFactory_Hibernate.jpg)

[к оглавлению](#Hibernate)

## Какая разница между `openSession()` и `getCurrentSession()`?
Оба метода вызываются на объекте `SessionFactory`. Но в их поведении и в поведении сессий, возвращенных ими, есть отличия :
+ `sessionFactory.openSession()` :
    + Всегда создает новый объект сессии.
    + Мы должны будем обязательно вызывать закрытие (`close()`) и синхронизацию с БД (`flush()`) вручную с такой сессией.
    + В однопоточной среде этот метод работает медленнее, чем `getCurrentSession()`.
    + Нам не надо конфигурировать никакие свойства Hibernate для использования этого метода.
+ `sessionFactory.getCurrentSession()` :
    + Создает новый объект сессии, если его нету, иначе автоматически возвращает сессию, которая относится к текущему Hibernate контексту.
    + На такой сессии нам не нужно вызывать вручную `flush()` и `close()`, поскольку это будет автоматически выполняться самим Hibernate.
    + В однопоточной среде этот метод работает быстрее, чем `openSession()`.
    + Для его использования нам надо сконфигурировать дополнительное свойство в конфигурации Hibernate - `hibernate.current_session_context_class`, иначе будет выброшено исключение.
    
[к оглавлению](#Hibernate)   

## `Session`
+ Объекты `Session` руководят проведением всех операций с объектами в БД, таких как чтение, запись, удаление и обновление.
+ `Session` является однопоточной, поэтому она не потокобезопасна, и каждый поток должен иметь свой собственный объект `Session` и закрывать его по окончанию работы.
+ `Session` является легковесным объектом, поэтому она может создаваться и закрываться много раз за время работы приложения.
+ Сессия используется для физического соединения с БД.
+ `Session` внутри оборачивает объект JDBC `Connection` и проводит операции через него.
+ `Session` является фабрикой для `Transaction` (есть метод `session.beginTransaction()`).
+ Сессия хранит и управляет кешом первого уровня.

[к оглавлению](#Hibernate)

## Методы `Session`
Сессия имеет такие методы :
##### 1. Для взаимодействия с конкретным _Entity_ :
+ `persist (Object object) -> void` - преобразует объект из состояния _transient_ в _persistent_, то есть, присоединяет к сессии. 
    + Если передать ему объект с `Id`, то выбросит `PersistentObjectException`, так как посчитает, что объект в состоянии _detached_.
    + Выполняет сразу `INSERT`, без `SELECT`. 
+ `save (Object object) -> Serializable` - сохраняет объект в БД, всегда генерируя новый `Id`, даже если он установлен. 
    + `object` может быть в состоянии _transient_ или _detached_.
+ `saveOrUpdate (Object object) -> void` - вызывает `save()` или `update()` в зависимости от того, сохранен ли уже объект.
+ `merge (Object object) -> Object` - преобразует объект из _detached_ или _transient_ в _persistent_. Возвращает новый _persistent_ объект.
    + Если переданный объект _transient_, то сохраняет его и возвращает новый _persistent_ объект.
    + Если переданный объект _detached_, загружает объект из БД, присоединяет к сессии, а при сохранении (флаше) выполняет запрос `UPDATE`.
+ `replicate (Object object, ReplicationMode mode) -> void` - преобразует объект из _detached_ в _persistent_, при этом у объекта обязательно должен быть `Id`.
    + Данный метод предназначен для сохранения в БД объекта с заданным `Id`, чего не позволяют сделать `persist()` и `merge()`.
    + Если данный объект уже существует в БД, то поведение определяется согласно правилу из перечисления `ReplicationMode` :
        + `ReplicationMode.IGNORE` - ничего не меняется в базе.
        + `ReplicationMode.OVERWRITE` - объект сохраняется в базу вместо существующего
        + `ReplicationMode.LATEST_VERSION` - в базе сохраняется объект последней версии
        + `ReplicationMode.EXCEPTION` - генерирует исключение
+ `delete (Object object) -> void` - удаляет объект, переводя его из _persistent_ в _removed_. Аналог JPA-шного `remove`.
+ `update (Object object) -> void` - обновляет объект, переводя его из _detached_ в _persistent_.
+ `refresh (Object object) -> void` - обновляет объект состояния _persistent_ или _detached_ данными из БД и приводит его к состоянию _persistent_.
+ `evict (Object object) -> void` - аналог JPA-шного `detach`. Переводит объект из _persistent_ в _detached_.
+ `get (Class<T> clazz, Serializable id) -> T` - возвращает объект класса `clazz` по `id`, возвращает `null`, если объект не найден. Загружает объект сразу, без использования прокси.
+ `load (Clatt<T> clazz, Serializable id) -> T` - возвращает объект класса `clazz` по `id`, бросает исключение если объект не найден. Использует прокси-объект для ленивой загрузки данных.
##### 2. Вспомогательные полезные методы :
+ `beginTransaction() -> Transaction` - создает транзакцию и возвращает ее.
+ `getTransaction() -> Transaction` - возвращает транзакцию, ассоциированную с данной сессией.
+ `close() -> void` - закрывает сессию, освобождает JDBC - соединение и выполняет очистку.
+ `clear() -> void` - освобождает сессию, вызывает `evict()` для всех _managed_ объектов.
+ `flush() -> void` - синхронизирует изменения _persistent store_ Hibernate и базы данных.
+ `getSessionFactory () -> SessionFactory` - возвращает `SessionFactory`, с помощью которой была создана данная `Session`.
+ `getIndentifier (Object object) -> Serializable` - возвращает идентификатор, связанный с переданным объектом.
+ `cancelQuery () -> void` - отменяет выполнение текущего запроса.
+ `createCriteria (String entityName) -> Criteria` - _deprecated_ - создание нового экземпляра `Criteria` для объекта с указанным именем.
+ `createCriteria (Class persistentClass) -> Criteria` - _deprecated_ - создание нового экземпляра `Criteria` для указанного класса.
+ `createSQLQuery(String queryString) -> SQLQuery` - создает новый экземпляр SQL-запроса для данной SQL-строки.
+ `createQuery (String queryString) -> Query` - создает новый экземпляр запроса для данной HQL-строки.
+ `createFilter (Object collection, String queryString) -> Query` - создает новый экземпляр запроса для данной коллекции и фильтра-строки.
+ `isOpen () -> boolean` - проверяет, открыта ли сессия.
+ `isDirty () -> boolean` - проверяет, есть ли в данной сессии какие-то изменения, которые должны быть синхронизированы с БД.
+ `isConnected () -> boolean` - проверяет, подключена ли сессия в данный момент.

[к оглавлению](#Hibernate)

## В чем разница между `session.get()` и `session.load()`?
Оба метода служат для загрузки объекта из БД.
+ `load` возвращает прокси объекта для _lazy_-загрузки, и бросает `exception`, если объект не найдется в БД.
+ `get` возвращает объект сразу или `null`, если он не найден.

[к оглавлению](#Hibernate)

## В чем разница между `session.save()`, `session.persist()` и `session.saveOrUpdate()`?
Все `3` метода могут использоваться для сохранения сущности в БД.
+ `save` может быть вызван без транзакции, поэтому в его результате мы можем получить несогласованные данные. Также он сразу возвращает `Id` объекта.
+ `persist` аналогичен `save` с транзакцией. `persist` не возвращает сгенерированный `Id` сразу.
+ `saveOrUpdate` используетс запрос для вставки или удаления, основываясь на предоставленных данных. Если они уже есть в БД, то будет вызван запрос обновления. Метод `saveOrUpdate` можно применять без транзакции, но это может привести к аналогичным проблемам, как и в случае с методом `save` (несогласованные данные).

[к оглавлению](#Hibernate)

## В чем разница между `session.merge()` и `session.replicate()`?
+ Главное отличие в том, что `merge` возвращает новый объект, а `replicate` изменяет состояние объекта-аргумента.
+ Оба они могут использоваться для переведения данных из _detached_ стостояния в _persistent_.
+ `replicate` позволяет конфигурировать, что делать с _detached_ объектом в БД, если такой будет найден. `merge` же всегда обновляет поля объекта лежащего в БД.
+ `merge` позволяет также сохранять _transient_ объекты, тогда как `replicate` - нет.

[к оглавлению](#Hibernate)

## Состояния _Entity_
В Hibernate у _Entity_ так же, как и в JPA, `4` возможных состояния :
1. _new_ или _transient_ - новый объект без `Id`, который не сохранен в БД и не управляется Hibernate-ом.
2. _managed_ или _persistent_ - управляемый Hibernate-ом объект, изменения в котором повлекут за собой автоматические изменения в БД. Такой объект уже сохранен в БД и имеет `Id`.
3. _detached_ - отсоединенный от управления Hibernate-а объект, имеет `Id` и сохраненный в базе. Отсоединенным объект становится или после вызова с ним-аргументом метода сессии `evict()`, или после очистки или закрытия сессии.
4. _removed_ - объект, который будет удален при ближайшем `flush()` или закрытии транзакции.

[к оглавлению](#Hibernate)

## Переходы между состояниями _Entity_
В JPA была такая схема переходов между состояниями _Entity_ :

![alt text](https://vladmihalcea.com/wp-content/uploads/2014/07/jpaentitystates.png)

В Hibernate схема довольно похожа, но более advanced за счет большего количества методов :

![alt text](https://vladmihalcea.com/wp-content/uploads/2014/07/hibernateentitystates1.png)

Для переходов между состояниями _Entity_ используются следующие методы `Session` :
1. `persist` :
    + _new_ => _managed_
2. `save` :
    + _new_ => _managed_
    + _removed_ => _managed_
3. `saveOrUpdate` :
    + _new_ => _managed_
    + _removed_ => _managed_
    + _detached_ => _managed_
4. `merge` :
    + _detached_ => _managed_
    + _new_=> _managed_
5. `replicate` :
    + _detached_ => _managed_
6. `delete` :
    + _managed_ => _removed_
7. `update` :
    + _detached_ => _managed_
8. `refresh` :
    + _managed_ => _managed_
    + _detached_ => _managed_
9. `evict` :
    + _managed_ => _detached_
10. `get` :
    + _database_ => _managed_
11. `load` :
    + _database_ => _managed_
    
[к оглавлению](#Hibernate)

## Почему нельзя делать _Entity_ final-классом в Hibernate
В таком случае Hibernate не сможет предоставлять нам возможность ленивой загрузки данных данного класса. Он делает это через прокси-класс, который наследует нашу _Entity_, и, следовательно, поскольку наследование _final_ классов невозможно, то у него и не получится сделать lazy-загрузку данных для такого класса. Ленивая загрузка данных во многих случаях повышает производительность, а значит, важна.

[к оглавлению](#Hibernate)

## HQL
+ _HQL_ (Hibernate Query Language) - это язык запросов в Hibernate, который помогает писать объектно-ориентированные запросы к БД. 
+ HQL похож на SQL, за исключением, что в нем используются объекты вместо имен таблиц, что делает язык ближе к объектно-ориентированному программированию.
+ HQL, в отличии от SQL, поддерживает такие принципы как наследование, полиморфизм и ассоциацию (связь между объектами).
+ HQL является регистронезависимым, кроме использования в запросах имен Java переменных и классов.
+ HQL появился раньше, чем JPQL, поэтому это JPQL подстроен под HQL.
+ Запросы HQL кешируются.

[к оглавлению](#Hibernate)

## Преимущества поддержки нативного SQL в Hibernate
+ Использование нативного SQL может быть необходимо для выполнения запросов к БД, которые (запросы) не поддерживаются Hibernate-ом. Обычно это какие-то специфические фишки разных баз данных.

[к оглавлению](#Hibernate)

## Cascade Types в Hibernate
В Hibernate есть те же `6` каскадных типов, как и в JPA (`ALL`, `PERSIST`, `MERGE`, `REMOVE`, `DETACH`, `REFRESH`), и он добавляет свои `3` новых :
+ `CascadeType.SAVE_UPDATE` - каскадирование при операциях `save` и `update`.
+ `CascadeType.LOCK` - каскадирование Lock-действия.
+ `CascadeType.REPLICATE` - каскадирование операции `replicate`.

[к оглавлению](#Hibernate)

## Какие паттерны применяются в Hibernate?
+ Прокси (_Lazy-loading_)
+ Фабрика (`SessionFactory`)
+ Domain Model - объектная модель предметной области, включающая в себя как поведение так и данные.
+ Data Mapper - слой мапперов, который передает данные между объектами и БД, сохраняя их независимыми друг от друга.

[к оглавлению](#Hibernate)

## Типы коллекций в Hibernate
+ Bag - это неупорядоченная коллекция, по сути тот же `Set`, только в котором еще могут храниться дубликаты.
+ Set
+ List
+ Map
+ Array

[к оглавлению](#Hibernate)

## Что лучше - _Sorted Collection_ или _Ordered_ Collection?
+ _Sorted Collection_ - это когда мы сортируем полученную коллекцию из БД с помощью `Collections.sort()`. Для маленьких коллекций это ОК, но на больших может привести к существенной потери произволдительности или даже `OutOfMemoryError`. В придачу, бины должны реализовывать интерфейс `Comparable`, или нужно определять `Comparator` для такой сортировки.
+ _Ordered Collection_ - это когда мы применяем метод `addOrder` в `Criteria` API для получения отсортированного списка. Этот метод использует сортировку на уровне БД :
```java
List<Employee> empList = session.createCriteria(Employee.class).addOrder(Order.desc("id")).list();
```
+ Метод получения _Ordered Collection_ лучше, поскольку он быстрее и не может привести к утечке памяти.

[к оглавлению](#Hibernate)

## Кеширование в Hibernate
Схема кеширования в Hibernate :

![alt text](https://i2.wp.com/proselyte.net/wp-content/uploads/2016/02/HibernateCaching.png?w=515&ssl=1)

Hibernate использует `2` уровня кеша для оптимизации своей работы и сокращения количества обращений в БД :
+ `1` - й уровень кеша находится в сессии.
    + По умолчанию используется для каждой операции в транзакции. 
    + В первую очередь кеш используется, чтобы уменьшить количество SQL-запросов. Например, если объект модифицировался несколько раз в одной и той же транзакции, то Hibernate сгенерирует только один `UPDATE`.
    + Не существует способа отключить кеш первого уровня.
    + Hibernate предоставляет методы для удаления объекта из кеша или полной очистки кеша.
    + После закрытия объекта `Session` все кешированные объекты теряются.
    + Любой закешированный объект в сессии не будет виден другим объектам `Session`.
+ `2` - й уровень кеша находится в `SessionFactory`.
    + Этот уровень кеша является общим для всего приложения, а не только для конкретного пользователя. 
    + Этот уровень кеша не подключен по умолчанию, его надо подключать вручную вместе с одним из провайдеров кеша :
        + _EHCache_ - быстрый и простой кеш. Поддерживает _read-only_ и _read/write_ кеширование, а также кеширование в память и на диск. Но не поддерживает кластеризацию.
        + _OSCache_ - помимо всего, что поддерживает EHCache, также поддерживает кластеризацию через JavaGroups или JMS.
        + _SwarmCache_ - cluster-based решение, базирующееся на JavaGroups. Поддерживает _read-only_ и нестрогий _read/write_ кеширование. Этот тип кеширования полезен, когда количество операций чтения из БД превышает количество записей в БД.
        + _JBoss TreeCache_ - предоставляет полноценный кеш транзакции.
+ Есть также кеш запросов (Query Cache) :
    + Он интегрирован с кешом второго уровня.
    + Требует двух дополнительных физических мест для хранения кешированных запросов и временных меток для обновления таблицы БД.
    + Этот вид кеширования эффективен только для часто используемых запросов с одинаковыми параметрами.

[к оглавлению](#Hibernate)

## Типы стратегий кеширования 
+ _Read-Only_ - эта стратегия используется, когда данные читаются, но никогда не обновляются. Самая простая и производительная стратегия.
+ _Read / Write_ - может быть использована, когда данные обновляются.
+ _Нестрогий Read / Write_ - эта стратегия не гарантирует, что две транзакции не модифицирууют одни и те же данные синхронно.
+ _Transactional_ - полноценное кеширование транзакций. Доступно только в JTA окружении.

[к оглавлению](#Hibernate)
