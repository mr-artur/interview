# Паттерны
+ [Что такое _Паттерн_?](#Что-такое-Паттерн)
+ [Классификация паттернов](#Классификация-паттернов)
### _Порождающие_ паттерны
+ [Factory Method / Фабричный метод ](#Factory-Method-Фабричный-метод) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Фабричного-метода) | [схема](#Схема-Фабричного-метода) | [преимущества](#Преимущества-Фабричного-метода) | [недостатки](#Недостатки-Фабричного-метода) | [использование](#Использование-Фабричного-метода))
+ [Abstract Factory / Абстрактная фабрика](#Abstract-Factory-Абстрактная-фабрика) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Абстрактной-фабрики) | [схема](#Схема-Абстрактной-фабрики) | [преимущества](#Преимущества-Абстрактной-фабрики) | [недостатки](#Недостатки-Абстрактной-фабрики) | [использование](#Использование-Абстрактной-фабрики))
+ [Builder / Строитель](#Builder-Строитель) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Строителя) | [схема](#Схема-Строителя) | [преимущества](#Преимущества-Строителя) | [недостатки](#Недостатки-Строителя) | [использование](#Использование-Строителя))
+ [Prototype / Прототип](#Prototype-Прототип) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Прототипа) | [схема](#Схема-Прототипа) | [преимущества](#Преимущества-Прототипа) | [недостатки](#Недостатки-Прототипа) | [использование](#Использование-Прототипа))
+ [Singleton / Одиночка](#Singleton-Одиночка) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Одиночки) | [схема](#Схема-Одиночки) | [преимущества](#Преимущества-Одиночки) | [недостатки](#Недостатки-Одиночки) | [использование](#Использование-Одиночки))
### _Структурные_ паттерны
+ [Adapter / Адаптер](#Adapter-Адаптер) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Адаптера) | [схема](#Схема-Адаптера) | [преимущества](#Преимущества-Адаптера) | [недостатки](#Недостатки-Адаптера) | [использование](#Использование-Адаптера))
+ [Bridge / Мост](#Bridge-Мост) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Моста) | [схема](#Схема-Моста) | [преимущества](#Преимущества-Моста) | [недостатки](#Недостатки-Моста) | [использование](#Использование-Моста))
+ [Composite / Компоновщик](#Composite-Компоновщик) &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; ([цель](#Назначение-Компоновщика) | [схема](#Схема-Компоновщика) | [преимущества](#Преимущества-Компоновщика) | [недостатки](#Недостатки-Компоновщика) | [использование](#Использование-Компоновщика))
+ [Decorator / Декоратор](#Decorator-Декоратор) &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Декоратора) | [схема](#Схема-Декоратора) | [преимущества](#Преимущества-Декоратора) | [недостатки](#Недостатки-Декоратора) | [использование](#Использование-Декоратора))
+ [Facade / Фасад](#Facade-Фасад) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Фасада) | [схема](#Схема-Фасада) | [преимущества](#Преимущества-Фасада) | [недостатки](#Недостатки-Фасада) | [использование](#Использование-Фасада))
+ [Flyweight / Легковес](#Flyweight-Легковес) &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Легковеса) | [схема](#Схема-Легковеса) | [преимущества](#Преимущества-Легковеса) | [недостатки](#Недостатки-Легковеса) | [использование](#Использование-Легковеса))
+ [Proxy / Заместитель](#Proxy-Заместитель) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Прокси) | [схема](#Схема-Прокси) | [преимущества](#Преимущества-Прокси) | [недостатки](#Недостатки-Прокси) | [использование](#Использование-Прокси))
### _Поведенческие_ паттерны
+ [Chain of Responsibility / Цепочка Обязанностей](#Chain-of-Responsibility-Цепочка-Обязанностей) &nbsp; &nbsp; ([цель](#Назначение-Цепочки-обязанностей) | [схема](#Схема-Цепочки-обязанностей) | [преимущества](#Преимущества-Цепочки-обязанностей) | [недостатки](#Недостатки-Цепочки-обязанностей) | [использование](#Использование-Цепочки-обязанностей))
+ [Command / Команда](#Command-Команда) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Команды) | [схема](#Схема-Команды) | [преимущества](#Преимущества-Команды) | [недостатки](#Недостатки-Команды) | [использование](#Использование-Команды))

## Что такое _Паттерн_?
_Паттерны (шаблоны) проектирования_ - это способы решения часто встречающихся проблем при проектировании программ.

[к оглавлению](#Паттерны)

## Классификация паттернов
По предназначению паттерны делятся на `3` группы :
+ ___Порождающие___ - те, которые беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей. К порождающим паттернам относятся :
    + Фабричный метод
    + Абстрактная фабрика
    + Строитель
    + Прототип
    + Одиночка
+ ___Структурные___ - те, которые описывают разные способы построения связей между объектами. К структурным паттернам относятся :
    + Адаптер
    + Мост
    + Компоновщик
    + Декоратор
    + Фасад
    + Легковес
    + Заместитель
+ ___Поведенческие___ - те, которые заботятся об эффективной коммуникации между объектами. К поведенческим паттернам относятся :
    + Цепочка обязанностей
    + Команда
    + Итератор
    + Посредник
    + Снимок
    + Наблюдатель
    + Состояние
    + Стратегия
    + Шаблонный метод
    + Посетитель
    + Делегат
    
[к оглавлению](#Паттерны)

## Factory Method (Фабричный метод)
_Фабричный метод_ определяет стандартный метод создания объекта, не связанный с вызовом конструктора, оставляя решение о том, какой именно объект создавать, за подклассами.

[к оглавлению](#Паттерны)

### Назначение Фабричного метода
+ Фабричный метод позволяет отделить логику создания объектов от их использования в клиентском коде. Благодаря этому, код производства можно изменять, не трогая основной (клиентский). Например, мы можем добавить кеширование объектов, поместив его код в фабричный метод, не засоряя при этом клиентский код.
+ Фабричный метод нужен для создания объектов разных типов с помощью одного и того же интерфейса.

[к оглавлению](#Паттерны)

### Схема Фабричного метода
![alt text](https://i.ibb.co/7t6z3mS/pattern-1.jpg)

+ `Product` - интерфейс создаваемых объектов.
+ `ConcreteProduct` - реализация `Product`. Создание объектов этого класса возлагается на класс `ConcreteCreator`.
+ `Creator` - интерфейс, который определяет метод, "фабрикующий" объекты.
+ `ConcreteCreator` - класс, реализующий интерфейс `Creator` и соответственно определяющий тело метода `factoryMethod()`. Этот метод может возвращать любой объект, реализующий интерфейс `Product`.

[к оглавлению](#Паттерны)

### Преимущества Фабричного метода
+ Избавляет клиентский код от привязки к конкретному классу продукта.
+ Выделяет код производства продуктов в одно место, упрощая поддержку кода.
+ Упрощает добавление новых продуктов в программу.
+ Реализует _Open / Closed_ принцип.

[к оглавлению](#Паттерны)

### Недостатки Фабричного метода
+ Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создавать свой класс создателя.

[к оглавлению](#Паттерны)

### Использование Фабричного метода
В примерах фабричного метода создающие методы возвращают объект конкретного подтипа.
+ `java.lang.Object.toString()` - переопределяемый во всех подклассах фабричный метод.
+ `java.lang.Class.newInstance()`
+ `java.lang.Integer.valueOf(String)` (также в `Boolean`, `Byte`, `Character`, `Short`, `Long`, `Float` и `Double`).
+ `java.lang.Class.forName()`
+ `java.lang.reflect.Array.newInstance()`
+ `java.lang.reflect.Constructor.newInstance()`
+ `java.util.Map.of()` и т.д.

[к оглавлению](#Паттерны)

## Abstract Factory (Абстрактная фабрика)
_Абстрактная фабрика_ помогает нам создавать семейства связанных объектов, не привязываясь к к конкретным классам создаваемых объектов. 

Абстрактная фабрика является расширением _Фабричного метода_ и может быть создана вследствии наличия большого количества фабричных методов, которые реорганизовывают в иерархию классов.

[к оглавлению](#Паттерны)

### Назначение Абстрактной фабрики
+ Помогает производить семейства продуктов (связанных между собой), при этом клиентский код может работать с такими семействами одинаково.

[к оглавлению](#Паттерны)

### Схема Абстрактной фабрики
![alt text](https://i.ibb.co/Y8kcZ48/pattern-2.jpg)

+ `AbstractFactory` - абстрактный класс или интерфейс, который определяет механизмы создания абстрактных продуктов.
+ `AbstractProduct` - абстрактный класс или интерфейс, который который описывает базовые функции ресурса, который будет использоваться в приложении.
+ `ConcreteFactory` - класс, порожденный от класса `AbstractFactory` и реализующий методы получения одного или нескольких конкретных продуктов.
+ `ConcreteProduct` - класс, порожденный от класса `AbstractProduct` и реализующий конкретный ресурс.

[к оглавлению](#Паттерны)

### Преимущества Абстрактной фабрики
+ Гарантирует сочитаемость создаваемых продуктов.
+ Избавляет клиентский код от привязки к конкретным типам продуктов
+ Выделяет код производства продуктов в одно место, упрощая поддержку кода.
+ Упрощает добавление новых продуктов и их семейств в программу.
+ Реализует _Open / Closed_ принцип.

[к оглавлению](#Паттерны)

### Недостатки Абстрактной фабрики
+ Усложняет код программы из-за введения множества дополнительных классов.
+ Требует наличия всех типов продуктов в каждом семействе.

[к оглавлению](#Паттерны)

### Использование Абстрактной фабрики
В примерах абстрактной фабрики создающие методы возвращают объект типа интерфейса или абстрактного класса.
+ `java.util.Calendar.getInstance()`
+ `java.util.Arrays.asList()`
+ `java.util.ResourceBundle.getBundle()`
+ `java.net.URL.openConnection()`
+ `java.sql.DriverManager.getConnection()`
+ `java.sql.Connection.createStatement()`
+ `java.sql.Statement.executeQuery()`
+ `java.text.NumberFormat.getInstance()`
+ `java.lang.management.ManagementFactory` (все `getXXX()` методы)
+ `java.nio.charset.Charset.forName()`
+ `javax.xml.parsers.DocumentBuilderFactory.newInstance()`
+ `javax.xml.transform.TransformerFactory.newInstance()`
+ `javax.xml.xpath.XPathFactory.newInstance()`
+ `java.net.URLStreamHandlerFactory.createURLStreamHandler(String)` (Возвращает синглтон для каждого протокола)

[к оглавлению](#Паттерны)

## Builder (Строитель)
_Строитель_ позволяет нам создавать сложные объекты пошагово.

[к оглавлению](#Паттерны)

### Назначение Строителя
+ Главное назначение - это пошаговое построение сложных объектов.
+ Позволяет избавиться от сложных конструкторов.
+ Может использоваться для того, чтобы строить объекты разными способами (применение разных строителей с одним интерфейсом).

[к оглавлению](#Паттерны)

### Схема Строителя
![alt text](https://i.ibb.co/s1MxqNK/pattern-3.jpg)

+ `Director` - необязательный элемент. Содержит ссылку на экземпляр `AbstractBuilder`. По этой ссылке класс `Director` вызывает методы создания конкретного генератора классов, которые создают различные части продукта, что в итоге приводит к созданию объекта-продукта.
+ `AbstractBuilder` - интерфейс, определяющий методы, предназначенные для создания отдельных частей продукта.
+ `ConcreteBuilder` - класс, реализующий интерфейс `AbstractBuilder`. Он содержит реализацию всех его методов, нужных для создания `Product`. У класса `ConcreteBuilder` обязательно должен быть метод, возвращающий итоговый объект `Product`.
+ `Product` - полученный объект, может быть объявлен и как интерфейс.

[к оглавлению](#Паттерны)

### Преимущества Строителя
+ Позволяет создавать объекты пошагово.
+ Позволяет использовать один и тот же код для создание разных объектов.
+ Изолирует сложный код сборки продукта от его основной бизнес-логики.
+ Позволяет избежать огромных конструкторов.

[к оглавлению](#Паттерны)

### Недостатки Строителя
+ Усложняет код программы из-за добавления большего количества классов.
+ Клиент будет привязан к конкретным классам-строителям, так как в интерфейсе строителя может не быть метода получения результата.

[к оглавлению](#Паттерны)

### Использование Строителя
В примерах строителя создающие методы возаращают объект, на котором вызывается метод.
+ `java.lang.StringBuilder.append()` (несинхронизированный)
+ `java.lang.StringBuffer.append()` (синхронизированный)
+ `java.nio.ByteBuffer.put()` (также в `CharBuffer`, `ShortBuffer`, `IntBuffer`, `LongBuffer`, `FloatBuffer` and `DoubleBuffer`)
+ `javax.swing.GroupLayout.Group.addComponent()`
+ Все имплементации `java.lang.Appendable`

[к оглавлению](#Паттерны)

## Prototype (Прототип)
_Прототип_ позволяет нам копировать объекты, не вдаваясь в подробности их реализации.

Паттерн Прототип поручает создание копий самим копируемым объектам.

[к оглавлению](#Паттерны)

### Назначение Прототипа
+ Копирование любого объекта с помощью одного и того же интерфейса, не вникая в реализацию. Обычно это метод `clone()`.

[к оглавлению](#Паттерны)

### Схема Прототипа
![alt text](https://i.ibb.co/JcX9RK6/pattern-4.jpg)

Как видно из схемы, объект класса `Prototype` сам отвечает за свое копирование.

[к оглавлению](#Паттерны)

### Преимущества Прототипа
+ Позволяет копировать объекты, не привязываясь к их конкретным классам.
+ Меньше повторяющегося кода инициализации объектов.
+ Ускоряет создание объектов.
+ Альтернатива созданию подклассов для конструирования сложных объектов.

[к оглавлению](#Паттерны)

### Недостатки Прототипа
+ Сложность в клонировании составных объектов, имеющих ссылки на другие объекты.

[к оглавлению](#Паттерны)

### Использование Прототипа
В примерах прототипа создающие методы возвращают новый инстанс с такими же свойствами.
+ `java.lang.Object.clone()` (класс должен имплементировать `java.lang.Cloneable`)

[к оглавлению](#Паттерны)

## Singleton (Одиночка)
_Одиночка_ гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

Одиночка решает сразу `2` проблемы и таким образом нарушает _Single Responsibility_ принцип :
1. Гарантирует, что у класса есть только один экземпляр.
2. Предоставляет глобальную точку доступа.

[к оглавлению](#Паттерны)

### Назначение Одиночки
+ Применяется, когда нужно, чтобы в программе был единственный экземпляр какой-либо сущности, и при этом нужно обеспечить доступ к нему во всех элементах приложения.

[к оглавлению](#Паттерны)

### Схема Одиночки
![alt text](https://i.ibb.co/YZszHVY/pattern-5.jpg)

На данной схеме показан один из вариантов Одиночки. В нем инстанс хранится в приватном статическом поле, а его получение происходит через статический метод `getInstance()`, который, если поле пустое, инициализирует его, если не пустое, то возвращает существующий инстанс.

[к оглавлению](#Паттерны)

### Преимущества Одиночки
+ Гарантирует наличие единственного экземпляра класса.
+ Предоставляет глобальную точку доступа к экземпляру.
+ Реализует _lazy_ - инициализацию объекта - одиночки.

[к оглавлению](#Паттерны)

### Недостатки Одиночки
+ Нарушает _Single Responsibility_ принцип.
+ Маскирует плохой дизайн.
+ Испытывает проблемы с многопоточностью.
+ Требует постоянного создания mock-объектов при юнит-тестировании.

[к оглавлению](#Паттерны)

### Использование Одиночки
В примерах одиночки создающие методы возвращают один и тот же инстанс при каждом вызове.
+ `java.lang.Runtime.getRuntime()`
+ `java.awt.Desktop.getDesktop()`

[к оглавлению](#Паттерны)

## Adapter (Адаптер)
_Адаптер_ помогает адаптировать интерфейс одного класса для работы с ним в другом классе. Другими словами, он позволяет объектам с несовместимыми интерфейсами работать вместе.

[к оглавлению](#Паттерны)

### Назначение Адаптера
+ Нужен для создания возможности работать с классом, интерфейс которого нам не подходит.

[к оглавлению](#Паттерны)

### Схема Адаптера
![alt text](https://i.ibb.co/7Sd1Qg2/pattern-6.jpg)

+ `Framework` - это клиентский класс, использующий экземпляр класса `Adapter`. Для него необходимо воспользоваться методами объекта `Adaptee`, но не подходит его интерфейс.
+ `Adapter` - это класс, предоставляющий удобный интерфейс для `Framework` и под капотом работающий с агрегируемым экземпляром `Adaptee`.
+ `Adaptee` - это класс, в котором определены методы, подлежащие адаптации. Его интерфейс должен быть адаптированым для работы с ним в `Framework`.

[к оглавлению](#Паттерны)

### Преимущества Адаптера
+ Отделяет и скрывает от клиентского кода преобразование различных интерфейсов.

[к оглавлению](#Паттерны)

### Недостатки Адаптера
+ Усложнение кода из-за введения дополнительных классов.

[к оглавлению](#Паттерны)

### Использование Адаптера
Методы, которые служат как примеры Адаптеров, принимают в аргумент объект интерфейсного / абстрактного типа и возвращают другую имплементацию, которая декорирует или оверрайдит переданный инстанс.
+ `java.io.InputStreamReader(InputStream)` (возвращает `Reader`)
+ `java.io.OutputStreamWriter(OutputStream)` (возвращает `Writer`)
+ `javax.xml.bind.annotation.adapters.XmlAdapter.marshal()` и `.unmarshal()`

[к оглавлению](#Паттерны)

## Bridge (Мост)
_Мост_ помогает разделить один или несколько классов на две иерархии - абстракцию и реализацию, и позволяет их менять независимо друг от друга.

[к оглавлению](#Паттерны)

### Назначение Моста
+ Позволяет разделить компонент на две иерархии - абстракцию и реализацию, это позволяет изменять любую из них независимо от другой.    

[к оглавлению](#Паттерны)

### Схема Моста
![alt text](https://refactoring.guru/images/patterns/diagrams/bridge/structure-ru.png)

+ __Абстракция__ (`Abstraction`) содержит управляющую логику. Код абстракции делегирует реальную работу связанному объекту реализации.
+ __Реализация__ (`Implementation`) задаёт общий интерфейс для всех реализаций. Все методы, которые здесь описаны, будут доступны из класса абстракции и его подклассов. Интерфейсы абстракции и реализации могут как совпадать, так и быть совершенно разными. Но обычно в реализации живут базовые операции, на которых строятся сложные операции абстракции.
+ __Конкретные реализации__ (`Concrete implementations`) содержат платформо-зависимый код.
+ __Расширенные абстракции__ (`Refined Abstraction`) содержат различные вариации управляющей логики. Как и родитель, работает с реализациями только через общий интерфейс реализации.
+ __Клиент__ (`Client`) работает только с объектами абстракции. Не считая начального связывания абстракции с одной из реализаций, клиентский код не имеет прямого доступа к объектам реализации.

[к оглавлению](#Паттерны)

### Преимущества Моста
+ Позволяет строить платформо-независимые программы.
+ Скрывает лишние детали реализации от клиентского кода.
+ Реализует _Open / Closed_ принцип.

[к оглавлению](#Паттерны)

### Недостатки Моста
+ Усложняет код программы из-за введения дополнительных классов.

[к оглавлению](#Паттерны)

### Использование Моста
В данном примере Мост разделяет монолитный код приборов и пультов на `2` части : _приборы_ (выступают реализацией) и _пульты_ управления ими (выступают абстракцией).

![alt text](https://refactoring.guru/images/patterns/diagrams/bridge/example-ru.png)

Класс пульта имеет ссылку на экземпляр прибора, которым он управляет. Таким образом, клиентский код только один раз работает напрямую с реализацией - в момент инициализации он должен выбрать версию абстракции и реализации и связать иъ между собой.

[к оглавлению](#Паттерны)

## Composite (Компоновщик)
_Компоновщик_ помогает объединить множество объектов в древовидную структуру и работать с ними, как с одним объектом.

[к оглавлению](#Паттерны)

### Назначение Компоновщика
+ Помогает однообразно работать со всеми элементами древовидной структуры сразу через одну точку входа (root).

[к оглавлению](#Паттерны)

### Схема Компоновщика
![alt text](https://refactoring.guru/images/patterns/diagrams/composite/structure-ru.png)

+ __Компонент__ (`Component`) определяет общий интерфейс для простых и составных компонентов дерева.
+ __Лист__ (`Leaf`) — это простой компонент дерева, не имеющий ответвлений. Из-за того, что им некому больше передавать выполнение, классы листьев будут содержать большую часть полезного кода.
+ __Контейнер__ (`Composite`) (или композит) — это составной компонент дерева. Он содержит набор дочерних компонентов, но ничего не знает об их типах. Это могут быть как простые компоненты-листья, так и другие компоненты-контейнеры. Но это не является проблемой, если все дочерние компоненты следуют единому интерфейсу. Методы контейнера переадресуют основную работу своим дочерним компонентам, хотя и могут добавлять что-то своё к результату.
+ __Клиент__ (`Client`) работает с деревом через общий интерфейс компонентов. Благодаря этому, клиенту не важно, что перед ним находится — простой или составной компонент дерева.
  
[к оглавлению](#Паттерны)

### Преимущества Компоновщика
+ Упрощение клиентского кода при работе со сложными древовидными структурами.
+ Облегчение добавления новых компонентов.

[к оглавлению](#Паттерны)

### Недостатки Компоновщика
+ Создает слишком общий дизайн классов.

[к оглавлению](#Паттерны)

### Использование Компоновщика
Классический пример использования Компоновщика - это вложенные геометрические фигуры.

![alt text](https://refactoring.guru/images/patterns/diagrams/composite/example.png)

Здесь класс `CompoundGraphic` может содержать любое количество подфигур, включая такие же контейнеры, как и он сам. При этом контейнер реализует те же методы, что и обычные фигуры, но делегирует их выполнение дочерним фигурам. Таким образом, клиентский код работает со всеми фигурами чере общий интерфейс, не зная, перед ним обычная фигура или составная. Также можно заметить, что вызов метода `draw()` на объекте root контейнера позволит отрисовать все объекты из иерархии.

Стандартные примеры Компоновщика тоже относятся к графическим библиотекам :
+ `java.awt.Container.add(Component)` (аналоги есть во многих местах в Swing)
+ `javax.faces.component.UIComponent.getChildren()` (аналоги есть во многих местах JSF UI) 

[к оглавлению](#Паттерны)

## Decorator (Декоратор)
_Декоратор_ применяется для добавления функциональности какому-либо компоненту без непосредственной его модификации.

[к оглавлению](#Паттерны)

### Назначение Декоратора
+ Добавление дополнительного поведения объектам на лету, незаметно для кода, который их использует.
+ Добавление дополнительного поведения объектам, когда это невозможно с помощью наследования (например, класс `final`).

[к оглавлению](#Паттерны)

### Схема Декоратора
![alt text](https://refactoring.guru/images/patterns/diagrams/decorator/structure.png)

+ __Компонент__ (`Component`) задаёт общий интерфейс обёрток и оборачиваемых объектов.
+ __Конкретный компонент__ (`Concrete Component`) определяет класс оборачиваемых объектов. Он содержит какое-то базовое поведение, которое потом изменяют декораторы.
+ __Базовый декоратор__ (`Base Decorator`) хранит ссылку на вложенный объект-компонент. Им может быть как конкретный компонент, так и один из конкретных декораторов. Базовый декоратор делегирует все свои операции вложенному объекту. Дополнительное поведение будет жить в конкретных декораторах.
+ __Конкретные декораторы__ (`Concrete Decorators`) — это различные вариации декораторов, которые содержат добавочное поведение. Оно выполняется до или после вызова аналогичного поведения обёрнутого объекта.
+ __Клиент__ (`Client`) может оборачивать простые компоненты и декораторы в другие декораторы, работая со всеми объектами через общий интерфейс компонентов.

[к оглавлению](#Паттерны)

### Преимущества Декоратора
+ Большая гибкость, чем у наследования.
+ Позволяет добавлять поведение на лету.
+ Можно добавлять несколько новых обязанностей (разные поведения) сразу.
+ Позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни.

[к оглавлению](#Паттерны)

### Недостатки Декоратора
+ Трудность конфигурации многократно обернутых объектов.
+ Обилие крошечных классов.

[к оглавлению](#Паттерны)

### Использование Декоратора
+ Все подклассы `java.io.InputStream`, `OutputStream`, `Reader` и `Writer` имеют конструктор, принимающий инстанс того же типа.
+ `java.util.Collections`, `checkedXXX()`, `synchronizedXXX()` и `unmodifiableXXX()` методы.
+ `javax.servlet.http.HttpServletRequestWrapper` и `HttpServletResponseWrapper`.

[к оглавлению](#Паттерны)

## Facade (Фасад)
_Фасад_ предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

[к оглавлению](#Паттерны)

### Назначение Фасада
+ Представление простого или урезанного клиентского интерфейса к сложной системе.
+ Разделение системы на отдельные подслои и соответственно обеспечение связи между ними через фасады.

[к оглавлению](#Паттерны)

### Схема Фасада
![alt text](https://refactoring.guru/images/patterns/diagrams/facade/structure.png)

+ __Фасад__ (`Facade`) предоставляет быстрый доступ к определённой функциональности подсистемы. Он «знает», каким классам нужно переадресовать запрос, и какие данные для этого нужны.
+ __Дополнительный фасад__ (`Additional Facade`) можно ввести, чтобы не «захламлять» единственный фасад разнородной функциональностью. Он может использоваться как клиентом, так и другими фасадами.
+ __Сложная подсистема__ состоит из множества разнообразных классов. Для того, чтобы заставить их что-то делать, нужно знать подробности устройства подсистемы, порядок инициализации объектов и так далее. Классы подсистемы не знают о существовании фасада и работают друг с другом напрямую.
+ __Клиент__ (`Client`) использует фасад вместо прямой работы с объектами сложной подсистемы.

[к оглавлению](#Паттерны)

### Преимущества Фасада
+ Изолируент клиентский код от компонентов сложной подсистемы.

[к оглавлению](#Паттерны)

### Недостатки Фасада
+ Фасад рискует стать _God Object_, привязанный ко всем классам программы.

[к оглавлению](#Паттерны)

### Использование Фасада
В данном примере Фасад упрощает работу со сложным фреймворком видеоконвертации.

![alt text](https://refactoring.guru/images/patterns/diagrams/facade/example.png)

Вместо с непосредственной работы с кучей подклассов, фасад предоставляет коду приложения единственный метод для конвертации видео, который сам заботится о том, чтобы правильно сконфигурировать нужные объекты фреймворка и получить требуемый результат.

[к оглавлению](#Паттерны)

## Flyweight (Легковес)
_Легковес_, также известен как _Приспособленец_, позволяет разделять общие данные между разными объектами и таким образом экономить отведенную для них память.

[к оглавлению](#Паттерны)

### Назначение Легковеса
+ Уменьшение расхода оперативной памяти на хранение объектов за счет разделения общих данных между ними, вместо дублирования всех этих данных в каждом объекте.

[к оглавлению](#Паттерны)

### Схема Легковеса
Паттерн разделяет данные объектов в программе на две части — легковесы и контексты.

![alt text](https://refactoring.guru/images/patterns/diagrams/flyweight/structure.png)

+ __Легковес__ (`Flyweight`) содержит состояние, которое повторялось во множестве первоначальных объектов. Один и тот же легковес можно использовать в связке со множеством контекстов. Состояние, которое хранится здесь, называется внутренним, а то, которое он получает извне — внешним.
+ __Контекст__ (`Context`) содержит «внешнюю» часть состояния, уникальную для каждого объекта. Контекст связан с одним из объектов-легковесов, хранящих оставшееся состояние.
+ __Клиент__ (`Client`) вычисляет или хранит контекст, то есть внешнее состояние легковесов. Для клиента легковесы выглядят как шаблонные объекты, которые можно настроить во время использования, передав контекст через параметры.
+ __Фабрика легковесов__ (`FlyweightFactory`) управляет созданием и повторным использованием легковесов. Фабрика получает запросы, в которых указано желаемое состояние легковеса. Если легковес с таким состоянием уже создан, фабрика сразу его возвращает, а если нет — создаёт новый объект.

Поведение оригинального объекта чаще всего оставляют в Легковесе, передавая значения контекста через параметры методов. Тем не менее, поведение можно поместить и в контекст, используя легковес как объект данных.

[к оглавлению](#Паттерны)

### Преимущества Легковеса
+ Экономит оперативную память.

[к оглавлению](#Паттерны)

### Недостатки Легковеса
+ Расходует процессорное время на поиск / вычисление контекста.
+ Усложняет код программы из-за введения множества дополнительных классов.

[к оглавлению](#Паттерны)

### Использование Легковеса
+ `java.lang.Integer.valueOf(int)` (аналогично в `Boolean`, `Byte`, `Character`, `Short`, `Long`, `Float` и `Double`)
+ `java.lang.String.intern()` - метод, взаимодействующий со _String Pool_.

[к оглавлению](#Паттерны)

## Proxy (Заместитель)
_Прокси_ - это класс-заместитель реального объекта. Он позволяет выполнять какие-то операции до или после непосредственного вызова методов класса, которого он заменяет.

[к оглавлению](#Паттерны)

### Назначение Прокси
+ _Lazy_ инициализация (виртуальный прокси).
+ Защита доступа к объекту (защищающий прокси).
+ Локальный запуск удаленного сервиса (удаленный прокси).
+ Логирование запросов (логирующий прокси).
+ Кеширование объектов ("умная" ссылка).

[к оглавлению](#Паттерны)

### Схема Прокси
![alt text](https://refactoring.guru/images/patterns/diagrams/proxy/structure.png)

+ __Интерфейс сервиса__ (`ServiceInterface`) определяет общий интерфейс для сервиса и заместителя. Благодаря этому, объект заместителя можно использовать там, где ожидается объект сервиса.
+ __Сервис__ (`Service`) содержит полезную бизнес-логику.
+ __Заместитель__ (`Proxy`) хранит ссылку на объект сервиса. После того как заместитель заканчивает свою работу (например, инициализацию, логирование, защиту или другое), он передаёт вызовы вложенному сервису. Заместитель может сам отвечать за создание и удаление объекта сервиса.
+ __Клиент__ (`Client`) работает с объектами через интерфейс сервиса. Благодаря этому, его можно «одурачить», подменив объект сервиса объектом заместителя.

Также Прокси может быть реализован через наследование, например так сделано в Hibernate для _lazy_ инициализации.

[к оглавлению](#Паттерны)

### Преимущества Прокси
+ Позволяет контролировать сервисный объект независимо для клиента.
+ Может работать, даже если сервисный объект еще не создан.
+ Может контролировать жизненный цикл служебного объекта.

[к оглавлению](#Паттерны)

### Недостатки Прокси
+ Усложнение кода программы из-за введения дополнительных классов.
+ Увеличение времени отклика от сервиса как минимум за счет оверхеда в виде количества дополнительных вызываемых методов.

[к оглавлению](#Паттерны)

### Использование Прокси
+ _lazy_ инициализация в Hibernate.
+ `java.lang.reflect.Proxy`.
+ `java.rmi.*`, весь API фактически.

[к оглавлению](#Паттерны)

## Chain of Responsibility (Цепочка Обязанностей)
_Цепочка обязанностей_ используется для обработки запросов с помощью специальных обработчиков, которые образуют цепочку. Идея в том, что запрос последовательно передается по этим обработчикам, и каждый из них решает, должен ли он его обработать и передавать ли его следующему обработчику.

[к оглавлению](#Паттерны)

### Назначение Цепочки обязанностей
+ Обработка разнообразных запросов несколькими способами, при этом может быть неизвестно заранее какие запросы будут приходить и какие обработчики для них понадобятся.
+ Действия по обработке запроса проводятся в строгом порядке (обработчики идут один за другим).
+ Когда нужно динамически добавлять или удалять обработчики из цепочки.

[к оглавлению](#Паттерны)

### Схема Цепочки обязанностей
![alt text](https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/structure.png)

+ __Обработчик__ (`Handler`) определяет общий для всех конкретных обработчиков интерфейс. Обычно достаточно описать единственный метод обработки запросов, но иногда здесь может быть объявлен и метод выставления следующего обработчика.
+ __Базовый обработчик__ (`BaseHandler`) — опциональный класс, который позволяет избавиться от дублирования одного и того же кода во всех конкретных обработчиках. Обычно этот класс имеет поле для хранения ссылки на следующий обработчик в цепочке. Клиент связывает обработчики в цепь, подавая ссылку на следующий обработчик через конструктор или сеттер поля. Также здесь можно реализовать базовый метод обработки, который бы просто перенаправлял запрос следующему обработчику, проверив его наличие.
+ __Конкретные обработчики__ (`ConcreteHandlers`) содержат код обработки запросов. При получении запроса каждый обработчик решает, может ли он обработать запрос, а также стоит ли передать его следующему объекту. В большинстве случаев обработчики могут работать сами по себе и быть неизменяемыми, получив все нужные детали через параметры конструктора.
+ __Клиент__ (`Client`) может либо сформировать цепочку обработчиков единожды, либо перестраивать её динамически, в зависимости от логики программы. Клиент может отправлять запросы любому из объектов цепочки, не обязательно первому из них.

[к оглавлению](#Паттерны)

### Преимущества Цепочки обязанностей
+ Уменьшает зависимость между клиентом и обработчиками.
+ Реализует _Single Responsibility_ принцип.
+ Реализует _Open / Closed_ принцип.

[к оглавлению](#Паттерны)

### Недостатки Цепочки обязанностей
+ Запрос может остаться не обработанным.

[к оглавлению](#Паттерны)

### Использование Цепочки обязанностей
+ `java.util.logging.Logger.log()` - логгирование.
+ `javax.servlet.Filter.doFilter()` - фильтры запросов в сервлетах.

[к оглавлению](#Паттерны)

## Command (Команда)
_Команда_ используется для представления запросов в виде объектов, и возможности их передачи в качестве аргументов в методы, выстраивания в очередь, отмены и т.д.

[к оглавлению](#Паттерны)

### Назначение Команды
+ Используется чтобы убрать зависимость между клиентским кодом и объектами, выполняющими операции.
+ Реализация отмены и повтора операций.
+ Реализация отложенного запуска операций.
+ Сбор сложных команд из простых.

[к оглавлению](#Паттерны)

### Схема Команды
![alt text](https://refactoring.guru/images/patterns/diagrams/command/structure.png)

+ __Отправитель__ (`Invoker`) хранит ссылку на объект команды и обращается к нему, когда нужно выполнить какое-то действие. Отправитель работает с командами только через их общий интерфейс. Он не знает, какую конкретно команду использует, так как получает готовый объект команды от клиента.
+__Команда__ (`Command`) описывает общий для всех конкретных команд интерфейс. Обычно здесь описан всего один метод для запуска команды.
+ __Конкретные команды__ (`Command`, `Command2`) реализуют различные запросы, следуя общему интерфейсу команд. Обычно команда не делает всю работу самостоятельно, а лишь передаёт вызов получателю, которым является один из объектов бизнес-логики. Параметры, с которыми команда обращается к получателю, следует хранить в виде полей. В большинстве случаев объекты команд можно сделать неизменяемыми, передавая в них все необходимые параметры только через конструктор.
+ __Получатель__ (`Receiver`) содержит бизнес-логику программы. В этой роли может выступать практически любой объект. Обычно команды перенаправляют вызовы получателям. Но иногда, чтобы упростить программу, вы можете избавиться от получателей, «слив» их код в классы команд.
+ __Клиент__ (`Client`) создаёт объекты конкретных команд, передавая в них все необходимые параметры, среди которых могут быть и ссылки на объекты получателей. После этого клиент связывает объекты отправителей с созданными командами.

[к оглавлению](#Паттерны)

### Преимущества Команды
+ Убирает прямую зависимость между объектами, вызывающими операции, и объектами, которые их непосредственно исполняют.
+ Позволяет реализовать простую отмену и повтор операций.
+ Позволяет реализовать отложенный запуск операций.
+ Позволяет собирать сложные команды из простых.
+ Реализует _Open / Closed_ принцип.

[к оглавлению](#Паттерны)

### Недостатки Команды
+ Усложняет код из-за введения множества дополнительных классов.

[к оглавлению](#Паттерны)

### Использование Команды
+ Команды, выполняемые в зависимости от запроса на url сервлетного приложения, эти команды могут храниться как в `enum`, так и в мапе. Такие команды вызывают методы сервисов и выступают как прослойка между контроллером и слоем бизнес-логики.
+ Все имплементации `java.lang.Runnable`
+ Все имплементации `javax.swing.Action`

[к оглавлению](#Паттерны)
