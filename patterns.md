# Паттерны
+ [Что такое _Паттерн_?](#Что-такое-Паттерн)
+ [Классификация паттернов](#Классификация-паттернов)
### _Порождающие_ паттерны
+ [Factory Method / Фабричный метод ](#Factory-Method-Фабричный-метод) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Фабричного-метода) | [схема](#Схема-Фабричного-метода) | [преимущества](#Преимущества-Фабричного-метода) | [недостатки](#Недостатки-Фабричного-метода) | [использование](#Использование-Фабричного-метода))
+ [Abstract Factory / Абстрактная фабрика](#Abstract-Factory-Абстрактная-фабрика) &nbsp; ([цель](#Назначение-Абстрактной-фабрики) | [схема](#Схема-Абстрактной-фабрики) | [преимущества](#Преимущества-Абстрактной-фабрики) | [недостатки](#Недостатки-Абстрактной-фабрики) | [использование](#Использование-Абстрактной-фабрики))
+ [Builder / Строитель](#Builder-Строитель) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Строителя) | [схема](#Схема-Строителя) | [преимущества](#Преимущества-Строителя) | [недостатки](#Недостатки-Строителя) | [использование](#Использование-Строителя))
+ [Prototype / Прототип](#Prototype-Прототип) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Прототипа) | [схема](#Схема-Прототипа) | [преимущества](#Преимущества-Прототипа) | [недостатки](#Недостатки-Прототипа) | [использование](#Использование-Прототипа))
+ [Singleton / Одиночка](#Singleton-Одиночка) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Одиночки) | [схема](#Схема-Одиночки) | [преимущества](#Преимущества-Одиночки) | [недостатки](#Недостатки-Одиночки) | [использование](#Использование-Одиночки))
### _Структурные_ паттерны
+ [Adapter / Адаптер](#Adapter-Адаптер) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Адаптера) | [схема](#Схема-Адаптера) | [преимущества](#Преимущества-Адаптера) | [недостатки](#Недостатки-Адаптера) | [использование](#Использование-Адаптера))
+ [Bridge / Мост](#Bridge-Мост) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Моста) | [схема](#Схема-Моста) | [преимущества](#Преимущества-Моста) | [недостатки](#Недостатки-Моста) | [использование](#Использование-Моста))
+ [Composite / Компоновщик](#Composite-Компоновщик) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Компоновщика) | [схема](#Схема-Компоновщика) | [преимущества](#Преимущества-Компоновщика) | [недостатки](#Недостатки-Компоновщика) | [использование](#Использование-Компоновщика))
+ [Decorator / Декоратор](#Decorator-Декоратор) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Декоратора) | [схема](#Схема-Декоратора) | [преимущества](#Преимущества-Декоратора) | [недостатки](#Недостатки-Декоратора) | [использование](#Использование-Декоратора))

## Что такое _Паттерн_?
_Паттерны (шаблоны) проектирования_ - это способы решения часто встречающихся проблем при проектировании программ.

[к оглавлению](#Паттерны)

## Классификация паттернов
По предназначению паттерны делятся на `3` группы :
+ ___Порождающие___ - те, которые беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей. К порождающим паттернам относятся :
    + Фабричный метод
    + Абстрактная фабрика
    + Строитель
    + Прототип
    + Одиночка
+ ___Структурные___ - те, которые описывают разные способы построения связей между объектами. К структурным паттернам относятся :
    + Адаптер
    + Мост
    + Компоновщик
    + Декоратор
    + Фасад
    + Легковес
    + Заместитель
+ ___Поведенческие___ - те, которые заботятся об эффективной коммуникации между объектами. К поведенческим паттернам относятся :
    + Цепочка обязанностей
    + Команда
    + Итератор
    + Посредник
    + Снимок
    + Наблюдатель
    + Состояние
    + Стратегия
    + Шаблонный метод
    + Посетитель
    + Делегат
    
[к оглавлению](#Паттерны)

## Factory Method (Фабричный метод)
_Фабричный метод_ определяет стандартный метод создания объекта, не связанный с вызовом конструктора, оставляя решение о том, какой именно объект создавать, за подклассами.

[к оглавлению](#Паттерны)

### Назначение Фабричного метода
+ Фабричный метод позволяет отделить логику создания объектов от их использования в клиентском коде. Благодаря этому, код производства можно изменять, не трогая основной (клиентский). Например, мы можем добавить кеширование объектов, поместив его код в фабричный метод, не засоряя при этом клиентский код.
+ Фабричный метод нужен для создания объектов разных типов с помощью одного и того же интерфейса.

[к оглавлению](#Паттерны)

### Схема Фабричного метода
![alt text](https://i.ibb.co/7t6z3mS/pattern-1.jpg)

+ `Product` - интерфейс создаваемых объектов.
+ `ConcreteProduct` - реализация `Product`. Создание объектов этого класса возлагается на класс `ConcreteCreator`.
+ `Creator` - интерфейс, который определяет метод, "фабрикующий" объекты.
+ `ConcreteCreator` - класс, реализующий интерфейс `Creator` и соответственно определяющий тело метода `factoryMethod()`. Этот метод может возвращать любой объект, реализующий интерфейс `Product`.

[к оглавлению](#Паттерны)

### Преимущества Фабричного метода
+ Избавляет клиентский код от привязки к конкретному классу продукта.
+ Выделяет код производства продуктов в одно место, упрощая поддержку кода.
+ Упрощает добавление новых продуктов в программу.
+ Реализует _Open / Closed_ принцип.

[к оглавлению](#Паттерны)

### Недостатки Фабричного метода
+ Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создавать свой класс создателя.

[к оглавлению](#Паттерны)

### Использование Фабричного метода
В примерах фабричного метода создающие методы возвращают объект конкретного подтипа.
+ `java.lang.Object.toString()` - переопределяемый во всех подклассах фабричный метод.
+ `java.lang.Class.newInstance()`
+ `java.lang.Integer.valueOf(String)` (также в `Boolean`, `Byte`, `Character`, `Short`, `Long`, `Float` и `Double`).
+ `java.lang.Class.forName()`
+ `java.lang.reflect.Array.newInstance()`
+ `java.lang.reflect.Constructor.newInstance()`
+ `java.util.Map.of()` и т.д.

[к оглавлению](#Паттерны)

## Abstract Factory (Абстрактная фабрика)
_Абстрактная фабрика_ помогает нам создавать семейства связанных объектов, не привязываясь к к конкретным классам создаваемых объектов. 

Абстрактная фабрика является расширением _Фабричного метода_ и может быть создана вследствии наличия большого количества фабричных методов, которые реорганизовывают в иерархию классов.

[к оглавлению](#Паттерны)

### Назначение Абстрактной фабрики
+ Помогает производить семейства продуктов (связанных между собой), при этом клиентский код может работать с такими семействами одинаково.

[к оглавлению](#Паттерны)

### Схема Абстрактной фабрики
![alt text](https://i.ibb.co/Y8kcZ48/pattern-2.jpg)

+ `AbstractFactory` - абстрактный класс или интерфейс, который определяет механизмы создания абстрактных продуктов.
+ `AbstractProduct` - абстрактный класс или интерфейс, который который описывает базовые функции ресурса, который будет использоваться в приложении.
+ `ConcreteFactory` - класс, порожденный от класса `AbstractFactory` и реализующий методы получения одного или нескольких конкретных продуктов.
+ `ConcreteProduct` - класс, порожденный от класса `AbstractProduct` и реализующий конкретный ресурс.

[к оглавлению](#Паттерны)

### Преимущества Абстрактной фабрики
+ Гарантирует сочитаемость создаваемых продуктов.
+ Избавляет клиентский код от привязки к конкретным типам продуктов
+ Выделяет код производства продуктов в одно место, упрощая поддержку кода.
+ Упрощает добавление новых продуктов и их семейств в программу.
+ Реализует _Open / Closed_ принцип.

[к оглавлению](#Паттерны)

### Недостатки Абстрактной фабрики
+ Усложняет код программы из-за введения множества дополнительных классов.
+ Требует наличия всех типов продуктов в каждом семействе.

[к оглавлению](#Паттерны)

### Использование Абстрактной фабрики
В примерах абстрактной фабрики создающие методы возвращают объект типа интерфейса или абстрактного класса.
+ `java.util.Calendar.getInstance()`
+ `java.util.Arrays.asList()`
+ `java.util.ResourceBundle.getBundle()`
+ `java.net.URL.openConnection()`
+ `java.sql.DriverManager.getConnection()`
+ `java.sql.Connection.createStatement()`
+ `java.sql.Statement.executeQuery()`
+ `java.text.NumberFormat.getInstance()`
+ `java.lang.management.ManagementFactory` (все `getXXX()` методы)
+ `java.nio.charset.Charset.forName()`
+ `javax.xml.parsers.DocumentBuilderFactory.newInstance()`
+ `javax.xml.transform.TransformerFactory.newInstance()`
+ `javax.xml.xpath.XPathFactory.newInstance()`
+ `java.net.URLStreamHandlerFactory.createURLStreamHandler(String)` (Возвращает синглтон для каждого протокола)

[к оглавлению](#Паттерны)

## Builder (Строитель)
_Строитель_ позволяет нам создавать сложные объекты пошагово.

[к оглавлению](#Паттерны)

### Назначение Строителя
+ Главное назначение - это пошаговое построение сложных объектов.
+ Позволяет избавиться от сложных конструкторов.
+ Может использоваться для того, чтобы строить объекты разными способами (применение разных строителей с одним интерфейсом).

[к оглавлению](#Паттерны)

### Схема Строителя
![alt text](https://i.ibb.co/s1MxqNK/pattern-3.jpg)

+ `Director` - необязательный элемент. Содержит ссылку на экземпляр `AbstractBuilder`. По этой ссылке класс `Director` вызывает методы создания конкретного генератора классов, которые создают различные части продукта, что в итоге приводит к созданию объекта-продукта.
+ `AbstractBuilder` - интерфейс, определяющий методы, предназначенные для создания отдельных частей продукта.
+ `ConcreteBuilder` - класс, реализующий интерфейс `AbstractBuilder`. Он содержит реализацию всех его методов, нужных для создания `Product`. У класса `ConcreteBuilder` обязательно должен быть метод, возвращающий итоговый объект `Product`.
+ `Product` - полученный объект, может быть объявлен и как интерфейс.

[к оглавлению](#Паттерны)

### Преимущества Строителя
+ Позволяет создавать объекты пошагово.
+ Позволяет использовать один и тот же код для создание разных объектов.
+ Изолирует сложный код сборки продукта от его основной бизнес-логики.
+ Позволяет избежать огромных конструкторов.

[к оглавлению](#Паттерны)

### Недостатки Строителя
+ Усложняет код программы из-за добавления большего количества классов.
+ Клиент будет привязан к конкретным классам-строителям, так как в интерфейсе строителя может не быть метода получения результата.

[к оглавлению](#Паттерны)

### Использование Строителя
В примерах строителя создающие методы возаращают объект, на котором вызывается метод.
+ `java.lang.StringBuilder.append()` (несинхронизированный)
+ `java.lang.StringBuffer.append()` (синхронизированный)
+ `java.nio.ByteBuffer.put()` (также в `CharBuffer`, `ShortBuffer`, `IntBuffer`, `LongBuffer`, `FloatBuffer` and `DoubleBuffer`)
+ `javax.swing.GroupLayout.Group.addComponent()`
+ Все имплементации `java.lang.Appendable`

[к оглавлению](#Паттерны)

## Prototype (Прототип)
_Прототип_ позволяет нам копировать объекты, не вдаваясь в подробности их реализации.

Паттерн Прототип поручает создание копий самим копируемым объектам.

[к оглавлению](#Паттерны)

### Назначение Прототипа
+ Копирование любого объекта с помощью одного и того же интерфейса, не вникая в реализацию. Обычно это метод `clone()`.

[к оглавлению](#Паттерны)

### Схема Прототипа
![alt text](https://i.ibb.co/JcX9RK6/pattern-4.jpg)

Как видно из схемы, объект класса `Prototype` сам отвечает за свое копирование.

[к оглавлению](#Паттерны)

### Преимущества Прототипа
+ Позволяет копировать объекты, не привязываясь к их конкретным классам.
+ Меньше повторяющегося кода инициализации объектов.
+ Ускоряет создание объектов.
+ Альтернатива созданию подклассов для конструирования сложных объектов.

[к оглавлению](#Паттерны)

### Недостатки Прототипа
+ Сложность в клонировании составных объектов, имеющих ссылки на другие объекты.

[к оглавлению](#Паттерны)

### Использование Прототипа
В примерах прототипа создающие методы возвращают новый инстанс с такими же свойствами.
+ `java.lang.Object.clone()` (класс должен имплементировать `java.lang.Cloneable`)

[к оглавлению](#Паттерны)

## Singleton (Одиночка)
_Одиночка_ гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

Одиночка решает сразу `2` проблемы и таким образом нарушает _Single Responsibility_ принцип :
1. Гарантирует, что у класса есть только один экземпляр.
2. Предоставляет глобальную точку доступа.

[к оглавлению](#Паттерны)

### Назначение Одиночки
+ Применяется, когда нужно, чтобы в программе был единственный экземпляр какой-либо сущности, и при этом нужно обеспечить доступ к нему во всех элементах приложения.

[к оглавлению](#Паттерны)

### Схема Одиночки
![alt text](https://i.ibb.co/YZszHVY/pattern-5.jpg)

На данной схеме показан один из вариантов Одиночки. В нем инстанс хранится в приватном статическом поле, а его получение происходит через статический метод `getInstance()`, который, если поле пустое, инициализирует его, если не пустое, то возвращает существующий инстанс.

[к оглавлению](#Паттерны)

### Преимущества Одиночки
+ Гарантирует наличие единственного экземпляра класса.
+ Предоставляет глобальную точку доступа к экземпляру.
+ Реализует _lazy_ - инициализацию объекта - одиночки.

[к оглавлению](#Паттерны)

### Недостатки Одиночки
+ Нарушает _Single Responsibility_ принцип.
+ Маскирует плохой дизайн.
+ Испытывает проблемы с многопоточностью.
+ Требует постоянного создания mock-объектов при юнит-тестировании.

[к оглавлению](#Паттерны)

### Использование Одиночки
В примерах одиночки создающие методы возвращают один и тот же инстанс при каждом вызове.
+ `java.lang.Runtime.getRuntime()`
+ `java.awt.Desktop.getDesktop()`

[к оглавлению](#Паттерны)

## Adapter (Адаптер)
_Адаптер_ помогает адаптировать интерфейс одного класса для работы с ним в другом классе. Другими словами, он позволяет объектам с несовместимыми интерфейсами работать вместе.

[к оглавлению](#Паттерны)

### Назначение Адаптера
+ Нужен для создания возможности работать с классом, интерфейс которого нам не подходит.

[к оглавлению](#Паттерны)

### Схема Адаптера
![alt text](https://i.ibb.co/7Sd1Qg2/pattern-6.jpg)

+ `Framework` - это клиентский класс, использующий экземпляр класса `Adapter`. Для него необходимо воспользоваться методами объекта `Adaptee`, но не подходит его интерфейс.
+ `Adapter` - это класс, предоставляющий удобный интерфейс для `Framework` и под капотом работающий с агрегируемым экземпляром `Adaptee`.
+ `Adaptee` - это класс, в котором определены методы, подлежащие адаптации. Его интерфейс должен быть адаптированым для работы с ним в `Framework`.

[к оглавлению](#Паттерны)

### Преимущества Адаптера
+ Отделяет и скрывает от клиентского кода преобразование различных интерфейсов.

[к оглавлению](#Паттерны)

### Недостатки Адаптера
+ Усложнение кода из-за введения дополнительных классов.

[к оглавлению](#Паттерны)

### Использование Адаптера
Методы, которые служат как примеры Адаптеров, принимают в аргумент объект интерфейсного / абстрактного типа и возвращают другую имплементацию, которая декорирует или оверрайдит переданный инстанс.
+ `java.io.InputStreamReader(InputStream)` (возвращает `Reader`)
+ `java.io.OutputStreamWriter(OutputStream)` (возвращает `Writer`)
+ `javax.xml.bind.annotation.adapters.XmlAdapter.marshal()` и `.unmarshal()`

[к оглавлению](#Паттерны)

## Bridge (Мост)
_Мост_ помогает разделить один или несколько классов на две иерархии - абстракцию и реализацию, и позволяет их менять независимо друг от друга.

[к оглавлению](#Паттерны)

### Назначение Моста
+ Позволяет разделить компонент на две иерархии - абстракцию и реализацию, это позволяет изменять любую из них независимо от другой.    

[к оглавлению](#Паттерны)

### Схема Моста
![alt text](https://refactoring.guru/images/patterns/diagrams/bridge/structure-ru.png)

+ __Абстракция__ (`Abstraction`) содержит управляющую логику. Код абстракции делегирует реальную работу связанному объекту реализации.
+ __Реализация__ (`Implementation`) задаёт общий интерфейс для всех реализаций. Все методы, которые здесь описаны, будут доступны из класса абстракции и его подклассов. Интерфейсы абстракции и реализации могут как совпадать, так и быть совершенно разными. Но обычно в реализации живут базовые операции, на которых строятся сложные операции абстракции.
+ __Конкретные реализации__ (`Concrete implementations`) содержат платформо-зависимый код.
+ __Расширенные абстракции__ (`Refined Abstraction`) содержат различные вариации управляющей логики. Как и родитель, работает с реализациями только через общий интерфейс реализации.
+ __Клиент__ (`Client`) работает только с объектами абстракции. Не считая начального связывания абстракции с одной из реализаций, клиентский код не имеет прямого доступа к объектам реализации.

[к оглавлению](#Паттерны)

### Преимущества Моста
+ Позволяет строить платформо-независимые программы.
+ Скрывает лишние детали реализации от клиентского кода.
+ Реализует _Open / Closed_ принцип.

[к оглавлению](#Паттерны)

### Недостатки Моста
+ Усложняет код программы из-за введения дополнительных классов.

[к оглавлению](#Паттерны)

### Использование Моста
В данном примере Мост разделяет монолитный код приборов и пультов на `2` части : _приборы_ (выступают реализацией) и _пульты_ управления ими (выступают абстракцией).

![alt text](https://refactoring.guru/images/patterns/diagrams/bridge/example-ru.png)

Класс пульта имеет ссылку на экземпляр прибора, которым он управляет. Таким образом, клиентский код только один раз работает напрямую с реализацией - в момент инициализации он должен выбрать версию абстракции и реализации и связать иъ между собой.

[к оглавлению](#Паттерны)

## Composite (Компоновщик)
_Компоновщик_ помогает объединить множество объектов в древовидную структуру и работать с ними, как с одним объектом.

[к оглавлению](#Паттерны)

### Назначение Компоновщика
+ Помогает однообразно работать со всеми элементами древовидной структуры сразу через одну точку входа (root).

[к оглавлению](#Паттерны)

### Схема Компоновщика
![alt text](https://refactoring.guru/images/patterns/diagrams/composite/structure-ru.png)

+ Компонент (`Component`) определяет общий интерфейс для простых и составных компонентов дерева.
+ Лист (`Leaf`) — это простой компонент дерева, не имеющий ответвлений. Из-за того, что им некому больше передавать выполнение, классы листьев будут содержать большую часть полезного кода.
+ Контейнер (`Composite`) (или композит) — это составной компонент дерева. Он содержит набор дочерних компонентов, но ничего не знает об их типах. Это могут быть как простые компоненты-листья, так и другие компоненты-контейнеры. Но это не является проблемой, если все дочерние компоненты следуют единому интерфейсу. Методы контейнера переадресуют основную работу своим дочерним компонентам, хотя и могут добавлять что-то своё к результату.
+ Клиент (`Client`) работает с деревом через общий интерфейс компонентов. Благодаря этому, клиенту не важно, что перед ним находится — простой или составной компонент дерева.
  
[к оглавлению](#Паттерны)

### Преимущества Компоновщика
+ Упрощение клиентского кода при работе со сложными древовидными структурами.
+ Облегчение добавления новых компонентов.

[к оглавлению](#Паттерны)

### Недостатки Компоновщика
+ Создает слишком общий дизайн классов.

[к оглавлению](#Паттерны)

### Использование Компоновщика
Классический пример использования Компоновщика - это вложенные геометрические фигуры.

![alt text](https://refactoring.guru/images/patterns/diagrams/composite/example.png)

Здесь класс `CompoundGraphic` может содержать любое количество подфигур, включая такие же контейнеры, как и он сам. При этом контейнер реализует те же методы, что и обычные фигуры, но делегирует их выполнение дочерним фигурам. Таким образом, клиентский код работает со всеми фигурами чере общий интерфейс, не зная, перед ним обычная фигура или составная. Также можно заметить, что вызов метода `draw()` на объекте root контейнера позволит отрисовать все объекты из иерархии.

Стандартные примеры Компоновщика тоже относятся к графическим библиотекам :
+ `java.awt.Container.add(Component)` (аналоги есть во многих местах в Swing)
+ `javax.faces.component.UIComponent.getChildren()` (аналоги есть во многих местах JSF UI) 

[к оглавлению](#Паттерны)

## Decorator (Декоратор)
_Декоратор_ применяется для добавления функциональности какому-либо компоненту без непосредственной его модификации.

[к оглавлению](#Паттерны)

### Назначение Декоратора
+ Добавление дополнительного поведения объектам на лету, незаметно для кода, который их использует.
+ Добавление дополнительного поведения объектам, когда это невозможно с помощью наследования (например, класс `final`).

[к оглавлению](#Паттерны)

### Схема Декоратора
![alt text](https://refactoring.guru/images/patterns/diagrams/decorator/structure.png)

+ Компонент (`Component`) задаёт общий интерфейс обёрток и оборачиваемых объектов.
+ Конкретный компонент (`Concrete Component`) определяет класс оборачиваемых объектов. Он содержит какое-то базовое поведение, которое потом изменяют декораторы.
+ Базовый декоратор (`Base Decorator`) хранит ссылку на вложенный объект-компонент. Им может быть как конкретный компонент, так и один из конкретных декораторов. Базовый декоратор делегирует все свои операции вложенному объекту. Дополнительное поведение будет жить в конкретных декораторах.
+ Конкретные декораторы (`Concrete Decorators`) — это различные вариации декораторов, которые содержат добавочное поведение. Оно выполняется до или после вызова аналогичного поведения обёрнутого объекта.
+ Клиент (`Client`) может оборачивать простые компоненты и декораторы в другие декораторы, работая со всеми объектами через общий интерфейс компонентов.

[к оглавлению](#Паттерны)

### Преимущества Декоратора
+ Большая гибкость, чем у наследования.
+ Позволяет добавлять поведение на лету.
+ Можно добавлять несколько новых обязанностей (разные поведения) сразу.
+ Позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни.

[к оглавлению](#Паттерны)

### Недостатки Декоратора
+ Трудность конфигурации многократно обернутых объектов.
+ Обилие крошечных классов.

[к оглавлению](#Паттерны)

### Использование Декоратора
+ Все подклассы `java.io.InputStream`, `OutputStream`, `Reader` и `Writer` имеют конструктор, принимающий инстанс того же типа.
+ `java.util.Collections`, `checkedXXX()`, `synchronizedXXX()` и `unmodifiableXXX()` методы.
+ `javax.servlet.http.HttpServletRequestWrapper` и `HttpServletResponseWrapper`.

[к оглавлению](#Паттерны)
