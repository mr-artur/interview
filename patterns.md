# Паттерны
+ [Что такое _Паттерн_?](#Что-такое-Паттерн)
+ [Классификация паттернов](#Классификация-паттернов)
+ [Factory Method (Фабричный метод)](#Factory-Method-Фабричный-метод) ([цель](#Назначение-Фабричного-метода) | [схема](#Схема-Фабричного-метода) | [преимущества](#Преимущества-Фабричного-метода) | [недостатки](#Недостатки-Фабричного-метода) | [использование](#Использование-Фабричного-метода))
+ [Abstract Factory (Абстрактная фабрика)](#Abstract-Factory-Абстрактная-фабрика) ([цель](#Назначение-Абстрактной-фабрики) | [схема](#Схема-Абстрактной-фабрики) | [преимущества](#Преимущества-Абстрактной-фабрики) | [недостатки](#Недостатки-Абстрактной-фабрики) | [использование](#Использование-Абстрактной-фабрики))

## Что такое _Паттерн_?
_Паттерны (шаблоны) проектирования_ - это способы решения часто встречающихся проблем при проектировании программ.

[к оглавлению](#Паттерны)

## Классификация паттернов
По предназначению паттерны делятся на `3` группы :
+ ___Порождающие___ - те, которые беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей. К порождающим паттернам относятся :
    + Фабричный метод
    + Абстрактная фабрика
    + Строитель
    + Прототип
    + Одиночка
+ ___Структурные___ - те, которые описывают разные способы построения связей между объектами. К структурным паттернам относятся :
    + Адаптер
    + Мост
    + Компоновщик
    + Декоратор
    + Фасад
    + Легковес
    + Заместитель
+ ___Поведенческие___ - те, которые заботятся об эффективной коммуникации между объектами. К поведенческим паттернам относятся :
    + Цепочка обязанностей
    + Команда
    + Итератор
    + Посредник
    + Снимок
    + Наблюдатель
    + Состояние
    + Стратегия
    + Шаблонный метод
    + Посетитель
    + Делегат
    
[к оглавлению](#Паттерны)

## Factory Method (Фабричный метод)
_Фабричный метод_ определяет стандартный метод создания объекта, не связанный с вызовом конструктора, оставляя решение о том, какой именно объект создавать, за подклассами.

[к оглавлению](#Паттерны)

### Назначение Фабричного метода
+ Фабричный метод позволяет отделить логику создания объектов от их использования в клиентском коде. Благодаря этому, код производства можно изменять, не трогая основной (клиентский). Например, мы можем добавить кеширование объектов, поместив его код в фабричный метод, не засоряя при этом клиентский код.
+ Фабричный метод нужен для создания объектов разных типов с помощью одного и того же интерфейса.

[к оглавлению](#Паттерны)

### Схема Фабричного метода
![alt text](https://i.ibb.co/7t6z3mS/pattern-1.jpg)

+ `Product` - интерфейс создаваемых объектов.
+ `ConcreteProduct` - реализация `Product`. Создание объектов этого класса возлагается на класс `ConcreteCreator`.
+ `Creator` - интерфейс, который определяет метод, "фабрикующий" объекты.
+ `ConcreteCreator` - класс, реализующий интерфейс `Creator` и соответственно определяющий тело метода `factoryMethod()`. Этот метод может возвращать любой объект, реализующий интерфейс `Product`.

[к оглавлению](#Паттерны)

### Преимущества Фабричного метода
+ Избавляет клиентский код от привязки к конкретному классу продукта.
+ Выделяет код производства продуктов в одно место, упрощая поддержку кода.
+ Упрощает добавление новых продуктов в программу.
+ Реализует _Open / Closed_ принцип.

[к оглавлению](#Паттерны)

### Недостатки Фабричного метода
+ Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создавать свой класс создателя.

[к оглавлению](#Паттерны)

### Использование Фабричного метода
+ `java.lang.Object.toString()` - переопределяемый во всех подклассах фабричный метод.
+ `java.lang.Class.newInstance()`
+ `java.lang.Integer.valueOf(String)` (также в `Boolean`, `Byte`, `Character`, `Short`, `Long`, `Float` и `Double`).
+ `java.lang.Class.forName()`
+ `java.lang.reflect.Array.newInstance()`
+ `java.lang.reflect.Constructor.newInstance()`
+ `java.util.Map.of()` и т.д.

[к оглавлению](#Паттерны)

## Abstract Factory (Абстрактная фабрика)
_Абстрактная фабрика_ помогает нам создавать семейства связанных объектов, не привязываясь к к конкретным классам создаваемых объектов. 

Абстрактная фабрика является расширением _Фабричного метода_ и может быть создана вследствии наличия большого количества фабричных методов, которые реорганизовывают в иерархию классов.

[к оглавлению](#Паттерны)

### Назначение Абстрактной фабрики
+ Помогает производить семейства продуктов (связанных между собой), при этом клиентский код может работать с такими семействами одинаково.

[к оглавлению](#Паттерны)

### Схема Абстрактной фабрики
![alt text](https://i.ibb.co/Y8kcZ48/pattern-2.jpg)

+ `AbstractFactory` - абстрактный класс или интерфейс, который определяет механизмы создания абстрактных продуктов.
+ `AbstractProduct` - абстрактный класс или интерфейс, который который описывает базовые функции ресурса, который будет использоваться в приложении.
+ `ConcreteFactory` - класс, порожденный от класса `AbstractFactory` и реализующий методы получения одного или нескольких конкретных продуктов.
+ `ConcreteProduct` - класс, порожденный от класса `AbstractProduct` и реализующий конкретный ресурс.

[к оглавлению](#Паттерны)

### Преимущества Абстрактной фабрики
+ Гарантирует сочитаемость создаваемых продуктов.
+ Избавляет клиентский код от привязки к конкретным типам продуктов
+ Выделяет код производства продуктов в одно место, упрощая поддержку кода.
+ Упрощает добавление новых продуктов и их семейств в программу.
+ Реализует _Open / Closed_ принцип.

[к оглавлению](#Паттерны)

### Недостатки Абстрактной фабрики
+ Усложняет код программы из-за введения множества дополнительных классов.
+ Требует наличия всех типов продуктов в каждом семействе.

[к оглавлению](#Паттерны)
