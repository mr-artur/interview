# Паттерны
+ [Что такое _Паттерн_?](#Что-такое-Паттерн)
+ [Классификация паттернов](#Классификация-паттернов)
### _Порождающие_ паттерны
+ [Factory Method / Фабричный метод ](#Factory-Method-Фабричный-метод) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Фабричного-метода) | [схема](#Схема-Фабричного-метода) | [преимущества](#Преимущества-Фабричного-метода) | [недостатки](#Недостатки-Фабричного-метода) | [использование](#Использование-Фабричного-метода))
+ [Abstract Factory / Абстрактная фабрика](#Abstract-Factory-Абстрактная-фабрика) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Абстрактной-фабрики) | [схема](#Схема-Абстрактной-фабрики) | [преимущества](#Преимущества-Абстрактной-фабрики) | [недостатки](#Недостатки-Абстрактной-фабрики) | [использование](#Использование-Абстрактной-фабрики))
+ [Builder / Строитель](#Builder-Строитель) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Строителя) | [схема](#Схема-Строителя) | [преимущества](#Преимущества-Строителя) | [недостатки](#Недостатки-Строителя) | [использование](#Использование-Строителя))
+ [Prototype / Прототип](#Prototype-Прототип) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Прототипа) | [схема](#Схема-Прототипа) | [преимущества](#Преимущества-Прототипа) | [недостатки](#Недостатки-Прототипа) | [использование](#Использование-Прототипа))
+ [Singleton / Одиночка](#Singleton-Одиночка) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Одиночки) | [схема](#Схема-Одиночки) | [преимущества](#Преимущества-Одиночки) | [недостатки](#Недостатки-Одиночки) | [использование](#Использование-Одиночки))
### _Структурные_ паттерны
+ [Adapter / Адаптер](#Adapter-Адаптер) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Адаптера) | [схема](#Схема-Адаптера) | [преимущества](#Преимущества-Адаптера) | [недостатки](#Недостатки-Адаптера) | [использование](#Использование-Адаптера))
+ [Bridge / Мост](#Bridge-Мост) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Моста) | [схема](#Схема-Моста) | [преимущества](#Преимущества-Моста) | [недостатки](#Недостатки-Моста) | [использование](#Использование-Моста))
+ [Composite / Компоновщик](#Composite-Компоновщик) &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; ([цель](#Назначение-Компоновщика) | [схема](#Схема-Компоновщика) | [преимущества](#Преимущества-Компоновщика) | [недостатки](#Недостатки-Компоновщика) | [использование](#Использование-Компоновщика))
+ [Decorator / Декоратор](#Decorator-Декоратор) &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Декоратора) | [схема](#Схема-Декоратора) | [преимущества](#Преимущества-Декоратора) | [недостатки](#Недостатки-Декоратора) | [использование](#Использование-Декоратора))
+ [Facade / Фасад](#Facade-Фасад) &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Фасада) | [схема](#Схема-Фасада) | [преимущества](#Преимущества-Фасада) | [недостатки](#Недостатки-Фасада) | [использование](#Использование-Фасада))
+ [Flyweight / Легковес](#Flyweight-Легковес) &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Легковеса) | [схема](#Схема-Легковеса) | [преимущества](#Преимущества-Легковеса) | [недостатки](#Недостатки-Легковеса) | [использование](#Использование-Легковеса))
+ [Proxy / Заместитель](#Proxy-Заместитель) &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Прокси) | [схема](#Схема-Прокси) | [преимущества](#Преимущества-Прокси) | [недостатки](#Недостатки-Прокси) | [использование](#Использование-Прокси))
### _Поведенческие_ паттерны
+ [Chain of Responsibility / Цепочка Обязанностей](#Chain-of-Responsibility-Цепочка-Обязанностей) &nbsp; &nbsp; ([цель](#Назначение-Цепочки-обязанностей) | [схема](#Схема-Цепочки-обязанностей) | [преимущества](#Преимущества-Цепочки-обязанностей) | [недостатки](#Недостатки-Цепочки-обязанностей) | [использование](#Использование-Цепочки-обязанностей))
+ [Command / Команда](#Command-Команда) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Команды) | [схема](#Схема-Команды) | [преимущества](#Преимущества-Команды) | [недостатки](#Недостатки-Команды) | [использование](#Использование-Команды))
+ [Iterator / Итератор](#Iterator-Итератор) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Итератора) | [схема](#Схема-Итератора) | [преимущества](#Преимущества-Итератора) | [недостатки](#Недостатки-Итератора) | [использование](#Использование-Итератора))
+ [Mediator / Посредник](#Mediator-Посредник) &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Посредника) | [схема](#Схема-Посредника) | [преимущества](#Преимущества-Посредника) | [недостатки](#Недостатки-Посредника) | [использование](#Использование-Посредника))
+ [Memento / Снимок](#Memento-Снимок) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Снимка) | [схема](#Схема-Снимка) | [преимущества](#Преимущества-Снимка) | [недостатки](#Недостатки-Снимка) | [использование](#Использование-Снимка))
+ [Observer / Наблюдатель](#Observer-Наблюдатель) &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Наблюдателя) | [схема](#Схема-Наблюдателя) | [преимущества](#Преимущества-Наблюдателя) | [недостатки](#Недостатки-Наблюдателя) | [использование](#Использование-Наблюдателя))
+ [State / Состояние](#State-Состояние) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Состояния) | [схема](#Схема-Состояния) | [преимущества](#Преимущества-Состояния) | [недостатки](#Недостатки-Состояния) | [использование](#Использование-Состояния))
+ [Strategy / Стратегия](#Strategy-Стратегия) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Стратегии) | [схема](#Схема-Стратегии) | [преимущества](#Преимущества-Стратегии) | [недостатки](#Недостатки-Стратегии) | [использование](#Использование-Стратегии))
+ [Template Method / Шаблонный Метод](#Template-Method-Шаблонный-Метод) &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Шаблонного-метода) | [схема](#Схема-Шаблонного-метода) | [преимущества](#Преимущества-Шаблонного-метода) | [недостатки](#Недостатки-Шаблонного-метода) | [использование](#Использование-Шаблонного-метода))
+ [Visitor / Посетитель](#Visitor-Посетитель) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([цель](#Назначение-Посетителя) | [схема](#Схема-Посетителя) | [преимущества](#Преимущества-Посетителя) | [недостатки](#Недостатки-Посетителя) | [использование](#Использование-Посетителя))
### _Системные_ паттерны
+ [Presentation паттерны](#Presentation-паттерны)
    + [MVC / Model-View-Controller](#MVC-Model-View-Controller) ([схема](#Схема-MVC))
    + [MVP / Model-View-Presenter](#MVP-Model-View-Presenter) ([схема](#Схема-MVP))
        + [Passive View](#Passive-View) 
        + [Supervising Controller](#Supervising-Controller)
    + [PM / Presentation Model](#PM-Presentation-Model) ([схема](#Схема-PM))
    + [MVVM / Model-View-ViewModel](#MVVM-Model-View-ViewModel) ([схема](#Схема-MVVM))
    + [RxPM / Rx-Presentation Model](#RxPM-Rx-Presentation-Model) ([схема](#Схема-RxPM))
    
## Что такое _Паттерн_?
_Паттерны (шаблоны) проектирования_ - это способы решения часто встречающихся проблем при проектировании программ.

[к оглавлению](#Паттерны)

## Классификация паттернов
По предназначению паттерны делятся на `3` группы :
+ ___Порождающие___ - те, которые беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей. К порождающим паттернам относятся :
    + Фабричный метод
    + Абстрактная фабрика
    + Строитель
    + Прототип
    + Одиночка
+ ___Структурные___ - те, которые описывают разные способы построения связей между объектами. К структурным паттернам относятся :
    + Адаптер
    + Мост
    + Компоновщик
    + Декоратор
    + Фасад
    + Легковес
    + Заместитель
+ ___Поведенческие___ - те, которые заботятся об эффективной коммуникации между объектами. К поведенческим паттернам относятся :
    + Цепочка обязанностей
    + Команда
    + Итератор
    + Посредник
    + Снимок
    + Наблюдатель
    + Состояние
    + Стратегия
    + Шаблонный метод
    + Посетитель

Можно также выделить и 4ю, самую большую группу :
+ ___Системные___ паттерны. Их существует много, и вот некоторые из них: 
    + MVC
    + MVP
    + PM
    + MVVM
    + RxPM
    
[к оглавлению](#Паттерны)

## Factory Method (Фабричный метод)
_Фабричный метод_ определяет стандартный метод создания объекта, не связанный с вызовом конструктора, оставляя решение о том, какой именно объект создавать, за подклассами.

[к оглавлению](#Паттерны)

### Назначение Фабричного метода
+ Фабричный метод позволяет отделить логику создания объектов от их использования в клиентском коде. Благодаря этому, код производства можно изменять, не трогая основной (клиентский). Например, мы можем добавить кеширование объектов, поместив его код в фабричный метод, не засоряя при этом клиентский код.
+ Фабричный метод нужен для создания объектов разных типов с помощью одного и того же интерфейса.

[к оглавлению](#Паттерны)

### Схема Фабричного метода
![alt text](https://i.ibb.co/7t6z3mS/pattern-1.jpg)

+ `Product` - интерфейс создаваемых объектов.
+ `ConcreteProduct` - реализация `Product`. Создание объектов этого класса возлагается на класс `ConcreteCreator`.
+ `Creator` - интерфейс, который определяет метод, "фабрикующий" объекты.
+ `ConcreteCreator` - класс, реализующий интерфейс `Creator` и соответственно определяющий тело метода `factoryMethod()`. Этот метод может возвращать любой объект, реализующий интерфейс `Product`.

[к оглавлению](#Паттерны)

### Преимущества Фабричного метода
+ Избавляет клиентский код от привязки к конкретному классу продукта.
+ Выделяет код производства продуктов в одно место, упрощая поддержку кода.
+ Упрощает добавление новых продуктов в программу.
+ Реализует _Open / Closed_ принцип.

[к оглавлению](#Паттерны)

### Недостатки Фабричного метода
+ Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создавать свой класс создателя.

[к оглавлению](#Паттерны)

### Использование Фабричного метода
В примерах фабричного метода создающие методы возвращают объект конкретного подтипа.
+ `java.lang.Object.toString()` - переопределяемый во всех подклассах фабричный метод.
+ `java.lang.Class.newInstance()`
+ `java.lang.Integer.valueOf(String)` (также в `Boolean`, `Byte`, `Character`, `Short`, `Long`, `Float` и `Double`).
+ `java.lang.Class.forName()`
+ `java.lang.reflect.Array.newInstance()`
+ `java.lang.reflect.Constructor.newInstance()`
+ `java.util.Map.of()` и т.д.

[к оглавлению](#Паттерны)

## Abstract Factory (Абстрактная фабрика)
_Абстрактная фабрика_ помогает нам создавать семейства связанных объектов, не привязываясь к к конкретным классам создаваемых объектов. 

Абстрактная фабрика является расширением _Фабричного метода_ и может быть создана вследствии наличия большого количества фабричных методов, которые реорганизовывают в иерархию классов.

[к оглавлению](#Паттерны)

### Назначение Абстрактной фабрики
+ Помогает производить семейства продуктов (связанных между собой), при этом клиентский код может работать с такими семействами одинаково.

[к оглавлению](#Паттерны)

### Схема Абстрактной фабрики
![alt text](https://i.ibb.co/Y8kcZ48/pattern-2.jpg)

+ `AbstractFactory` - абстрактный класс или интерфейс, который определяет механизмы создания абстрактных продуктов.
+ `AbstractProduct` - абстрактный класс или интерфейс, который который описывает базовые функции ресурса, который будет использоваться в приложении.
+ `ConcreteFactory` - класс, порожденный от класса `AbstractFactory` и реализующий методы получения одного или нескольких конкретных продуктов.
+ `ConcreteProduct` - класс, порожденный от класса `AbstractProduct` и реализующий конкретный ресурс.

[к оглавлению](#Паттерны)

### Преимущества Абстрактной фабрики
+ Гарантирует сочитаемость создаваемых продуктов.
+ Избавляет клиентский код от привязки к конкретным типам продуктов
+ Выделяет код производства продуктов в одно место, упрощая поддержку кода.
+ Упрощает добавление новых продуктов и их семейств в программу.
+ Реализует _Open / Closed_ принцип.

[к оглавлению](#Паттерны)

### Недостатки Абстрактной фабрики
+ Усложняет код программы из-за введения множества дополнительных классов.
+ Требует наличия всех типов продуктов в каждом семействе.

[к оглавлению](#Паттерны)

### Использование Абстрактной фабрики
Паттерн можно определить по методам, возвращающим фабрику, которая, в свою очередь, используется для создания конкретных продуктов, возвращая их через абстрактные типы или интерфейсы.
+ `java.util.Calendar.getInstance()`
+ `java.util.Arrays.asList()`
+ `java.util.ResourceBundle.getBundle()`
+ `java.net.URL.openConnection()`
+ `java.sql.DriverManager.getConnection()`
+ `java.sql.Connection.createStatement()`
+ `java.sql.Statement.executeQuery()`
+ `java.text.NumberFormat.getInstance()`
+ `java.lang.management.ManagementFactory` (все `getXXX()` методы)
+ `java.nio.charset.Charset.forName()`
+ `javax.xml.parsers.DocumentBuilderFactory.newInstance()`
+ `javax.xml.transform.TransformerFactory.newInstance()`
+ `javax.xml.xpath.XPathFactory.newInstance()`
+ `java.net.URLStreamHandlerFactory.createURLStreamHandler(String)` (Возвращает синглтон для каждого протокола)

[к оглавлению](#Паттерны)

## Builder (Строитель)
_Строитель_ позволяет нам создавать сложные объекты пошагово.

[к оглавлению](#Паттерны)

### Назначение Строителя
+ Главное назначение - это пошаговое построение сложных объектов.
+ Позволяет избавиться от сложных конструкторов.
+ Может использоваться для того, чтобы строить объекты разными способами (применение разных строителей с одним интерфейсом).

[к оглавлению](#Паттерны)

### Схема Строителя
![alt text](https://i.ibb.co/s1MxqNK/pattern-3.jpg)

+ `Director` - необязательный элемент. Содержит ссылку на экземпляр `AbstractBuilder`. По этой ссылке класс `Director` вызывает методы создания конкретного генератора классов, которые создают различные части продукта, что в итоге приводит к созданию объекта-продукта.
+ `AbstractBuilder` - интерфейс, определяющий методы, предназначенные для создания отдельных частей продукта.
+ `ConcreteBuilder` - класс, реализующий интерфейс `AbstractBuilder`. Он содержит реализацию всех его методов, нужных для создания `Product`. У класса `ConcreteBuilder` обязательно должен быть метод, возвращающий итоговый объект `Product`.
+ `Product` - полученный объект, может быть объявлен и как интерфейс.

[к оглавлению](#Паттерны)

### Преимущества Строителя
+ Позволяет создавать объекты пошагово.
+ Позволяет использовать один и тот же код для создание разных объектов.
+ Изолирует сложный код сборки продукта от его основной бизнес-логики.
+ Позволяет избежать огромных конструкторов.

[к оглавлению](#Паттерны)

### Недостатки Строителя
+ Усложняет код программы из-за добавления большего количества классов.
+ Клиент будет привязан к конкретным классам-строителям, так как в интерфейсе строителя может не быть метода получения результата.

[к оглавлению](#Паттерны)

### Использование Строителя
В примерах строителя создающие методы возаращают объект, на котором вызывается метод.
+ `java.lang.StringBuilder.append()` (несинхронизированный)
+ `java.lang.StringBuffer.append()` (синхронизированный)
+ `java.nio.ByteBuffer.put()` (также в `CharBuffer`, `ShortBuffer`, `IntBuffer`, `LongBuffer`, `FloatBuffer` and `DoubleBuffer`)
+ `javax.swing.GroupLayout.Group.addComponent()`
+ Все имплементации `java.lang.Appendable`

[к оглавлению](#Паттерны)

## Prototype (Прототип)
_Прототип_ позволяет нам копировать объекты, не вдаваясь в подробности их реализации.

Паттерн Прототип поручает создание копий самим копируемым объектам.

[к оглавлению](#Паттерны)

### Назначение Прототипа
+ Копирование любого объекта с помощью одного и того же интерфейса, не вникая в реализацию. Обычно это метод `clone()`.

[к оглавлению](#Паттерны)

### Схема Прототипа
![alt text](https://i.ibb.co/JcX9RK6/pattern-4.jpg)

Как видно из схемы, объект класса `Prototype` сам отвечает за свое копирование.

[к оглавлению](#Паттерны)

### Преимущества Прототипа
+ Позволяет копировать объекты, не привязываясь к их конкретным классам.
+ Меньше повторяющегося кода инициализации объектов.
+ Ускоряет создание объектов.
+ Альтернатива созданию подклассов для конструирования сложных объектов.

[к оглавлению](#Паттерны)

### Недостатки Прототипа
+ Сложность в клонировании составных объектов, имеющих ссылки на другие объекты.

[к оглавлению](#Паттерны)

### Использование Прототипа
В примерах прототипа создающие методы возвращают новый инстанс с такими же свойствами.
+ `java.lang.Object.clone()` (класс должен имплементировать `java.lang.Cloneable`)

[к оглавлению](#Паттерны)

## Singleton (Одиночка)
_Одиночка_ гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

Одиночка решает сразу `2` проблемы и таким образом нарушает _Single Responsibility_ принцип :
1. Гарантирует, что у класса есть только один экземпляр.
2. Предоставляет глобальную точку доступа.

[к оглавлению](#Паттерны)

### Назначение Одиночки
+ Применяется, когда нужно, чтобы в программе был единственный экземпляр какой-либо сущности, и при этом нужно обеспечить доступ к нему во всех элементах приложения.

[к оглавлению](#Паттерны)

### Схема Одиночки
![alt text](https://i.ibb.co/YZszHVY/pattern-5.jpg)

На данной схеме показан один из вариантов Одиночки. В нем инстанс хранится в приватном статическом поле, а его получение происходит через статический метод `getInstance()`, который, если поле пустое, инициализирует его, если не пустое, то возвращает существующий инстанс.

[к оглавлению](#Паттерны)

### Преимущества Одиночки
+ Гарантирует наличие единственного экземпляра класса.
+ Предоставляет глобальную точку доступа к экземпляру.
+ Реализует _lazy_ - инициализацию объекта - одиночки.

[к оглавлению](#Паттерны)

### Недостатки Одиночки
+ Нарушает _Single Responsibility_ принцип.
+ Маскирует плохой дизайн.
+ Испытывает проблемы с многопоточностью.
+ Требует постоянного создания mock-объектов при юнит-тестировании.

[к оглавлению](#Паттерны)

### Использование Одиночки
В примерах одиночки создающие методы возвращают один и тот же инстанс при каждом вызове.
+ `java.lang.Runtime.getRuntime()`
+ `java.awt.Desktop.getDesktop()`

[к оглавлению](#Паттерны)

## Adapter (Адаптер)
_Адаптер_ помогает адаптировать интерфейс одного класса для работы с ним в другом классе. Другими словами, он позволяет объектам с несовместимыми интерфейсами работать вместе.

[к оглавлению](#Паттерны)

### Назначение Адаптера
+ Нужен для создания возможности работать с классом, интерфейс которого нам не подходит.

[к оглавлению](#Паттерны)

### Схема Адаптера
![alt text](https://i.ibb.co/7Sd1Qg2/pattern-6.jpg)

+ `Framework` - это клиентский класс, использующий экземпляр класса `Adapter`. Для него необходимо воспользоваться методами объекта `Adaptee`, но не подходит его интерфейс.
+ `Adapter` - это класс, предоставляющий удобный интерфейс для `Framework` и под капотом работающий с агрегируемым экземпляром `Adaptee`.
+ `Adaptee` - это класс, в котором определены методы, подлежащие адаптации. Его интерфейс должен быть адаптированым для работы с ним в `Framework`.

[к оглавлению](#Паттерны)

### Преимущества Адаптера
+ Отделяет и скрывает от клиентского кода преобразование различных интерфейсов.

[к оглавлению](#Паттерны)

### Недостатки Адаптера
+ Усложнение кода из-за введения дополнительных классов.

[к оглавлению](#Паттерны)

### Использование Адаптера
Адаптер получает конвертируемый объект в конструкторе или через параметры своих методов. Методы Адаптера обычно совместимы с интерфейсом одного объекта. Они делегируют вызовы вложенному объекту, превратив перед этим параметры вызова в формат, поддерживаемый вложенным объектом.
+ `java.util.Arrays.asList()`
+ `java.util.Collections.list()`
+ `java.util.Collections.enumeration()`
+ `java.io.InputStreamReader(InputStream)` (возвращает `Reader`)
+ `java.io.OutputStreamWriter(OutputStream)` (возвращает `Writer`)
+ `javax.xml.bind.annotation.adapters.XmlAdapter.marshal()` и `.unmarshal()`

[к оглавлению](#Паттерны)

## Bridge (Мост)
_Мост_ помогает разделить один или несколько классов на две иерархии - абстракцию и реализацию, и позволяет их менять независимо друг от друга.

[к оглавлению](#Паттерны)

### Назначение Моста
+ Позволяет разделить компонент на две иерархии - абстракцию и реализацию, это позволяет изменять любую из них независимо от другой.    

[к оглавлению](#Паттерны)

### Схема Моста
![alt text](https://refactoring.guru/images/patterns/diagrams/bridge/structure-ru.png)

+ __Абстракция__ (`Abstraction`) содержит управляющую логику. Код абстракции делегирует реальную работу связанному объекту реализации.
+ __Реализация__ (`Implementation`) задаёт общий интерфейс для всех реализаций. Все методы, которые здесь описаны, будут доступны из класса абстракции и его подклассов. Интерфейсы абстракции и реализации могут как совпадать, так и быть совершенно разными. Но обычно в реализации живут базовые операции, на которых строятся сложные операции абстракции.
+ __Конкретные реализации__ (`Concrete implementations`) содержат платформо-зависимый код.
+ __Расширенные абстракции__ (`Refined Abstraction`) содержат различные вариации управляющей логики. Как и родитель, работает с реализациями только через общий интерфейс реализации.
+ __Клиент__ (`Client`) работает только с объектами абстракции. Не считая начального связывания абстракции с одной из реализаций, клиентский код не имеет прямого доступа к объектам реализации.

[к оглавлению](#Паттерны)

### Преимущества Моста
+ Позволяет строить платформо-независимые программы.
+ Скрывает лишние детали реализации от клиентского кода.
+ Реализует _Open / Closed_ принцип.

[к оглавлению](#Паттерны)

### Недостатки Моста
+ Усложняет код программы из-за введения дополнительных классов.

[к оглавлению](#Паттерны)

### Использование Моста
В данном примере Мост разделяет монолитный код приборов и пультов на `2` части : _приборы_ (выступают реализацией) и _пульты_ управления ими (выступают абстракцией).

![alt text](https://refactoring.guru/images/patterns/diagrams/bridge/example-ru.png)

Класс пульта имеет ссылку на экземпляр прибора, которым он управляет. Таким образом, клиентский код только один раз работает напрямую с реализацией - в момент инициализации он должен выбрать версию абстракции и реализации и связать иъ между собой.

[к оглавлению](#Паттерны)

## Composite (Компоновщик)
_Компоновщик_ помогает объединить множество объектов в древовидную структуру и работать с ними, как с одним объектом.

[к оглавлению](#Паттерны)

### Назначение Компоновщика
+ Помогает однообразно работать со всеми элементами древовидной структуры сразу через одну точку входа (root).

[к оглавлению](#Паттерны)

### Схема Компоновщика
![alt text](https://refactoring.guru/images/patterns/diagrams/composite/structure-ru.png)

+ __Компонент__ (`Component`) определяет общий интерфейс для простых и составных компонентов дерева.
+ __Лист__ (`Leaf`) — это простой компонент дерева, не имеющий ответвлений. Из-за того, что им некому больше передавать выполнение, классы листьев будут содержать большую часть полезного кода.
+ __Контейнер__ (`Composite`) (или композит) — это составной компонент дерева. Он содержит набор дочерних компонентов, но ничего не знает об их типах. Это могут быть как простые компоненты-листья, так и другие компоненты-контейнеры. Но это не является проблемой, если все дочерние компоненты следуют единому интерфейсу. Методы контейнера переадресуют основную работу своим дочерним компонентам, хотя и могут добавлять что-то своё к результату.
+ __Клиент__ (`Client`) работает с деревом через общий интерфейс компонентов. Благодаря этому, клиенту не важно, что перед ним находится — простой или составной компонент дерева.
  
[к оглавлению](#Паттерны)

### Преимущества Компоновщика
+ Упрощение клиентского кода при работе со сложными древовидными структурами.
+ Облегчение добавления новых компонентов.

[к оглавлению](#Паттерны)

### Недостатки Компоновщика
+ Создает слишком общий дизайн классов.

[к оглавлению](#Паттерны)

### Использование Компоновщика
Классический пример использования Компоновщика - это вложенные геометрические фигуры.

![alt text](https://refactoring.guru/images/patterns/diagrams/composite/example.png)

Здесь класс `CompoundGraphic` может содержать любое количество подфигур, включая такие же контейнеры, как и он сам. При этом контейнер реализует те же методы, что и обычные фигуры, но делегирует их выполнение дочерним фигурам. Таким образом, клиентский код работает со всеми фигурами чере общий интерфейс, не зная, перед ним обычная фигура или составная. Также можно заметить, что вызов метода `draw()` на объекте root контейнера позволит отрисовать все объекты из иерархии.

Стандартные примеры Компоновщика тоже относятся к графическим библиотекам :
+ `java.awt.Container.add(Component)` (обычно применим для компонентов Swing)
+ `javax.faces.component.UIComponent.getChildren()` (аналоги есть во многих местах JSF UI) 

[к оглавлению](#Паттерны)

## Decorator (Декоратор)
_Декоратор_ применяется для добавления функциональности какому-либо компоненту без непосредственной его модификации.

[к оглавлению](#Паттерны)

### Назначение Декоратора
+ Добавление дополнительного поведения объектам на лету, незаметно для кода, который их использует.
+ Добавление дополнительного поведения объектам, когда это невозможно с помощью наследования (например, класс `final`).

[к оглавлению](#Паттерны)

### Схема Декоратора
![alt text](https://refactoring.guru/images/patterns/diagrams/decorator/structure.png)

+ __Компонент__ (`Component`) задаёт общий интерфейс обёрток и оборачиваемых объектов.
+ __Конкретный компонент__ (`Concrete Component`) определяет класс оборачиваемых объектов. Он содержит какое-то базовое поведение, которое потом изменяют декораторы.
+ __Базовый декоратор__ (`Base Decorator`) хранит ссылку на вложенный объект-компонент. Им может быть как конкретный компонент, так и один из конкретных декораторов. Базовый декоратор делегирует все свои операции вложенному объекту. Дополнительное поведение будет жить в конкретных декораторах.
+ __Конкретные декораторы__ (`Concrete Decorators`) — это различные вариации декораторов, которые содержат добавочное поведение. Оно выполняется до или после вызова аналогичного поведения обёрнутого объекта.
+ __Клиент__ (`Client`) может оборачивать простые компоненты и декораторы в другие декораторы, работая со всеми объектами через общий интерфейс компонентов.

[к оглавлению](#Паттерны)

### Преимущества Декоратора
+ Большая гибкость, чем у наследования.
+ Позволяет добавлять поведение на лету.
+ Можно добавлять несколько новых обязанностей (разные поведения) сразу.
+ Позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни.

[к оглавлению](#Паттерны)

### Недостатки Декоратора
+ Трудность конфигурации многократно обернутых объектов.
+ Обилие крошечных классов.

[к оглавлению](#Паттерны)

### Использование Декоратора
+ Все подклассы `java.io.InputStream`, `OutputStream`, `Reader` и `Writer` имеют конструктор, принимающий инстанс того же типа.
+ `java.util.Collections`, `checkedXXX()`, `synchronizedXXX()` и `unmodifiableXXX()` методы.
+ `javax.servlet.http.HttpServletRequestWrapper` и `HttpServletResponseWrapper`.

[к оглавлению](#Паттерны)

## Facade (Фасад)
_Фасад_ предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

[к оглавлению](#Паттерны)

### Назначение Фасада
+ Представление простого или урезанного клиентского интерфейса к сложной системе.
+ Разделение системы на отдельные подслои и соответственно обеспечение связи между ними через фасады.

[к оглавлению](#Паттерны)

### Схема Фасада
![alt text](https://refactoring.guru/images/patterns/diagrams/facade/structure.png)

+ __Фасад__ (`Facade`) предоставляет быстрый доступ к определённой функциональности подсистемы. Он «знает», каким классам нужно переадресовать запрос, и какие данные для этого нужны.
+ __Дополнительный фасад__ (`Additional Facade`) можно ввести, чтобы не «захламлять» единственный фасад разнородной функциональностью. Он может использоваться как клиентом, так и другими фасадами.
+ __Сложная подсистема__ состоит из множества разнообразных классов. Для того, чтобы заставить их что-то делать, нужно знать подробности устройства подсистемы, порядок инициализации объектов и так далее. Классы подсистемы не знают о существовании фасада и работают друг с другом напрямую.
+ __Клиент__ (`Client`) использует фасад вместо прямой работы с объектами сложной подсистемы.

[к оглавлению](#Паттерны)

### Преимущества Фасада
+ Изолируент клиентский код от компонентов сложной подсистемы.

[к оглавлению](#Паттерны)

### Недостатки Фасада
+ Фасад рискует стать _God Object_, привязанный ко всем классам программы.

[к оглавлению](#Паттерны)

### Использование Фасада
В данном примере Фасад упрощает работу со сложным фреймворком видеоконвертации.

![alt text](https://refactoring.guru/images/patterns/diagrams/facade/example.png)

Вместо с непосредственной работы с кучей подклассов, фасад предоставляет коду приложения единственный метод для конвертации видео, который сам заботится о том, чтобы правильно сконфигурировать нужные объекты фреймворка и получить требуемый результат.

[к оглавлению](#Паттерны)

## Flyweight (Легковес)
_Легковес_, также известен как _Приспособленец_, позволяет разделять общие данные между разными объектами и таким образом экономить отведенную для них память.

[к оглавлению](#Паттерны)

### Назначение Легковеса
+ Уменьшение расхода оперативной памяти на хранение объектов за счет разделения общих данных между ними, вместо дублирования всех этих данных в каждом объекте.

[к оглавлению](#Паттерны)

### Схема Легковеса
Паттерн разделяет данные объектов в программе на две части — легковесы и контексты.

![alt text](https://refactoring.guru/images/patterns/diagrams/flyweight/structure.png)

+ __Легковес__ (`Flyweight`) содержит состояние, которое повторялось во множестве первоначальных объектов. Один и тот же легковес можно использовать в связке со множеством контекстов. Состояние, которое хранится здесь, называется внутренним, а то, которое он получает извне — внешним.
+ __Контекст__ (`Context`) содержит «внешнюю» часть состояния, уникальную для каждого объекта. Контекст связан с одним из объектов-легковесов, хранящих оставшееся состояние.
+ __Клиент__ (`Client`) вычисляет или хранит контекст, то есть внешнее состояние легковесов. Для клиента легковесы выглядят как шаблонные объекты, которые можно настроить во время использования, передав контекст через параметры.
+ __Фабрика легковесов__ (`FlyweightFactory`) управляет созданием и повторным использованием легковесов. Фабрика получает запросы, в которых указано желаемое состояние легковеса. Если легковес с таким состоянием уже создан, фабрика сразу его возвращает, а если нет — создаёт новый объект.

Поведение оригинального объекта чаще всего оставляют в Легковесе, передавая значения контекста через параметры методов. Тем не менее, поведение можно поместить и в контекст, используя легковес как объект данных.

[к оглавлению](#Паттерны)

### Преимущества Легковеса
+ Экономит оперативную память.

[к оглавлению](#Паттерны)

### Недостатки Легковеса
+ Расходует процессорное время на поиск / вычисление контекста.
+ Усложняет код программы из-за введения множества дополнительных классов.

[к оглавлению](#Паттерны)

### Использование Легковеса
+ `java.lang.Integer.valueOf(int)` (аналогично в `Boolean`, `Byte`, `Character`, `Short`, `Long`, `Float` и `Double`)
+ `java.lang.String.intern()` - метод, взаимодействующий со _String Pool_.

[к оглавлению](#Паттерны)

## Proxy (Заместитель)
_Прокси_ - это класс-заместитель реального объекта. Он позволяет выполнять какие-то операции до или после непосредственного вызова методов класса, которого он заменяет.

[к оглавлению](#Паттерны)

### Назначение Прокси
+ _Lazy_ инициализация (виртуальный прокси).
+ Защита доступа к объекту (защищающий прокси).
+ Локальный запуск удаленного сервиса (удаленный прокси).
+ Логирование запросов (логирующий прокси).
+ Кеширование объектов ("умная" ссылка).

[к оглавлению](#Паттерны)

### Схема Прокси
![alt text](https://refactoring.guru/images/patterns/diagrams/proxy/structure.png)

+ __Интерфейс сервиса__ (`ServiceInterface`) определяет общий интерфейс для сервиса и заместителя. Благодаря этому, объект заместителя можно использовать там, где ожидается объект сервиса.
+ __Сервис__ (`Service`) содержит полезную бизнес-логику.
+ __Заместитель__ (`Proxy`) хранит ссылку на объект сервиса. После того как заместитель заканчивает свою работу (например, инициализацию, логирование, защиту или другое), он передаёт вызовы вложенному сервису. Заместитель может сам отвечать за создание и удаление объекта сервиса.
+ __Клиент__ (`Client`) работает с объектами через интерфейс сервиса. Благодаря этому, его можно «одурачить», подменив объект сервиса объектом заместителя.

Также Прокси может быть реализован через наследование, например так сделано в Hibernate для _lazy_ инициализации.

[к оглавлению](#Паттерны)

### Преимущества Прокси
+ Позволяет контролировать сервисный объект независимо для клиента.
+ Может работать, даже если сервисный объект еще не создан.
+ Может контролировать жизненный цикл служебного объекта.

[к оглавлению](#Паттерны)

### Недостатки Прокси
+ Усложнение кода программы из-за введения дополнительных классов.
+ Увеличение времени отклика от сервиса как минимум за счет оверхеда в виде количества дополнительных вызываемых методов.

[к оглавлению](#Паттерны)

### Использование Прокси
Класс заместителя чаще всего делегирует всю настоящую работу своему реальному объекту. Заместители часто сами следят за жизненным циклом своего реального объекта.
+ _lazy_ инициализация в Hibernate.
+ `java.lang.reflect.Proxy`.
+ `java.rmi.*`, весь API фактически.

[к оглавлению](#Паттерны)

## Chain of Responsibility (Цепочка Обязанностей)
_Цепочка обязанностей_ используется для обработки запросов с помощью специальных обработчиков, которые образуют цепочку. Идея в том, что запрос последовательно передается по этим обработчикам, и каждый из них решает, должен ли он его обработать и передавать ли его следующему обработчику.

[к оглавлению](#Паттерны)

### Назначение Цепочки обязанностей
+ Обработка разнообразных запросов несколькими способами, при этом может быть неизвестно заранее какие запросы будут приходить и какие обработчики для них понадобятся.
+ Действия по обработке запроса проводятся в строгом порядке (обработчики идут один за другим).
+ Когда нужно динамически добавлять или удалять обработчики из цепочки.

[к оглавлению](#Паттерны)

### Схема Цепочки обязанностей
![alt text](https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/structure.png)

+ __Обработчик__ (`Handler`) определяет общий для всех конкретных обработчиков интерфейс. Обычно достаточно описать единственный метод обработки запросов, но иногда здесь может быть объявлен и метод выставления следующего обработчика.
+ __Базовый обработчик__ (`BaseHandler`) — опциональный класс, который позволяет избавиться от дублирования одного и того же кода во всех конкретных обработчиках. Обычно этот класс имеет поле для хранения ссылки на следующий обработчик в цепочке. Клиент связывает обработчики в цепь, подавая ссылку на следующий обработчик через конструктор или сеттер поля. Также здесь можно реализовать базовый метод обработки, который бы просто перенаправлял запрос следующему обработчику, проверив его наличие.
+ __Конкретные обработчики__ (`ConcreteHandlers`) содержат код обработки запросов. При получении запроса каждый обработчик решает, может ли он обработать запрос, а также стоит ли передать его следующему объекту. В большинстве случаев обработчики могут работать сами по себе и быть неизменяемыми, получив все нужные детали через параметры конструктора.
+ __Клиент__ (`Client`) может либо сформировать цепочку обработчиков единожды, либо перестраивать её динамически, в зависимости от логики программы. Клиент может отправлять запросы любому из объектов цепочки, не обязательно первому из них.

[к оглавлению](#Паттерны)

### Преимущества Цепочки обязанностей
+ Уменьшает зависимость между клиентом и обработчиками.
+ Реализует _Single Responsibility_ принцип.
+ Реализует _Open / Closed_ принцип.

[к оглавлению](#Паттерны)

### Недостатки Цепочки обязанностей
+ Запрос может остаться не обработанным.

[к оглавлению](#Паттерны)

### Использование Цепочки обязанностей
Цепочку обязанностей можно определить по спискам обработчиков или проверок, через которые пропускаются запросы. Особенно если порядок следования обработчиков важен.
+ `java.util.logging.Logger.log()` - логгирование.
+ `javax.servlet.Filter.doFilter()` - фильтры запросов в сервлетах.

[к оглавлению](#Паттерны)

## Command (Команда)
_Команда_ используется для представления запросов в виде объектов, и возможности их передачи в качестве аргументов в методы, выстраивания в очередь, отмены и т.д.

[к оглавлению](#Паттерны)

### Назначение Команды
+ Используется чтобы убрать зависимость между клиентским кодом и объектами, выполняющими операции.
+ Реализация отмены и повтора операций.
+ Реализация отложенного запуска операций.
+ Сбор сложных команд из простых.

[к оглавлению](#Паттерны)

### Схема Команды
![alt text](https://refactoring.guru/images/patterns/diagrams/command/structure.png)

+ __Отправитель__ (`Invoker`) хранит ссылку на объект команды и обращается к нему, когда нужно выполнить какое-то действие. Отправитель работает с командами только через их общий интерфейс. Он не знает, какую конкретно команду использует, так как получает готовый объект команды от клиента.
+__Команда__ (`Command`) описывает общий для всех конкретных команд интерфейс. Обычно здесь описан всего один метод для запуска команды.
+ __Конкретные команды__ (`Command`, `Command2`) реализуют различные запросы, следуя общему интерфейсу команд. Обычно команда не делает всю работу самостоятельно, а лишь передаёт вызов получателю, которым является один из объектов бизнес-логики. Параметры, с которыми команда обращается к получателю, следует хранить в виде полей. В большинстве случаев объекты команд можно сделать неизменяемыми, передавая в них все необходимые параметры только через конструктор.
+ __Получатель__ (`Receiver`) содержит бизнес-логику программы. В этой роли может выступать практически любой объект. Обычно команды перенаправляют вызовы получателям. Но иногда, чтобы упростить программу, вы можете избавиться от получателей, «слив» их код в классы команд.
+ __Клиент__ (`Client`) создаёт объекты конкретных команд, передавая в них все необходимые параметры, среди которых могут быть и ссылки на объекты получателей. После этого клиент связывает объекты отправителей с созданными командами.

[к оглавлению](#Паттерны)

### Преимущества Команды
+ Убирает прямую зависимость между объектами, вызывающими операции, и объектами, которые их непосредственно исполняют.
+ Позволяет реализовать простую отмену и повтор операций.
+ Позволяет реализовать отложенный запуск операций.
+ Позволяет собирать сложные команды из простых.
+ Реализует _Open / Closed_ принцип.

[к оглавлению](#Паттерны)

### Недостатки Команды
+ Усложняет код из-за введения множества дополнительных классов.

[к оглавлению](#Паттерны)

### Использование Команды
Классы команд построены вокруг одного действия и имеют очень узкий контекст. Объекты команд часто подаются в обработчики событий элементов GUI. Практически любая реализация отмены использует принципа команд.
+ Команды, выполняемые в зависимости от запроса на url сервлетного приложения, эти команды могут храниться как в `enum`, так и в мапе. Такие команды вызывают методы сервисов и выступают как прослойка между контроллером и слоем бизнес-логики.
+ Все имплементации `java.lang.Runnable`
+ Все имплементации `javax.swing.Action`

[к оглавлению](#Паттерны)

## Iterator (Итератор)
_Итератор_ помогает делать обход элементов объекта, не зная его внутренней структуры.

[к оглавлению](#Паттерны)

### Назначение Итератора
+ Помогает перебирать элементы объекта, чаще всего именно коллекции, с помощью одного и того же интерфейса, не зная при этом внутреннюю ее структуру.
+ Помогает скрыть сложность структуры данных.
+ Помогает реализовать несколько вариантов обхода структуры данных.

[к оглавлению](#Паттерны)

### Схема Итератора
![alt text](https://refactoring.guru/images/patterns/diagrams/iterator/structure.png)

[к оглавлению](#Паттерны)

### Преимущества Итератора
+ Упрощает классы хранения данных.
+ Позволяет реализовать различные способы обхода структуры данных.
+ Позволяет одновременно перемещаться по структуре данных в разные стороны.

[к оглавлению](#Паттерны)

### Недостатки Итератора
+ Не оправдан, если можно обойтись простым циклом.

[к оглавлению](#Паттерны)

### Использование Итератора
+ Все имплементации `java.util.Iterator` (учитывая и в `java.util.Scanner`) и его потомков.
+ Все имплементации `java.util.Enumeration`

[к оглавлению](#Паттерны)

## Mediator (Посредник)
_Посредник_ помогает уменьшить связанность множества классов между собой, благодаря перемещению этих связей в класс-посредник.

[к оглавлению](#Паттерны)

### Назначение Посредника
+ Уменьшить число связей в системе с помощью вынесения их в класс посредника, который будет заниматься этими связями. Это позволяет сделать более универсальными остальные компоненты системы.

[к оглавлению](#Паттерны)

### Схема Посредника
![alt text](https://refactoring.guru/images/patterns/diagrams/mediator/structure.png)

+ __Компоненты__ (`Component A,B,C,D`) — это разнородные объекты, содержащие бизнес-логику программы. Каждый компонент хранит ссылку на объект посредника, но работает с ним только через абстрактный интерфейс посредников. Благодаря этому, компоненты можно повторно использовать в другой программе, связав их с посредником другого типа.
+ __Посредник__ (`Mediator`) определяет интерфейс для обмена информацией с компонентами. Обычно хватает одного метода, чтобы оповещать посредника о событиях, произошедших в компонентах. В параметрах этого метода можно передавать детали события: ссылку на компонент, в котором оно произошло, и любые другие данные.
+ __Конкретный посредник__ (`ConcreteMediator`) содержит код взаимодействия нескольких компонентов между собой. Зачастую этот объект не только хранит ссылки на все свои компоненты, но и сам их создаёт, управляя дальнейшим жизненным циклом.

Компоненты не должны общаться друг с другом напрямую. Если в компоненте происходит важное событие, он должен оповестить своего посредника, а тот сам решит — касается ли событие других компонентов, и стоит ли их оповещать. При этом компонент-отправитель не знает кто обработает его запрос, а компонент-получатель не знает кто его прислал.

[к оглавлению](#Паттерны)

### Преимущества Посредника
+ Устраняет зависимости между компонентами, позволяя повторно их использовать.
+ Упрощает взаимодействие между компонентами.
+ Централизует управление в одном месте.

[к оглавлению](#Паттерны)

### Недостатки Посредника
+ Посредник может сильно раздуться и стать _God Object_.

[к оглавлению](#Паттерны)

### Использование Посредника
+ `java.util.Timer` (все `scheduleXXX()` методы)
+ `java.util.concurrent.Executor.execute()`
+ `java.util.concurrent.ExecutorService` (`invokeXXX()` и `submit()` методы)
+ `java.util.concurrent.ScheduledExecutorService` (все `scheduleXXX()` методы)
+ `java.lang.reflect.Method.invoke()`

[к оглавлению](#Паттерны)

## Memento (Снимок)
_Снимок_ помогает сохранять и восстанавливать прошлые состояния объектов, не раскрывая подробностей их реализации.

[к оглавлению](#Паттерны)

### Назначение Снимка
+ Применяется для сохранения состояния объекта и возможности его восстановления в дальнейшем, при этом не нарушая его инкапсуляцию.

[к оглавлению](#Паттерны)

### Схема Снимка
Классическая реализация основана на вложенных классах :

![alt text](https://refactoring.guru/images/patterns/diagrams/memento/structure1.png)

+ __Создатель__ (`Originator`) может производить снимки своего состояния, а также воспроизводить прошлое состояние, если подать в него готовый снимок.
+ __Снимок__ (`Memento`) — это простой объект данных, содержащий состояние создателя. Надёжнее всего сделать объекты снимков неизменяемыми, передавая в них состояние только через конструктор.
+ __Опекун__ (`Caretaker`) должен знать, когда делать снимок создателя и когда его нужно восстанавливать. Опекун может хранить историю прошлых состояний создателя в виде стека из снимков. Когда понадобится отменить выполненную операцию, он возьмёт «верхний» снимок из стека и передаст его создателю для восстановления.

В данной реализации снимок — это внутренний класс по отношению к классу создателя. Именно поэтому он имеет полный доступ к полям и методам создателя, даже приватным. С другой стороны, опекун не имеет доступа ни к состоянию, ни к методам снимков и может всего лишь хранить ссылки на эти объекты.

[к оглавлению](#Паттерны)

### Преимущества Снимка
+ Не нарушает инкапсуляцию исходного объекта.
+ Упрощает структуру исходного объекта. Ему не нужно хранить историю версий своего состояния.

[к оглавлению](#Паттерны)

### Недостатки Снимка
+ Требует много памяти, если клиенты слишком часто создают снимки.
+ Может повлечь дополнительные расходы памяти, если объекты, сохраняющие историю, не освобождают ресурсы, занятые устаревшими снимками.
+ В некоторых языках, как JavaScript, PHP, Python сложно гарантировать, чтобы только исходный код имел доступ к состоянию снимков.

[к оглавлению](#Паттерны)

### Использование Снимка
+ Применяется в играх и например текстовых редакторах.
+ `java.util.Date` (через сеттеры или конструкторы можно восстановить состояние даты с помощью значения `long`)
+ Все имплементации `java.io.Serializable`
+ Все имплементации `javax.faces.component.StateHolder`

[к оглавлению](#Паттерны)

## Observer (Наблюдатель)
_Наблюдатель_ позволяет подписываться одним объектам на события в других и реагировать на эти события.

[к оглавлению](#Паттерны)

### Назначение Наблюдателя
+ Изменение состояния одних объектов должно привести к изменению других, но заранее неизвестно, какие именно объекты должны реагировать.
+ Применяется, когда одни объекты должны реагировать на изменения в других, но только в определенных случаях.

[к оглавлению](#Паттерны)

### Схема Наблюдателя
![alt text](https://refactoring.guru/images/patterns/diagrams/observer/structure.png)

+ __Издатель__ (`Publisher`) владеет внутренним состоянием, изменение которого интересно отслеживать подписчикам. Издатель содержит механизм подписки: список подписчиков и методы подписки/отписки.
+ __Подписчик__ (`Subscriber`) определяет интерфейс, которым пользуется издатель для отправки оповещения. В большинстве случаев для этого достаточно единственного метода.
+ __Конкретные подписчики__ (`Concrete Subscribers`) выполняют что-то в ответ на оповещение, пришедшее от издателя. Эти классы должны следовать общему интерфейсу подписчиков, чтобы издатель не зависел от конкретных классов подписчиков.
+ __Клиент__ (`Client`) создаёт объекты издателей и подписчиков, а затем регистрирует подписчиков на обновления в издателях.

Когда внутреннее состояние издателя меняется, он оповещает своих подписчиков. Для этого издатель проходит по списку подписчиков и вызывает их метод оповещения, заданный в общем интерфейсе подписчиков.

По приходу оповещения подписчику нужно получить обновлённое состояние издателя. Издатель может передать это состояние через параметры метода оповещения. Более гибкий вариант — передавать через параметры весь объект издателя, чтобы подписчик мог сам получить требуемые данные. Как вариант, подписчик может постоянно хранить ссылку на объект издателя, переданный ему в конструкторе.

[к оглавлению](#Паттерны)

### Преимущества Наблюдателя
+ Издатели не зависят от конкретных классов подписчиков и наоборот.
+ Мы можем подписывать и отписывать подписчиков динамически.
+ Реализует _Open / Closed_ принцип.

[к оглавлению](#Паттерны)

### Недостатки Наблюдателя
+ Подписчики оповещаются в случайном порядке.

[к оглавлению](#Паттерны)

### Использование Наблюдателя
+ `java.util.Observer/java.util.Observable` (редко используется в реальных проектах)
+ Все имплементации `java.util.EventListener` (практически во всем Swing)
+ `javax.servlet.http.HttpSessionBindingListener`
+ `javax.servlet.http.HttpSessionAttributeListener`
+ `javax.faces.event.PhaseListener`

[к оглавлению](#Паттерны)

## State (Состояние)
_Состояние_ позволяет объектам менять поведение в зависимости от своего состояния. Извне создается впечатление, что изменился класс объекта.

[к оглавлению](#Паттерны)

### Назначение Состояния
+ Возможность смены поведения объекта в зависимости от его состояния, то есть, избежания большого количества условных операторов.

[к оглавлению](#Паттерны)

### Схема Состояния
![alt text](https://refactoring.guru/images/patterns/diagrams/state/structure-ru.png)

+ __Контекст__ (`Context`) хранит ссылку на объект состояния и делегирует ему часть работы, зависящей от состояний. Контекст работает с этим объектом через общий интерфейс состояний. Контекст должен иметь метод для присваивания ему нового объекта-состояния.
+ __Состояние__ (`State`) описывает общий интерфейс для всех конкретных состояний.
+ __Конкретные состояния__ (`ConcreteStates`) реализуют поведения, связанные с определённым состоянием контекста. Иногда приходится создавать целые иерархии классов состояний, чтобы обобщить дублирующий код. Состояние может иметь обратную ссылку на объект контекста. Через неё не только удобно получать из контекста нужную информацию, но и осуществлять смену его состояния.
  
И контекст, и объекты конкретных состояний могут решать, когда и какое следующее состояние будет выбрано. Чтобы переключить состояние, нужно подать другой объект-состояние в контекст.

[к оглавлению](#Паттерны)

### Преимущества Состояния
+ Избавляет от множества условных операторов машины состояний.
+ Концентрирует в одном месте код, связанный с определенным состоянием.
+ Урощает код контекста.

[к оглавлению](#Паттерны)

### Недостатки Состояния
+ Если состояний мало и они редко меняются, может неоправданно усложнить код.

[к оглавлению](#Паттерны)

### Использование Состояния
В этом примере Состояние помогает изменять функциональность одних и тех же элементов управления музыкальным проигрывателем, в зависимости от того, в каком состоянии проигрыватель сейчас находится.

![alt text](https://refactoring.guru/images/patterns/diagrams/state/example.png)

Здесь объект `Player` делегирует выполнение некоторых своих методов объекту `State`, что позволяет подставлять разные реализации этих методов.

Пример использование из Java :
+ `javax.faces.lifecycle.LifeCycle.execute()` (управляемый с помощью `FacesServlet`, поведение зависит от конкретной фазы (state) жизненного цикла JSF)

[к оглавлению](#Паттерны)

## Strategy (Стратегия)
_Стратегия_ позволяет применять в одном месте разные алгоритмы во время выполнения программы.

[к оглавлению](#Паттерны)

### Назначение Стратегии
+ Применение разных алгоритмов для решения одной и той же задачи и возможность их менять динамически.

[к оглавлению](#Паттерны)

### Схема Стратегии
![alt text](https://refactoring.guru/images/patterns/diagrams/strategy/structure.png)

+ __Контекст__ (`Context`) хранит ссылку на объект конкретной стратегии, работая с ним через общий интерфейс стратегий.
+ __Стратегия__ (`Strategy`) определяет интерфейс, общий для всех вариаций алгоритма. Контекст использует этот интерфейс для вызова алгоритма. Для контекста неважно, какая именно вариация алгоритма будет выбрана, так как все они имеют одинаковый интерфейс.
+ __Конкретные стратегии__ (`ConcreteStrategies`) реализуют различные вариации алгоритма.
+ __Клиент__ (`Client`) должен создать объект конкретной стратегии и передать его в конструктор контекста. Кроме этого, клиент должен иметь возможность заменить стратегию на лету, используя сеттер. Благодаря этому, контекст не будет знать о том, какая именно стратегия сейчас выбрана.

Во время выполнения программы контекст получает вызовы от клиента и делегирует их объекту конкретной стратегии.

[к оглавлению](#Паттерны)

### Преимущества Стратегии
+ Горячая замена алгоритмов на лету.
+ Изолирует код и данные алгоритмов от остальных классов.
+ Уход от наследования к делегированию.
+ Реализует _Open / Closed_ принцип.

[к оглавлению](#Паттерны)

### Недостатки Стратегии
+ Усложняет программу за счет дополнительных классов.
+ Клиент должен знать, в чем состоит разница между стратегиями, чтобы выбрать подходящую.

[к оглавлению](#Паттерны)

### Использование Стратегии
+ `java.util.Comparator.compare()`, который используется например в `Collections.sort()`.
+ `javax.servlet.http.HttpServlet`, `service()` и все `doXXX()` методы принимающие `HttpServletRequest` и `HttpServletResponse` и имплементатор должен обработать их (и не сохранять их как поля инстанса).
+ `javax.servlet.Filter.doFilter()`

[к оглавлению](#Паттерны)

## Template Method (Шаблонный Метод)
_Шаблонный метод_ помогает вынести в класс-родитель часть алгоритма, которая повторяется в потомках.

[к оглавлению](#Паттерны)

### Назначение Шаблонного метода
+ Нужен, чтобы выносить общую логику из родственных класов в общего предка, таким образом устраняя дублирование.

[к оглавлению](#Паттерны)

### Схема Шаблонного метода
![alt text](https://refactoring.guru/images/patterns/diagrams/template-method/structure.png)

+ __Абстрактный класс__ (`AbstractClass`) определяет шаги алгоритма и содержит шаблонный метод, состоящий из вызовов этих шагов. Шаги могут быть как абстрактными, так и содержать реализацию по умолчанию.
+ __Конкретный класс__ (`ConcreteClass1`, `ConcreteClass2`) переопределяет некоторые (или все) шаги алгоритма. Конкретные классы не переопределяют сам шаблонный метод.

[к оглавлению](#Паттерны)

### Преимущества Шаблонного метода
+ Упрощает повторное использование кода.
+ Устраняет дублирование.

[к оглавлению](#Паттерны)

### Недостатки Шаблонного метода
+ Жестко ограничивает нас скелетом существующего алгоритма.
+ Мы можем нарушить _Liskov_ принцип, изменяя базовое поведение одного из шагов алгоритма через подкласс.
+ С ростом количества шагов шаблонный метод может стать слишком трудно поддерживать.

[к оглавлению](#Паттерны)

### Использование Шаблонного метода
+ Пример из проекта поиска маршрутов, где общая логика засекания времени, потраченного на рассчеты, вынесена в абстрактный класс-родитель, общий для всех стратегий поиска маршрута.
+ Все неабстрактные методы `java.io.InputStream`, `java.io.OutputStream`, `java.io.Reader` и `java.io.Writer`.
+ Все неабстрактные методы `java.util.AbstractList`, `java.util.AbstractSet` и `java.util.AbstractMap`.

[к оглавлению](#Паттерны)

## Visitor (Посетитель)
_Посетитель_ помогает добавлять в программу операции, при этом не меняя классы объектов, над которыми эти операции будут производиться.

[к оглавлению](#Паттерны)

### Назначение Посетителя
+ Можем использовать, когда нам нужно выполнить какую-то операцию над всеми элементами сложной структуры объектов, например, дерева.
+ Актуально также, когда над объектами сложной структуры надо выполнить не связанные между собой операции, но мы не хотим засорять классы такими операциями.

[к оглавлению](#Паттерны)

### Схема Посетителя
![alt text](https://refactoring.guru/images/patterns/diagrams/visitor/structure-ru.png)

+ __Посетитель__ (`Visitor`) описывает общий интерфейс для всех типов посетителей. Он объявляет набор методов, отличающихся типом входящего параметра, которые нужны для запуска операции для всех типов конкретных элементов. В языках, поддерживающих перегрузку методов, эти методы могут иметь одинаковые имена, но типы их параметров должны отличаться.
+ __Конкретные посетители__ (`ConcreteVisitors`) реализуют какое-то особенное поведение для всех типов элементов, которые можно подать через методы интерфейса посетителя.
+ __Элемент__ (`Element`) описывает метод принятия посетителя. Этот метод должен иметь единственный параметр, объявленный с типом интерфейса посетителя.
+ __Конкретные элементы__ (`ElementA`, `ElementB`) реализуют методы принятия посетителя. Цель этого метода — вызвать тот метод посещения, который соответствует типу этого элемента. Так посетитель узнает, с каким именно элементом он работает.
+ __Клиентом__ (`Client`) зачастую выступает коллекция или сложный составной объект, например, дерево Компоновщика. Зачастую клиент не привязан к конкретным классам элементов, работая с ними через общий интерфейс элементов.

[к оглавлению](#Паттерны)

### Преимущества Посетителя
+ Упрощение добавления операций, работающих со сложными структурами объектов.
+ Объединяет родственные операции в одном классе.
+ Посетитель может накапливать состояние при обходе структуры элементов.

[к оглавлению](#Паттерны)

### Недостатки Посетителя
+ Паттерн не оправдан, если иерархия элементов часто меняется.
+ Может привести к нарушению инкапсуляции элементов.

[к оглавлению](#Паттерны)

### Использование Посетителя
+ `javax.lang.model.element.AnnotationValue` and `AnnotationValueVisitor`
+ `javax.lang.model.element.Element` and `ElementVisitor`
+ `javax.lang.model.type.TypeMirror` and `TypeVisitor`

[к оглавлению](#Паттерны)

## Presentation паттерны
_Презентационные_ шаблоны служат для отделения UI-кода (`View`) от кода логики (`Presenter`, `Controller`, `ViewModel` и т.д.) и кода обработки данных (`Model`). Это позволяет :
+ Менять UI, логику и код обработки данных независимо один от другого (не нужно менять и другие слои тоже).
+ Облегчение тестирования приложения.

Иерархия презентационных паттернов :

![alt text](https://habrastorage.org/files/1f2/2c1/6bd/1f22c16bd5ab47f5b317d1cae555a170.jpg)

[к оглавлению](#Паттерны)

## MVC (Model-View-Controller)
+ _MVC_ подразумевает три слоя приложения : 
    + _Model_ - это данные нашего приложения, логика их получения и сохранения.
    + _View_ - отвечает за отображение UI на экране. View также может наблюдать за моделью и отображать данные из нее.
    + _Controller_ - обрабатывает действия пользователя и обновляет в соответствии с ними модель или вью. 
+ Основная особенность MVC в том, что все взаимодействие с пользователем в нем идет через _Controller_.

[к оглавлению](#Паттерны)

### Схема MVC
![alt text](https://habrastorage.org/files/ffb/a13/9d5/ffba139d5caf44df94483e459b99cd68.png)

[к оглавлению](#Паттерны)

## MVP (Model-View-Presenter)
+ В _MVP_ вместо Контроллера появляется _Presenter_, а взаимодействие с пользователем идет через _View_.
+ Здесь слои означают следующее :
    + _Model_ - это данные приложения, логика их получения и сохранения.
    + _View_ - обычно это форма с виджетами. Пользователь взаимодействует с ней, и когда какое-то событие виджета будет затрагивать логику интерфейса, View будет направлять его Презентеру.
    + _Presenter_ - содержит всю логику пользовательского интерфейса и отвечает за синхронизацию модели и представления. Когда представление уведомляет презентер, что пользователь что-то наделал (например, нажал кнопку), презентер принимает решение об обновлении модели и синхронизирует все изменения между моделью и представлением.
+ Важной особенностью является то, что _Presenter_ не общается с _View_ напрямую. Вместо этого он общается через интерфейс. Это дает возможность тестировать Презентер и Вью по отдельности.    
+ Существует два вида паттерна _MVP_ : _Passive View_ и _Supervising Controller_.
+ Плюсы MVP :
    + Простота и прямолинейность.

[к оглавлению](#Паттерны)

### Схема MVP
![alt text](https://habrastorage.org/files/0ca/527/44b/0ca52744b20f4d54bee49198af906f57.png)

[к оглавлению](#Паттерны)

### Passive View
+ В этом варианте MVP представление ничего не знает о модели. Презентер будет считывать информацию из модели и обновлять свойства во Вью.
+ Используется довольно часто.
+ Пример Passive View :
```java
public PersonalDataView : UserControl, IPersonalDataView
  {
      TextBox _firstNameTextBox;

      public string FirstName
      {
          get
          {
              return _firstNameTextBox.Value;
          }
          set 
          {
              _firstNameTextBox.Value = value;
          }
      }
  }
```
Как можно заметить, требуется писать много кода как во View, так и в презентере. Тем не менее, это делает взаимодействие между ними более тестируемым.

[к оглавлению](#Паттерны)

### Supervising Controller
+ В этом варианте MVP представление знает о модели и отвечает за связывание данных с отображением. Это уменьшает количество кода для связки между Презентером и Вью, но в ущерб их тестирования.
+ Используется редко по сравнению с _Passive View_.
+ Пример Supervising Controller :
```java
public class PersonalDataView : UserControl, IPersonalDataView
  {
      protected TextBox _firstNameTextBox;

      public void SetPersonalData(PersonalData data)
      {
          _firstNameTextBox.Value = data.FirstName;
      }

      public void UpdatePersonalData(PersonalData data)
      {
          data.FirstName = _firstNameTextBox.Value;
      }
  }
```
Как видим, этот интерфейс является менее детальным и возлагает больше ответственности на View.

[к оглавлению](#Паттерны)

## PM (Presentation Model)
+ _Presentation Model_ используется на месте _Controller_ или _Presenter_ и представляет собой __логическое представление__ пользовательского интерфейса, не опираясь на какие-либо визуальные элементы.
+ _Presentation Model_ имеет несколько обязанностей :
  + __Содержит логику пользовательского интерфейса.__ Так же, как и _Presenter_, _Presentation Model_ содержит логику пользовательского интерфейса. Когда мы нажимаем на кнопку, это событие направляется в _Presentation Model_, которая затем решает, что с ним делать.
  + __Предоставляет данные из модели для отображения на экране.__ _Presentation Model_ может преобразовывать данные модели так, чтобы они были легко отображены на экране. Это особенно актуально, когда информация собирается из разных мест, например, веб-сервисов.
  + __Хранит состояние пользовательского интерфейса.__ Зачастую пользовательский интерфейс должен хранить дополнительную информацию о своем состоянии, но тут _Presentation Model_ может хранить эту информацию в свойствах.
+ _View_ может легко извлекать данные из _Presentation Model_ и получать всю необходимую информацию для отображения на экране.
+ Паттерн _Presentation Model_ никак не описывает, каким образом _View_ использует данные из модели (_Presentation Model_).
+ Одно из преимуществ такого подхода заключается в том, что мы можем создать логическое и полностью тестируемое представление нашего UI, не полагаясь на тестирование визуальных элементов.
+ Основная проблема паттерна - это синхронизиция состояния _Presentation Model_ и _View_. Нужно заботиться об этом самостоятельно, применяя паттерн _Наблюдатель_. По итогу может получиться много повторяющегося кода.

[к оглавлению](#Паттерны)

### Схема PM
![alt text](https://habrastorage.org/files/fa6/5fd/043/fa65fd04305e4fc6895f44e5d76d4c92.png)

[к оглавлению](#Паттерны)

## MVVM (Model-View-ViewModel)
+ _MVVM_ очень похож на _Presentation Model_, чуть ли не единственное отличие в том, что тут используется _data binding_.
+ _ViewModel_ не может общаться со _View_ напрямую. Вместо этого она предоставляет легко связываемые свойства и методы в виде команд. _View_ может привязываться к этим свойствам, чтобы получать информацию из _ViewModel_ и вызывать на ней команды (методы).
+ _View_ не знает о _ViewModel_, таким образом мы можем использовать любую _ViewModel_ для нашей _View_.
+ Преимущества _MVVM_ :
    + Автоматический _data binding_, из которого вытекают остальные преимущества.
    + Мы получаем полностью тестируемую логическую модель для нашего приложения.
    + Само представление может быть довольно простым, поскольку _ViewModel_ предоставляет _View_ всю информацию в удобном виде.
    + Позволяет избежать так называемого _code behind_ - кода для _View_.
+ Недостатки _MVVM_ :
    + Код в верстке.
    + В нем проблематично "чисто" реализовать какие-то анимации или что-либо сделать со _View_ из кода.

[к оглавлению](#Паттерны)

### Схема MVVM
![alt text](https://habrastorage.org/files/77c/6f6/70e/77c6f670eaa245d191b958a20841fbd0.png)

[к оглавлению](#Паттерны)

## RxPM (Rx-Presentation Model)
+ Реализует реактивный подход, который основывается на потоках данных. Базируется на _Observables_ и _Observers_.
+ Основное преимущество _Rx-Presentation Model_ перед остальными вышеперечисленными паттернами - это взаимодействие _View_ с посредником в декларативном стиле, в отличие от императивности в остальных паттернах.
+ Плюсы подхода _Rx-Presentation Model_ :
    + Декларативное описание логики в _Presentation Model_.
    + _Presentation Model_ представляет собой абстракцию _View_, не завязанную на конкретные виджеты.
    + Позволяет не разрывать реактивные цепочки _Observable_ и протягивать их от модели до _View_ и наоборот. Это избавляет от императивного взаимодействия со _View_.
    + Не нужно беспокоиться о том, присоединена _View_ или нет. Просто меняем значение Rx-property и View автоматически получит стейт, когда подпишется.
    + События от _View_ получаются в реактивном стиле и таким образом удобно применять Rx операторы, чтобы фильтровать, объединять и т.д.
+ Минусы подхода _Rx-Presentation Model_ :
    + Необходимо писать код связывания, но с Rx это легко.
    + Начав использовать Rx, приходится использовать его повсюду.

[к оглавлению](#Паттерны)

### Схема RxPM
![alt text](https://habrastorage.org/files/58f/f9e/e3a/58ff9ee3a76f4f2e9aebed8520e93abb.jpg)

[к оглавлению](#Паттерны)
