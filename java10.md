# Java 10
+ [Что нового появилось в Java 10?](#Что-нового-появилось-в-Java-10)
+ [Local-Variable Type Inference](#Local-Variable-Type-Inference)
+ [Сборщик мусора _G1_ стал параллельным](#Сборщик-мусора-G1-стал-параллельным)
+ [`Optional.orElseThrow`](#OptionalorElseThrow)
    + [Пример `orElseThrow`](#Пример-orElseThrow)

## Что нового появилось в Java 10?
+ Local-Variable Type Inference - возможность указать вместо явного типа переменной зарезервированное слово `var` ([_перейти_](#Local-Variable-Type-Inference))
+ Сборщик мусора _G1_ стал параллельным ([_перейти_](#Сборщик-мусора-G1-стал-параллельным))
+ В `Locale` добавлена поддержка расширенных языковых _Unicode_ - тегов, например, включающих символы для обозначения валюты, первого дня недели и часового пояса.
+ Новый метод `orElseThrow` для `Optional` и подобных ему классов. ([_перейти_](#OptionalorElseThrow))
+ Объединение "леса JDK" в один репозиторий. Это просто объединение восьми репозиториев, которые были в Java 9 в один, чтобы коммиты были атомарными.

[к оглавлению](#Java-10)

## Local-Variable Type Inference
+ Начиная с Java 10, можно не указывать тип переменной при ее объявлении - вместо этого перед ней можно написать новое зарезервированное слово `var`, в этом случае компилятор сам выведет тип переменной из выражения инициализации.
+ Тип переменной на самом деле никуда не девается, просто убирается лишняя его запись.
+ При использовании `var` переменная должна быть обязательно проинициализирована. Следующий код не сработает :
```java
// Так не сработает:
var v1; // Error: Cannot infer type for local variable v1
v1 = new BigDecimal("101.2");
```
+ Что интересно, слово `var` - не ключевое, а зарезервированное имя типа. Так как `var` не является зарезервированным словом, то его можно использовать в качестве переменной и даже имени метода :
```java
public class Main {
 
    public static void main(String [] args) throws Exception {

        var var = var();
    }
 
    public static int var() {
        return 1;
    }
}
```
+ Недостаток `var` #1 заключается в том, что в дальнейшем он может добавить путаницу в определении типа переменной.
+ Недостаток `var` #2 заключается в том, что ссылке, объявленной с его помощью, присваивается тот тип, на значение которого она указывает. То есть, ни о каком полиморфизме тут речи не идет.
+ `var` стоит использовать в таких кейсах :
    + локальные переменные
    + переменные, инициализируемые внутри цикла `for`
    
[к оглавлению](#Java-10)

## Сборщик мусора _G1_ стал параллельным
В JDK 9 сборщиком мусора по умолчанию стал _G1_, в то время как раньше базовым сборщиком был _Parallel GC_, который мог собирать мусор в нескольких потоках. 

Теперь это сможет и G1, раньше он делал это в одном потоке, что иногда вызывало сложности. 

Кстати, разработчики смогут настраивать количество потоков с помощью параметра `-XX:ParallelGCThreads.`

[к оглавлению](#Java-10)

## `Optional.orElseThrow`
В Java 10 добавили новый метод `orElseThrow` для экземпляров класса `Optional` и ему подобных (например, `OptionalInt`).

Суть работы нового метода состоит в том, что он проверяет, есть ли значение в опциональной переменной, и если его нету, то выбрасывает по дефолту `NoSuchElementException`, или исключение, которое вернет аргумент функция-производитель.

`Optional.orElseThrow` имеет `2` перегруженные сигнатуры :
```java
T orElseThrow();

<X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X;
```

[к оглавлению](#Java-10)

#### Пример `orElseThrow`
`orElseThrow` - очень полезный метод. Пример его использования из реального проекта (метод сервиса) :
```java
public TodoVO findById(String todoId) {
    return todoGateway.findById(todoId)
        .orElseThrow(() -> new TodoNotFoundException(String.format("Todo with such id:%s can't be found", todoId)));
}
```

[к оглавлению](#Java-10)
