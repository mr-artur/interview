# Строки в Java
+ [Класс ```String```](#Класс-String)
+ [Создание строки](#Создание-строки)
+ [Методы String](#Методы-String)
+ [Для чего сделано, что строка неизменная и финализированная в Java?](#Для-чего-сделано-что-строка-неизменная-и-финализированная-в-Java)
+ [Почему ```char[]``` предпочтительнее ```String``` для хранения пароля?](#Почему-char-предпочтительнее-String-для-хранения-пароля)
+ [Пул строк](#Пул-строк)
+ [Чем отличаются ```String```, ```StringBuffer``` и ```StringBuilder```?](#Чем-отличаются-String-StringBuffer-и-StringBuilder)

## Класс ```String```
_String_ - это класс в Java для представления текстовых неизменяемых строк. 

Свойства ```String``` по пунктам :

+ Находится в пакете ```java.lang```
+ ```String``` является immutable (неизменяемым) и финализированным типом данных
+ Символы в строках хранятся в кодировке Unicode в неизменяемом массиве ```char[]```
+ Для экономии памяти в Heap JVM использует пул строк, работающий по шаблону Flyweight
+ Объект класса ```String``` можно получить используя двойные кавычки
+ Можно использовать оператор ```+``` для конкатенации строк
+ Начиная с Java 7 ```String``` можно использовать в конструкции ```switch```

[к оглавлению](#Строки-в-Java)

## Создание строки
Создать строку в Java можно 3мя способами :
+ Присваивание переменной класса ```String``` строковой переменной 
```java
String str1 = "1st case";
```
В данном случае если такая же строка уже есть в стринг пуле, вернется ссылка на нее, если нету - создастся новая и добавится в стринг пул.

+ Использование конструктора
```java
String str2 = new String("2nd case");
```
В этом случае всегда создается новая строка, которая помещается в heap, но не в стринг пул.

Стоит также заметить, что есть несколько разных конструкторов у класса строк :
```java
String();                                       // пустая строка
String(String original);                        // содержимое строки-параметра копируется
String(StringBuffer buffer);                    // содержимое строки buffer преобразуется в строку
String(byte[] bytes);                           // строка из массива байт с использованием кодировки по умолчанию (для русского языка в Windows - Windows-1251)
String(byte[] bytes, int offset, int length);   // строка из массива байт, начиная с индекса offset длинной в length байт
String(char[] value);                           // строка из массива value символов Unicode
String(charp[] value, int offset, int length);  // строка из массива симсолов Unicode начиная с символа offset длинной в length символов
```
+ Использование строковой переменной в выражении. По сути, способ аналогичный первому, просто без присваивания
```java
something.setValue("string" + 2);
```
В данном случае если строка ```"string"``` уже есть в стринг пуле, используется ссылка на нее, если нету - создастся новая строка и поместится в стринг пул.

[к оглавлению](#Строки-в-Java)

## Методы String

##### 1. ```charAt(int index) -> char```
Возвращает символ по указанному индексу.
##### 2. ```compareTo(Object o) -> int```
Сравнивает данную строку с другим объектом.
##### 3. ```compareTo(String anotherString) -> int```
Сравнивает две строки лексически.
##### 4. ```compareToIgnoreCase(String str) -> int```
Сравнивает две строки лексически, игнорируя регистр букв.
##### 5. ```concat(String str) -> String```
Объединяет указанную строку с данной строкой, путем добавления ее в конце.
##### 6. ```contains(String str) -> boolean```
Проверяет, содержит ли данная строка указанную подстроку.
##### 7. ```contentEquals(StringBuffer sb) -> boolean```
Возвращает значение true только в том случае, если эта строка представляет собой ту же последовательность символов как указанно в буфере строки (StringBuffer).
##### 8. ```static copyValueOf(char[] data) -> String```
Возвращает строку, которая представляет собой последовательность символов, в указанный массив.
##### 9. ```static copyValueOf(char[] data, int offset, int count) -> String```
Возвращает строку, которая представляет собой последовательность символов, в указанный массив.
##### 10. ```endsWith(String suffix) -> boolean```
Проверяет заканчивается ли эта строка указанным окончанием.
##### 11. ```equals(Object anObject) -> boolean```
Сравнивает данную строку с указанным объектом.
##### 12. ```equalsIgnoreCase(String anotherString) -> boolean```
Сравнивает данную строку с другой строкой, игнорируя регистр букв.
##### 13. ```getBytes() -> byte[]```
Кодирует эту строку в последовательность байтов с помощью платформы charset, сохраняя результат в новый массив байтов.
##### 14. ```getBytes(String charsetName) -> byte[]```
Кодирует эту строку в последовательность байтов с помощью платформы charset, сохраняя результат в новый массив байтов.
##### 15. ```getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) -> void```
Копирует символы из этой строки в массив символов назначения.
##### 16. ```hashCode() -> int```
Возвращает хэш-код для этой строки.
##### 17. ```isEmpty() -> boolean```
Проверят, равна ли длина массива символов внутри строки нулю.
##### 18. ```indexOf(int ch) -> int```
Возвращает индекс первого вхождения указанного символа в данной строке.
##### 19. ```indexOf(int ch, int fromIndex) -> int```
Возвращает индекс первого вхождения указанного символа в данной строке, начиная поиск с указанного индекса.
##### 20. ```indexOf(String str) -> int```
Возвращает индекс первого вхождения указанной подстроки в данной строке.
##### 21. ```indexOf(String str, int fromIndex) -> int```
Возвращает индекс первого вхождения указанной подстроки в данной строке, начиная с указанного индекса.
##### 22. ```intern() -> String```
Запрашивает, есть ли такая строка в стринг пуле. Если есть, возвращает ссылку на нее. Есть нет, добавляет ее в стринг пул и возвращает ссылку на нее.
##### 23. ```lastIndexOf(int ch) -> int```
Возвращает индекс последнего вхождения указанного символа в этой строке.
##### 24. ```lastIndexOf(int ch, int fromIndex) -> int```
Возвращает индекс последнего вхождения указанного символа в этой строке, начиная обратный поиск с указанного индекса.
##### 25. ```lastIndexOf(String str) -> int```
Возвращает индекс последнего вхождения указанной подстроки в данной строке.
##### 26. ```lastIndexOf(String str, int fromIndex) -> int```
Возвращает индекс последнего вхождения указанной подстроки в этой строке, начиная обратный поиск с указанного индекса.
##### 27. ```length() -> int```
Возвращает длину строки.
##### 28. ```matches(String regex) -> boolean```
Сообщает, соответствует ли или нет эта строка заданному регулярному выражению.
##### 29. ```regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) -> boolean```
Проверяет равны ли две области строки.
##### 30. ```regionMatches(int toffset, String other, int ooffset, int len) -> boolean```
Проверяет равны ли две области строки.
##### 31. ```replace(char oldChar, char newChar) -> String```
Возвращает новую строку, в результате, заменив все вхождения oldChar в этой строке на newChar.
##### 32. ```replaceAll(String regex, String replacement) -> String```
Заменяет каждую подстроку строки, соответствующей заданному регулярному выражению с данной заменой.
##### 33. ```replaceFirst(String regex, String replacement) -> String```
Заменяет перую подстроку данной строки, которая соответствует заданному регулярному выражению с данной заменой.
##### 34. ```split(String regex) -> String[]```
Разделяет эту строку по данному регулярному выражению.
##### 35. ```split(String regex, int limit) -> String[]```
Разделяет эту строку по данному регулярному выражению.
##### 36. ```startsWith(String prefix) -> boolean```
Проверяет, начинается ли эта строка с заданного префикса.
##### 37. ```startsWith(String prefix, int toffset) -> boolean```
Проверяет, начинается ли эта строка с указанного префикса, начиная с указанного индекса.
##### 38. ```subSequence(int beginIndex, int endIndex) -> CharSequence```
Возвращает новую последовательность символов, которая является подпоследовательностью этой последовательности.
##### 39. ```substring(int beginIndex) -> String```
Возвращает новую строку, которая является подстрокой данной строки.
##### 40. ```substring(int beginIndex, int endIndex) -> String```
Возвращает новую строку, которая является подстрокой данной строки.
##### 41. ```toCharArray() -> char[]```
Преобразует эту строку в новый массив символов.
##### 42. ```toLowerCase() -> String```
Преобразует все символы в данной строке в нижний регистр, используя правила данного языкового стандарта.
##### 43. ```toLowerCase(Locale locale) -> String```
Преобразует все знаки в данной строке в нижний регистр, используя правила данного языкового стандарта.
##### 44. ```toString() -> String```
Этот объект (который уже является строкой!) возвращает себя.
##### 45. ```toUpperCase() -> String```
Преобразует все символы в строке в верхний регистр, используя правила данного языкового стандарта.
##### 46. ```toUpperCase(Locale locale) -> String```
Преобразует все символы в строке в верхний регистр, используя правила данного языкового стандарта.
##### 47. ```trim() -> String```
Возвращает копию строки с пропущенными начальными и конечными пробелами.
##### 48. ```static valueOf(primitive data type x) -> String```
Возвращает строковое представление переданного типа данных аргумента.

[к оглавлению](#Строки-в-Java)

## Для чего сделано, что строка неизменная и финализированная в Java?
1. Пул строк возможен благодаря неизменяемости строк. Если бы ее не было, мы могли бы взять очередную ссылку на строку из пула, и с помощью этой ссылки изменить значение строки в пуле, что привело бы к изменению значения строки по всем ссылкам, указывающим на эту строку.
2. Так как строка неизменна, она безопасна для многопоточности и один экземпляр может использоваться разными потоками 
3. Строки используются в Classloader и ее неизменность обеспечивает правильность загрузки класса при помощи Classloader.
4. Поскольку строка неизменна, ее хешкод генерируется в момент создания и нет необходимости его пересчитывать. Это делает строку отличным вариантом ключа для HashMap, поскольку его обработка происходит быстрее.
5. Если бы строка была изменяемой, это была бы угроза безопасности приложения из-за возможности изменения, например, пароля злоумышленниками.

[к оглавлению](#Строки-в-Java)

## Почему ```char[]``` предпочтительнее ```String``` для хранения пароля?
Потому что строка, хранящаяся в стринг пуле, после удаления еще какое-то время будет находится в памяти и способа избежать этого не существует, что является потенциальной проблемой безопасности, так как злоумышленники, имеющие доступ к памяти, смогут найти пароль в виде текста.
Массив символов же мы можем очистить сразу после того, как закончим с ним работать. Таким образом мы можем контроллировать, как долго он находится в памяти и избежать проблем безопасности, свойственных строке.

[к оглавлению](#Строки-в-Java)

## Пул строк
_Пул строк_ - это набор строк, который хранится в heap.

Он возможен только благодаря неизменяемости строк в Java и реализации интернирования строк.

Является примером паттена Приспособленец (Flyweight).

_Преимуществом_ пула строк является экономия памяти кучи.

_Недостатком_ пула строк является увеличение времени, которое занимает создание строки.

[к оглавлению](#Строки-в-Java)

## Чем отличаются ```String```, ```StringBuffer``` и ```StringBuilder```?
Класс ```String``` является immutable(неизменяемым), что означает невозможность изменения объекта этого класса, только замена его другим экземпляром. Поэтому операции с изменением строки будут ресурсоемкими(каждый раз будет создаваться новая строка).

Класс ```StringBuffer``` изменяемый - использовать его следует тогда, когда необходимо часто модифицировать содержимое. Его методы синхронизированы, поэтому он как и ```String``` может быть использован в многопоточной среде.

Класс ```StringBuilder``` был добавлен в 5й версии Java и он во всем идентичен классу ```StringBuffer```, за исключением того, что его методы не синхронизированы, за счет чего он работает быстрее. Таким образом, в однопоточной среде предпочтительно использовать именно его.

Классы ```StringBuffer``` и ```StringBuilder```, в отличии от ```String```, содержат мутабельные методы. Например, ```append```, ```insert```, ```delete```.

[к оглавлению](#Строки-в-Java)
