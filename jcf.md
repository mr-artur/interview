# Java Collections Framework
+ [Что такое _«коллекция»_?](#Что-такое-коллекция)
+ [Какие преимущества коллекций?](#Какие-преимущества-коллекций)
+ [Иерархия Коллекций](#Иерархия-коллекций)
+ [`ArrayList`](#ArrayList)
+ [Когда следует использовать `ArrayList`?](#Когда-следует-использовать-ArrayList)
+ [`LinkedList`](#LinkedList)
+ [Когда следует использовать `LinkedList`?](#Когда-следует-использовать-LinkedList)
+ [`HashMap`](#HashMap)
+ [Как происходит добавление элемента в `HashMap`?](#Как-происходит-добавление-элемента-в-HashMap)
+ [Итерирование по `Map`](#Итерирование-по-Map)
+ [`LinkedHashMap`](#LinkedHashMap)
+ [Когда стоит использовать `LinkedHashMap`?](#Когда-стоит-использовать-LinkedHashMap)

[к оглавлению](#Java-Collections-Framework)

## Что такое _«коллекция»_?
_Коллекция_ - это объект, структура данных, которая служит наобором других объектов. Данными в коллекции могут быть числа, строки, пользовательские классы и т.п.

[к оглавлению](#Java-Collections-Framework)

## Какие преимущества коллекций?
1. Уменьшение затрат времени на написание кода
2. Улучшение производительности за счет использования эффективных алгоритмов под капотом коллекций
3. Универсальный способ хранения и передачи данных, что упрощает взаимодействий разных частей кода
4. Простота использования, поскольку необходимо выучить только самые основные интерфейсы и поддерживаемые операции.

[к оглавлению](#Java-Collections-Framework)

## Иерархия Коллекций
![alt text](https://i.ibb.co/zrY08Hw/Untitled-Diagram-1.png)

[к оглавлению](#Java-Collections-Framework)

## `ArrayList`
+ Внутри `ArrayList` лежит массив `Object[]`, а так же `int size`, размер коллекции, учет которого ведется вручную, поскольку он в большинстве случаев не совпадает с длинной массива.
+ Дефолтный изначальный размер массива внутри `ArrayList` равняется `10`.
+ При вставке в список, если размера данного массива недостаточно, производится копирование текущего массива в новый с помощью `Arrays.copy`, который под капотом использует нативный метод `System.arraycopy`. Размер нового массива рассчитывается по формуле `(size * 3) / 2 + 1`. Грубо говоря, размер увеличивается в полтора раза.
+ Нахождение элемента по индексу имеет худшую временную сложность __O(1)__, поскольку внутри массив и адрес элемента в нем можно рассчитать исходя из адреса массива и смещения согласно размеру элементов.
+ Нахождение элемента по значению имеет худшую временную сложность __O(N)__, поскольку придется потенциально перебрать все элементы, чтобы найти нужный.
+ Вставка элемента в начало или середину списка имеет временную сложность __O(N)__, при этом если размера массива недостаточно, еще будет произведено дополнительное его копирование в больший массив.
+ Вставка элемента в конец имеет худшую временную сложность __O(1)__.
+ При удалении элемента из `ArrayList` уменьшается `size`, но фактический размер массива остается тем же. Его можно было бы уменьшить явным вызовом `trimToSize()`.
+ Удаление последнего элемента по индексу имеет худшую сложность __O(1)__.
+ Удаление элемента по первому индексу или из середины списка имеет худшую сложность __O(N)__.
+ Удаление элемента по значению имеет худшую временную сложность __O(N)__, поскольку необходимо перебором найти элемент и если он последний, то обнулить его и уменьшить размер массива, если нет, то еще и копировать часть массива которая была правее удаленного значения.
+ `ArrayList` не является синхронизированным
+ Позволяет хранить любые значения, в том числе и `null`

[к оглавлению](#Java-Collections-Framework)

## Когда следует использовать `ArrayList`?
1. Когда нам не нужна уникальность элементов списка.
2. Когда нам не нужно учитывать работу с многопоточностью.
3. Когда нас устраивает, что в коллекции могут храниться null-значения.
4. Когда нам нужна упорядоченная коллекция

[к оглавлению](#Java-Collections-Framework)

## `LinkedList`
+ Внутри `LinkedList` работает с объектами вложенного статического класса `Node`. Они содержат в себе поля `E item`, `Node<E> prev` и `Node<E> next`. То есть, каждый элемент коллекции будет содержать данные и ссылки на предыдущий и следующий элемент. Также внутри `LinkedList` хранятся две ссылки - `Node<E> first` и `Node<E> last` - на первый и последний элемент соответственно.
+ Нахождение элемента по индексу или по значению имеет худшую временную сложность __O(N)__.
+ Нахождение первого или последнего элемента имеет худшую временную сложность __O(1)__.
+ Вставка элемента в середину по индексу имеет худшую временную сложность __O(N)__.
+ Вставка элемента в середину по индексу с использованием `ListIterator` имеет худшую временную сложность __O(1)__, не учитывая худшей временной сложности __O(N)__ для поиска ссылки при создании `ListIterator`.
+ Вставка элемента в начало или конец имеет худшую временную сложность __O(1)__.
+ Удаление последнего или первого элемента имеет худшую временную сложность __O(1)__.
+ Удаление элемента из середины по индексу имеет худшую временную сложность, аналогичную вставке - __O(N)__ или с помощью `ListIterator` - __O(1)__.
+ Удаление элемента по значению имеет худшую временную сложность __O(N)__.
+ Из `LinkedList` можно организовывать стек или очередь со временем доступа __O(1)__.
+ `LinkedList` не является синхронизированным
+ Позволяет хранить любые значения, в том числе и `null`

[к оглавлению](#Java-Collections-Framework)

## Когда следует использовать `LinkedList`?
1. В теории, когда нужно часто вставлять элементы в начало списка и вставлять/удалять элементы в/из середины, но есть популярное мнение, что это все равно не выгоднее ни по времени, ни по расходу памяти, чем `ArrayList`.

[к оглавлению](#Java-Collections-Framework)

## `HashMap`
+ Внутри `HashMap` работает с объектами вложенного статического класса `Node`. Они содержат 4 поля : `final int hash`, `final K key`, `V value`, `Node<K,V> next`. 
+ Сам объект хеш-таблицы содержит :
    + коеффициент загрузки `loadFactor`
    + таблицу для хранения нод `Node<K,V>[] table`
    + множество входящих значений для кеширования `Set<Map<Entry<K,V>> entrySet` (для `keySet()` и `values()` используются поля `AbstractMap`)
    + количество элементов таблицы `size`
    + порог размера, при достижении которого хеш-таблица будет увеличена вдвое `int threshold`
    + количество структурных модификаций таблицы `int modCount` (используется для _fail-fast_ итерирования по хеш-таблице)
+ Также есть важное статическое поле `TREEIFY_THRESHOLD = 8`, которое содержит число элементов в корзине, при достижении которого корзина будет перестроена из `LinkedList` в сбалансированное дерево, построенное на `TreeNode` (вложенном в `HashMap` классе). Это позволит сократить худшее время поиска элемента с __O(N)__ до __O(log(N))__. Это было введено в Java 8.
+ Дефолтный размер массива внутри хеш-таблицы равняется `16`.
+ Ключи и значения могут быть null, при этом ключ null в таблице может быть всего один. Он будет храниться в первой ячейке.
+ В конструкторы можно передать свои коэффициент загрузки и начальный размер таблицы (внутреннего массива)
+ Максимальный размер хеш-таблицы - `1073741824`(половина максимального значения `int`).
+ `HashMap` использует _метод цепочек_ для разрешения коллизий.
+ Добавление элемента в `HashMap` имеет худшую временную сложность __O(1)__, так как новые элементы всегда вставляются в начало цепочки
+ Операции получения и удаления элемента могут выполняться как за время __O(1)__, если хеш-функция равномерно распределяет элементы и отсутствуют коллизии, так и за время __O(N)__, если все элементы находятся в одной цепочке. (Начиная с Java 8 худшее время уже составляет __O(log(N))__ благодаря оптимизации со сбалансированным деревом).
+ Ключи и значения могут быть любых типов. Для хранения примитивных типов используются классы-обертки.
+ `HashMap` не является синхронизированным.

[к оглавлению](#Java-Collections-Framework)

## Как происходит добавление элемента в `HashMap`?
1. Генерируется `hash` на основе переданного ключа. Для этого берется `key.hashcode()`, и происходит дополнительное хеширование его с самим с собой с дополнительными сдвигами. `(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)`.
2. Происходит проверка, создан ли массив внутри хеш-мапы. Если нет, или же его размер равен `0`, он создается / увеличивается.
3. Вычисляется номер корзины, в которую необходимо положить элемент, с помощью логического И между вычисленным `hash` и максимальным индексом в массиве корзин. `tab[i = (n - 1) & hash]`.
4. Если в найденной корзине (ячейке массива) пусто, создается новый `Node` и помещается в нее.
5. Если в корзине уже были элементы, происходит перебор элементов в данной корзине в попытках найти `Node` с эквивалентным ключом с помощью метода `equals`.
6. Если `Node` с эквивалентным ключем найден, то его значение `value` заменяется на переданное в параметры метода.
7. Если ключ не найден, создается новый `Node`, ему присвается ссылка `next` на бывший первый элемент в этой корзине, после чего этот созданный элемент помещается в ячейку массива `[] table`, которая принадлежит данной корзине. Таким образом, он становится в начало списка этой корзины. При этом, если элементов в корзине уже слишком много, она перестраивается в сбалансированное дерево. Если корзина уже таковой является, то новый элемент в нее добавляется как объект `TreeNode`.

[к оглавлению](#Java-Collections-Framework)

## Итерирование по `Map`
Для получения коллекции для итерации из `Map` можно использовать три метода :
##### 1. `map.entrySet() -> Set<Map.Entry<K, V>>`
Возвращает `Set` со всеми `Entry` из мапы, в каждом из которых находится как ключ, так и значение.
##### 2.  `map.keySet() -> Set<K>`
Возвращает `Set` со всеми ключами из `Map`.
##### 3. `map.values() -> Collection<V>`
Возвращает `Collection` со всеми значениями из `Map`.

Итерироваться по каждой из коллекций полученных с помощью методов указанных выше можно с помощью 3-х способов :
##### 1. Итератор
```java
Iterator<Entry<Integer, String>> iter = map.entrySet().iterator();
while (iter.hasNext()) {
    Entry<Integer, String> entry = iter.next();
    System.out.println(entry.getKey() + " = " + entry.getValue());
}
```
##### 2. Цикл foreach
```java
for (Map.Entry<String, String> entry: map.entrySet()) {
    System.out.println(entry.getKey() + " = " + entry.getValue());
}
```
##### 2. Stream API
```java
map.entrySet().stream().forEach(System.out::println);
map.entrySet().forEach(System.out::println);
```

[к оглавлению](#Java-Collections-Framework)

## `LinkedHashMap`
+ `LinkedHashMap` является симбиозом `HashMap` и `LinkedList`. Сам класс наследуется от `HashMap` и имплементирует интерфейс `Map`.
+ Внутри `LinkedHashMap` работает с объектами типа `Entry`, который наследуется от `HashMap.Node`. То есть `Entry` также содержит поля `hash`, `key`, `value`, `next`, но при этом в него еще добавились поля `Entry<K,V> before` и `Entry<K,V> after`, в которые будут устанавливаться ссылки на предыдущий и следующий добавленный элемент или тот, к которому осуществлялся доступ до или перед данным элементом(в зависимости от конфигурации).
+ Объект `LinkedHashMap` содержит те же свойства что и объект `HashMap` - т.е., `table`, `loadFactor`, `threshold`, `size`, `entrySet` и т.п., но к ним добавились еще 3 новых поля :
    + `head` - ссылка на самый старый элемент (голову списка) в `LinkedHashMap`
    + `tail` - ссылка на самый новый элемент (хвост списка) в `LinkedHashMap`
    + `accessOrder` - `boolean`, позволяет конфигурировать порядок элементов в общей цепочке самой мапы и в коллекциях полученных с помощью `values()`, `keySet()`, `entrySet()`. Если он установлен в `false` (по дефолту), то будет сохраняться порядок добавления элементов. Если `true`, будет соблюдаться "порядок последнего доступа", т.е., после каждой get- и update-операции (то есть, после `put()` и `get()`) будет происходить переприсваивание `before` и `after` полей у обновленного `Entry` и по итогу он будет перемещаться в конец списка.
+ При вызове метода `put` вызывается реализация из `HashMap`, в конце которой вызываются методы `afterNodeAccess()` и `afterNodeInsertion()`, которые переопределены в `LinkedHashMap`. В переопределенных методах происходит присвоение `after`, `before`.
+ Незначительно может уступать `HashMap` по производительности. Надо чуть больше места в памяти ля хранения элементов и их связей.
+ Время выполнения операций `add()`, `contains()`, `remove()` остается константой __O(1)__, как и в `HashMap`.  
+ По-другому (не как в `HashMap`) реализован метод `containsValue()`, который работает с помощью итерации начиная с `head` по ссылкам `after`.
+ Не синхронизирован
+ `LinkedHashMap` возвращается из метода `readValue("some_string", Map.class)` класса `ObjectMapper` из `jackson`. 

[к оглавлению](#Java-Collections-Framework)

## Когда стоит использовать `LinkedHashMap`?
+ Когда нам необходимо сохранять порядок добавления или последнего доступа к элементам в мапе.

[к оглавлению](#Java-Collections-Framework)
