# Java Collections Framework
+ [Что такое _«коллекция»_?](#Что-такое-коллекция)
+ [Какие преимущества коллекций?](#Какие-преимущества-коллекций)
+ [Иерархия Коллекций](#Иерархия-коллекций)
+ [`ArrayList`](#ArrayList)
+ [Когда следует использовать `ArrayList`?](#Когда-следует-использовать-ArrayList)
+ [`LinkedList`](#LinkedList)
+ [Когда следует использовать `LinkedList`?](#Когда-следует-использовать-LinkedList)
+ [`HashMap`](#HashMap)
+ [Как происходит добавление элемента в `HashMap`?](#Как-происходит-добавление-элемента-в-HashMap)
+ [Итерирование по `Map`](#Итерирование-по-Map)
+ [`LinkedHashMap`](#LinkedHashMap)
+ [Когда стоит использовать `LinkedHashMap`?](#Когда-стоит-использовать-LinkedHashMap)
+ [`Hashtable`](#Hashtable)
+ [`TreeMap`](#TreeMap)
+ [`HashSet`](#HashSet)
+ [Когда стоит использовать `HashSet`?](#Когда-стоит-использовать-HashSet)
+ [`LinkedHashSet`](#LinkedHashSet)
+ [Когда стоит использовать `LinkedHashSet`?](#Когда-стоит-использовать-LinkedHashSet)
+ [`TreeSet`](#TreeSet)
+ [Когда стоит использовать `TreeSet`?](#Когда-стоит-использовать-TreeSet)
+ [`EnumSet`](#EnumSet)
+ [Когда стоит использовать `EnumSet`?](#Когда-стоит-использовать-EnumSet)
+ [`Queue`](#Queue)
+ [`Deque`](#Deque)
+ [`ArrayDeque`](#ArrayDeque)
+ [`PriorityQueue`](#PriorityQueue)
+ [`Vector`](#Vector)
+ [`Stack`](#Stack)
+ [`Iterator`](#Iterator)
+ [`ListIterator`](#ListIterator)
+ [`Spliterator`](#Spliterator)

[к оглавлению](#Java-Collections-Framework)

## Что такое _«коллекция»_?
_Коллекция_ - это объект, структура данных, которая служит наобором других объектов. Данными в коллекции могут быть числа, строки, пользовательские классы и т.п.

[к оглавлению](#Java-Collections-Framework)

## Какие преимущества коллекций?
1. Уменьшение затрат времени на написание кода
2. Улучшение производительности за счет использования эффективных алгоритмов под капотом коллекций
3. Универсальный способ хранения и передачи данных, что упрощает взаимодействий разных частей кода
4. Простота использования, поскольку необходимо выучить только самые основные интерфейсы и поддерживаемые операции.

[к оглавлению](#Java-Collections-Framework)

## Иерархия Коллекций
![alt text](https://i.ibb.co/zrY08Hw/Untitled-Diagram-1.png)

[к оглавлению](#Java-Collections-Framework)

## `ArrayList`
+ Внутри `ArrayList` лежит массив `Object[]`, а так же `int size`, размер коллекции, учет которого ведется вручную, поскольку он в большинстве случаев не совпадает с длинной массива.
+ Дефолтный изначальный размер массива внутри `ArrayList` равняется `10`.
+ При вставке в список, если размера данного массива недостаточно, производится копирование текущего массива в новый с помощью `Arrays.copy`, который под капотом использует нативный метод `System.arraycopy`. Размер нового массива рассчитывается по формуле `(size * 3) / 2 + 1`. Грубо говоря, размер увеличивается в полтора раза.
+ Нахождение элемента по индексу имеет худшую временную сложность __O(1)__, поскольку внутри массив и адрес элемента в нем можно рассчитать исходя из адреса массива и смещения согласно размеру элементов.
+ Нахождение элемента по значению имеет худшую временную сложность __O(N)__, поскольку придется потенциально перебрать все элементы, чтобы найти нужный.
+ Вставка элемента в начало или середину списка имеет временную сложность __O(N)__, при этом если размера массива недостаточно, еще будет произведено дополнительное его копирование в больший массив.
+ Вставка элемента в конец имеет худшую временную сложность __O(1)__.
+ При удалении элемента из `ArrayList` уменьшается `size`, но фактический размер массива остается тем же. Его можно было бы уменьшить явным вызовом `trimToSize()`.
+ Удаление последнего элемента по индексу имеет худшую сложность __O(1)__.
+ Удаление элемента по первому индексу или из середины списка имеет худшую сложность __O(N)__.
+ Удаление элемента по значению имеет худшую временную сложность __O(N)__, поскольку необходимо перебором найти элемент и если он последний, то обнулить его и уменьшить размер массива, если нет, то еще и копировать часть массива которая была правее удаленного значения.
+ `ArrayList` не является синхронизированным
+ Позволяет хранить любые значения, в том числе и `null`

[к оглавлению](#Java-Collections-Framework)

## Когда следует использовать `ArrayList`?
1. Когда нам не нужна уникальность элементов списка.
2. Когда нам не нужно учитывать работу с многопоточностью.
3. Когда нас устраивает, что в коллекции могут храниться null-значения.
4. Когда нам нужна упорядоченная коллекция

[к оглавлению](#Java-Collections-Framework)

## `LinkedList`
+ Внутри `LinkedList` работает с объектами вложенного статического класса `Node`. Они содержат в себе поля `E item`, `Node<E> prev` и `Node<E> next`. То есть, каждый элемент коллекции будет содержать данные и ссылки на предыдущий и следующий элемент. Также внутри `LinkedList` хранятся две ссылки - `Node<E> first` и `Node<E> last` - на первый и последний элемент соответственно.
+ Нахождение элемента по индексу или по значению имеет худшую временную сложность __O(N)__.
+ Нахождение первого или последнего элемента имеет худшую временную сложность __O(1)__.
+ Вставка элемента в середину по индексу имеет худшую временную сложность __O(N)__.
+ Вставка элемента в середину по индексу с использованием `ListIterator` имеет худшую временную сложность __O(1)__, не учитывая худшей временной сложности __O(N)__ для поиска ссылки при создании `ListIterator`.
+ Вставка элемента в начало или конец имеет худшую временную сложность __O(1)__.
+ Удаление последнего или первого элемента имеет худшую временную сложность __O(1)__.
+ Удаление элемента из середины по индексу имеет худшую временную сложность, аналогичную вставке - __O(N)__ или с помощью `ListIterator` - __O(1)__.
+ Удаление элемента по значению имеет худшую временную сложность __O(N)__.
+ Из `LinkedList` можно организовывать стек или очередь со временем доступа __O(1)__.
+ `LinkedList` не является синхронизированным
+ Позволяет хранить любые значения, в том числе и `null`

[к оглавлению](#Java-Collections-Framework)

## Когда следует использовать `LinkedList`?
1. В теории, когда нужно часто вставлять элементы в начало списка и вставлять/удалять элементы в/из середины, но есть популярное мнение, что это все равно не выгоднее ни по времени, ни по расходу памяти, чем `ArrayList`.

[к оглавлению](#Java-Collections-Framework)

## `HashMap`
+ Внутри `HashMap` работает с объектами вложенного статического класса `Node`. Они содержат 4 поля : `final int hash`, `final K key`, `V value`, `Node<K,V> next`. 
+ Сам объект хеш-таблицы содержит :
    + коеффициент загрузки `loadFactor`
    + таблицу для хранения нод `Node<K,V>[] table`
    + множество входящих значений для кеширования `Set<Map<Entry<K,V>> entrySet` (для `keySet()` и `values()` используются поля `AbstractMap`)
    + количество элементов таблицы `size`
    + порог размера, при достижении которого хеш-таблица будет увеличена вдвое `int threshold`
    + количество структурных модификаций таблицы `int modCount` (используется для _fail-fast_ итерирования по хеш-таблице)
+ Также есть важные статические поля `TREEIFY_THRESHOLD = 8` и `UNTREEIFY_THRESHOLD = 6`, первое из которых содержит число элементов в корзине, при достижении которого корзина будет перестроена из `LinkedList` в сбалансированное дерево, построенное на `TreeNode` (вложенном в `HashMap` классе). Это позволит сократить худшее время поиска элемента с __O(N)__ до __O(log(N))__. Второе поле содержит число элементов в сбалансированном дереве, при котором оно обратно перестраивается в список. Оптимизация со сбалансированным деревом была введена в Java 8.
+ Дефолтный размер массива внутри хеш-таблицы равняется `16`.
+ Ключи и значения могут быть null, при этом ключ null в таблице может быть всего один. Он будет храниться в первой ячейке.
+ В конструкторы можно передать свои коэффициент загрузки и начальный размер таблицы (внутреннего массива)
+ Максимальный размер хеш-таблицы - `1073741824`(половина максимального значения `int`).
+ `HashMap` использует _метод цепочек_ для разрешения коллизий.
+ Добавление элемента в `HashMap` имеет худшую временную сложность __O(1)__, так как новые элементы всегда вставляются в начало цепочки
+ Операции получения и удаления элемента могут выполняться как за время __O(1)__, если хеш-функция равномерно распределяет элементы и отсутствуют коллизии, так и за время __O(N)__, если все элементы находятся в одной цепочке. (Начиная с Java 8 худшее время уже составляет __O(log(N))__ благодаря оптимизации со сбалансированным деревом).
+ Ключи и значения могут быть любых типов. Для хранения примитивных типов используются классы-обертки.
+ `HashMap` не является синхронизированным.

[к оглавлению](#Java-Collections-Framework)

## Как происходит добавление элемента в `HashMap`?
1. Генерируется `hash` на основе переданного ключа. Для этого берется `key.hashcode()`, и происходит дополнительное хеширование его с самим с собой с дополнительными сдвигами. `(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)`.
2. Происходит проверка, создан ли массив внутри хеш-мапы. Если нет, или же его размер равен `0`, он создается / увеличивается.
3. Вычисляется номер корзины, в которую необходимо положить элемент, с помощью логического И между вычисленным `hash` и максимальным индексом в массиве корзин. `tab[i = (n - 1) & hash]`.
4. Если в найденной корзине (ячейке массива) пусто, создается новый `Node` и помещается в нее.
5. Если в корзине уже были элементы, происходит перебор элементов в данной корзине в попытках найти `Node` с эквивалентным ключом с помощью метода `equals`.
6. Если `Node` с эквивалентным ключем найден, то его значение `value` заменяется на переданное в параметры метода.
7. Если ключ не найден, создается новый `Node`, ему присвается ссылка `next` на бывший первый элемент в этой корзине, после чего этот созданный элемент помещается в ячейку массива `[] table`, которая принадлежит данной корзине. Таким образом, он становится в начало списка этой корзины. При этом, если элементов в корзине уже слишком много, она перестраивается в сбалансированное дерево. Если корзина уже таковой является, то новый элемент в нее добавляется как объект `TreeNode`.

[к оглавлению](#Java-Collections-Framework)

## Итерирование по `Map`
Для получения коллекции для итерации из `Map` можно использовать три метода :
##### 1. `map.entrySet() -> Set<Map.Entry<K, V>>`
Возвращает `Set` со всеми `Entry` из мапы, в каждом из которых находится как ключ, так и значение.
##### 2.  `map.keySet() -> Set<K>`
Возвращает `Set` со всеми ключами из `Map`.
##### 3. `map.values() -> Collection<V>`
Возвращает `Collection` со всеми значениями из `Map`.

Итерироваться по каждой из коллекций полученных с помощью методов указанных выше можно с помощью 3-х способов :
##### 1. Итератор
```java
Iterator<Entry<Integer, String>> iter = map.entrySet().iterator();
while (iter.hasNext()) {
    Entry<Integer, String> entry = iter.next();
    System.out.println(entry.getKey() + " = " + entry.getValue());
}
```
##### 2. Цикл foreach
```java
for (Map.Entry<String, String> entry: map.entrySet()) {
    System.out.println(entry.getKey() + " = " + entry.getValue());
}
```
##### 2. Stream API
```java
map.entrySet().stream().forEach(System.out::println);
map.entrySet().forEach(System.out::println);
```

[к оглавлению](#Java-Collections-Framework)

## `LinkedHashMap`
+ `LinkedHashMap` является симбиозом `HashMap` и `LinkedList`. Сам класс наследуется от `HashMap` и имплементирует интерфейс `Map`.
+ Внутри `LinkedHashMap` работает с объектами типа `Entry`, который наследуется от `HashMap.Node`. То есть `Entry` также содержит поля `hash`, `key`, `value`, `next`, но при этом в него еще добавились поля `Entry<K,V> before` и `Entry<K,V> after`, в которые будут устанавливаться ссылки на предыдущий и следующий добавленный элемент или тот, к которому осуществлялся доступ до или перед данным элементом(в зависимости от конфигурации).
+ Объект `LinkedHashMap` содержит те же свойства что и объект `HashMap` - т.е., `table`, `loadFactor`, `threshold`, `size`, `entrySet` и т.п., но к ним добавились еще 3 новых поля :
    + `head` - ссылка на самый старый элемент (голову списка) в `LinkedHashMap`
    + `tail` - ссылка на самый новый элемент (хвост списка) в `LinkedHashMap`
    + `accessOrder` - `boolean`, позволяет конфигурировать порядок элементов в общей цепочке самой мапы и в коллекциях полученных с помощью `values()`, `keySet()`, `entrySet()`. Если он установлен в `false` (по дефолту), то будет сохраняться порядок добавления элементов. Если `true`, будет соблюдаться "порядок последнего доступа", т.е., после каждой get- и update-операции (то есть, после `put()` и `get()`) будет происходить переприсваивание `before` и `after` полей у обновленного `Entry` и по итогу он будет перемещаться в конец списка.
+ При вызове метода `put` вызывается реализация из `HashMap`, в конце которой вызываются методы `afterNodeAccess()` и `afterNodeInsertion()`, которые переопределены в `LinkedHashMap`. В переопределенных методах происходит присвоение `after`, `before`.
+ Незначительно может уступать `HashMap` по производительности. Надо чуть больше места в памяти для хранения элементов и их связей.
+ Время выполнения операций `add()`, `contains()`, `remove()` остается константой __O(1)__, как и в `HashMap`.  
+ По-другому (не как в `HashMap`) реализован метод `containsValue()`, который работает с помощью итерации начиная с `head` по ссылкам `after`.
+ Не синхронизирован
+ `LinkedHashMap` возвращается из метода `readValue("some_string", Map.class)` класса `ObjectMapper` из `jackson`. 

[к оглавлению](#Java-Collections-Framework)

## Когда стоит использовать `LinkedHashMap`?
+ Когда нам необходимо сохранять порядок добавления или последнего доступа к элементам в мапе.

[к оглавлению](#Java-Collections-Framework)

## `Hashtable`
+ Реализует интерфейс `Map`(начиная с Java 2), расширяет абстрактный класс `Dictionary`(все методы в котором абстрактные).
+ Аналог `HashMap`, внутри работает с объектами внутреннего класса `Entry`, который аналогичен одноименному в хешмапе.
+ В отличии от `HashMap`, все методы являются синхронизированными.
+ В `Hashtable` нельзя добавить `null` значения и ключи, тогда как в `HashMap` можно добавить один `null` ключ и сколько угодно значений.
+ `keys()` возвращает объект внутреннего типа-аналога итератора `Enumerator`, который имплементирует `Enumeration` и `Iterator`.
+ `values()` возвращает `Collections.synchronizedCollection()`.
+ `entrySet()` возвращает `Collections.synchronizedSet()`.
+ Работает медленнее, чем `HashMap` по 3м причинам :
    + все методы являются synchronized.
    + нету оптимизации в виде корзины-сбалансированного дерева, в корзину значения могут складываться бесконечно и таким образом худшее время получения и удаление элемента равно __O(N)__.
+ Номер корзины считается немного не так как в `HashMap`, хотя и подобным образом :
```java
int hash = key.hashCode();
int index = (hash & 0x7FFFFFFF) % tab.length;
```
+ Является _deprecated_.

[к оглавлению](#Java-Collections-Framework)

## `TreeMap`
+ Коллекция, основанная на самобалансирующемся красно-черном дереве - частном случае бинарного дерева поиска.
+ Реализует интерфейс `NavigableMap`, расширяет абстрактный класс `AbstractMap`.
+ Внутри работает с объектами вложенного класса `Entry`, в котором у каждого экземпляра есть 6 полей :
    + `K key` - ключ
    + `V value` - значение
    + `Entry<K,V> left` - левый потомок
    + `Entry<K,V> right` - правый потомок
    + `Entry<K,V> parent` - родитель
    + `boolean color = BLACK // BLACK = true` - цвет вершины в красно-черном дереве
+ Экземпляр `TreeMap` содержит главное поле `Entry<K,V> root` - корень дерева. Также есть поля `size`, `comparator` и `modCount`(для реализации _fail-fast_).
+ Не может содержать `null` ключи, но может содержать `null` значения.
+ Сортирует элементы по ключу в натуральном порядке или на основе заданного компаратора.
+ При вставке элемента, в отличии от других мап, не нужен ни `equals()`, ни `hashcode()`, поскольку все проходит через `comparator`.
+ Худшее время добавления, получения и удаления элементов равно __O(log(N))__.
+ Правила красно-черного дерева :
    + Корень - черный
    + Все листья - черные
    + Оба потомка красного узла - черные
    + Всякий простой путь от данного узла до любого его потомка-листового узла будет содержать одинаковое число черных узлов
+ Благодаря отсортированности коллекции, существуют методы :
    + `firstKey()` - получить самый маленький ключ
    + `lastKey()` - получить самый большой ключ 
    + `headMap(int n)` - получить мапу из ключей которые меньше чем `n`
    + `tailMap(int n)` - получить мапу из ключей, которые больше или равняются `n`
+ `TreeMap` не является синхронизированным

[к оглавлению](#Java-Collections-Framework)

## `HashSet`
+ Расширяет класс `AbstractSet`, реализует интерфейс `Set`.
+ Внутри содержит приватное поле `HashMap<E,Object> map` и статическую константу `Object PRESENT = new Object()`, которая будет всегда передаваться в эту мапу в качестве значения для элемента, а ключи будут теми, которые передаст пользователь.
+ Имеет несколько конструкторов, в частности, позволяет задать `loadFactor` и `initialCapacity`, а также есть отдельный `protected` конструктор для `LinkedHashSet`.
+ Может содержать только одно `null` значение за счет того, что внутри `HashMap`, в которой может быть только один ключ `null`.
+ Не может содержать одинаковые значения, за счет того, что внутри `HashMap`, с ключами которой мы работаем и в которую добавляются объекты только с ключом, который не эквивалентен по `equals()` ни одному другому ключу в ней.
+ `HashSet` не является синхронизированным.

[к оглавлению](#Java-Collections-Framework)

## Когда стоит использовать `HashSet`?
+ Когда нам нужно, чтобы в коллекции не было дубликатов
+ Когда нам не важен порядок элементов в коллекции
+ Когда нас устроит, чтобы в коллекции могло быть одно `null` значение
+ Когда нам не нужно иметь возможность доставать элементы из коллекции по одному без итератора

[к оглавлению](#Java-Collections-Framework)

## `LinkedHashSet`
+ Расширяет класс `HashSet`, реализует интерфейс `Set`.
+ Внутри, в отличии от `HashSet`, будет лежать `LinkedHashMap`.
+ Имеет 4 конструктора, можно задать `loadFactor` и `initialCapacity`.
+ Полностью аналогичные методы с `HashSet`, кроме одного - тут заоверрайжен `spliterator()`.
+ `accessOrder` будет всегда устанавливаться в `false` во внутренней `LinkedHashMap`, то есть, элементы всегда будут следовать только в порядке добавления.
+ За счет использования `LinkedHashMap` вместо `HashMap` внутри будет занимать немного больше памяти и работать немного медленнее, чем `HashSet`.
+ Может содержать только один `null` - элемент.
+ Может содержать только уникальные по `equals()` элементы.
+ `LinkedHashSet` не является синхронизированным.

[к оглавлению](#Java-Collections-Framework)

## Когда стоит использовать `LinkedHashSet`?
Те же самые условия, что и для `HashSet`, но к ним еще добавляются :
+ Когда нам нужно сохранять порядок добавления элементов в коллекцию
+ Когда нам не критично что коллекция будет занимать чуть больше места и работать чуть медленнее чем `HashSet`

[к оглавлению](#Java-Collections-Framework)

## `TreeSet`
+ Множество в виде дерева, в котором элементы хранятся в отсортированном виде по возрастанию.
+ Расширяет класс `AbstractSet`, реализует интерфейс `NavigableSet`, и, следовательно, `SortedSet` тоже(он выше по иерархии).
+ Внутри по умолчанию лежит `TreeMap`, куда мы передаем ключи, а значение у всех элементов всегда `dummy` - константное поле равное `new Object()`.
+ Через один из конструкторов можно поменять `TreeMap` внутри на любую имплементацию `NavigableSet`.
+ Из-за `TreeMap` внутри, которая не может содержать `null` ключи, `TreeSet` соответственно не может содержать `null` значения.
+ Как и `TreeMap`, имеет методы для извлечения одного или группы элементов по критерию, например :
    + `first()` / `last()` - наименьший / наибольший элемент
    + `pollFirst()` / `pollLast()` - возвращает первый / последний элемент и удаляет его из набора
    + `ceiling(E obj)` - ищет наименьший элемент, который больше или равен переданному аргументу, и возвращает его или `null` если не найден
    + `floor(E obj)` - ищет наибольший элемент, который меньше или равен переданному аргументу, и возвращает его или `null` если не найден
    + `higher(E obj)` / `lower(E obj)` - тоже самое, что и `ceiling(E obj)` и `floor(E obj)`, только тут строго больше или меньше, без равно
    + `descendingSet()` - возвращает `NavigableSet`, который содержит все элементы множества в обратном порядке
    + `headSet(E upperBound, boolean incl)` - возвращает `NavigableSet`, который содержит элементы множества, которые меньше чем `upperBound`, в зависимости от `incl` туда добавится переданный элемент или нет
    + `tailSet(E lowerBound, boolean incl)` - возвращает `NavigableSet`, который содержит элементы множества, которые больше чем `lowerBound`, в зависимости от `incl` туда добавится или нет переданный элемент
    + `subSet(E lowerBound, boolean lowerIncl, E upperBound, boolean highIncl)` - возвращает `NavigableSet`, который содержит все элементы множества от `lowerBound` до `highBound`
    + и т.д.
+ `TreeSet` не является синхронизированным.

[к оглавлению](#Java-Collections-Framework)

## Когда стоит использовать `TreeSet`?
+ Когда нам нужно чтобы наше множество было отсортированным в натуральном или кастомном порядке
+ Когда нам нужно часто получать какую-то часть значений из множества или одно значение по какому-то критерию
+ Когда нам нужно, чтобы худшее время добавления и удаления элементов было как можно меньше

[к оглавлению](#Java-Collections-Framework)

## `EnumSet`
+ Специальное множество для работы с `enum` классами.
+ Может содержать ТОЛЬКО `enum` значения.
+ Расширяет класс `AbstractSet`, реализует интерфейс `Set`.
+ Абстрактный класс. Имеет два _package-private_ класса-наследника - `RegularEnumSet` и `JumboEnumSet`. Они создаются с помощью статических фабричных методов. Тип коллекции выбирается в зависимости от количества элементов в `enum` :
```java
if (universe.length <= 64)
    return new RegularEnumSet<>(elementType, universe);
else
    return new JumboEnumSet<>(elementType, universe);
```
+ `RegularEnumSet` и `JumboEnumSet` работают с битовыми векторами :
    + Внутри `RegularEnumSet` лежит одно число типа `long`, которое используется как битовый вектор и каждый бит в котором указывает на то, присутствует ли элемент с данным порядковым номером из енама в данной коллекции. Поэтому `RegularEnumSet` ограничивается `64` значениями. 
    + Внутри `JumboEnumSet` лежит массив с числами типа `long`, который используется целиком как битовый вектор. Это позволяет этой реализации хранить больше `64` элементов. 
+ `JumboEnumSet` будет уступать `RegularEnumSet` по скорости операций из-за того, что в нем тратится дополнительное время на рассчет индекса массива.
+ `EnumSet` занимает мало памяти и очень быстрый благодаря тому, что все методы в его наследниках реализованы с помощью арифметических побитовых операций. Также можно отметить что для некоторых операций необходимо проверить всего один бит, что также дает высокую скорость.
+ Не позволяет добавлять `null` значения.
+ Сохраняет тот порядок элементов, в котором они объявлены в `enum`.
+ Использует `fail-safe` итератор, который работает с копией коллекции и поэтому не выбрасывает `ConcurrentModificationException`.
+ `EnumSet` не является синхронизированным.

[к оглавлению](#Java-Collections-Framework)

## Когда стоит использовать `EnumSet`?
+ Когда нам надо хранить коллекцию из значений `enum`

[к оглавлению](#Java-Collections-Framework)

## `Queue`
+ Интерфейс `Queue` расширяет `Collection` и описывает поведение очередей, которые работают по принципу __FIFO__ (First In First Out).

![alt text](https://static.examclouds.com/collections/queue-interface.png)

+ Очереди не могут хранить `null`.
+ В интерфейсе `Queue` 6 методов :
    + `add(E obj) -> boolean` - пытается добавить `obj` в очередь. Возвращает `true`, если добавлен. Если в очереди нет места, выбрасывает `IllegalStateException`
    + `offer(E obj) -> boolean` - пытается добавить `obj` в очередь. Возвращает `true`, если добавлен, и `false`, если нет. 
    + `element() -> E` - возвращает элемент из головы очереди. Если очередь пуста, выбрасывает `NoSuchElementException`
    + `peek() -> E` - возвращает элемент из головы очереди. Если очередь пуста, возвращает `null`
    + `remove() -> E` - возвращает элемент из головы очереди и удаляет его из нее. Если очередь пуста, выбрасывает `NoSuchElementException`
    + `poll() -> E` - возвращает элемент из головы очереди и удаляет его из нее. Если очередь пуста, возвращает `null`

[к оглавлению](#Java-Collections-Framework)

## `Deque`
+ Интерфейс, который расширяет интерфейс очереди `Queue` и описывает поведение двунаправленной очереди.
+ Появился в Java 6.
+ Двунаправленная очередь может функционировать и как очередь __FIFO__, и как стек __LIFO__.
+ `Deque` содержит методы для работой с обеими сторонами очереди :
    + `addFirst(Е obj) -> void`  - добавляет obj в голову двунаправленной очереди. Если в очереди нет места, выбрасывает IllegalStateException
    + `addLast(Е obj) -> void` - добавляет obj в хвост двунаправленной очереди. Если в очереди нет места, выбрасывает IllegalStateException
    + `getFirst() -> Е` - возвращает первый элемент двунаправленной очереди. Если очередь пуста, выбрасывает NoSuchElementException
    + `getLast() -> Е` - возвращает последний элемент двунаправленной очереди. Если очередь пуста, выбрасывает NoSuchElementException
    + `offerFirst(Е obj) -> boolean` - пытается добавить obj в голову двунаправленной очереди. Возвращает true, если obj добавлен, и false в противном случае. Таким образом, этот метод возвращает false при попытке добавить obj в полную двунаправленную очередь ограниченной емкости
    + `offerLast(E obj) -> boolean` - пытается добавить obj в хвост двунаправленной очереди. Возвращает true, если obj добавлен, и false в противном случае
    + `рор() -> E` - возвращает элемент, находящийся в голове двунаправленной очереди, одновременно удаляя его из очереди. Если очередь пуста, выбрасывает NoSuchElementException
    + `push(Е obj) -> void` - добавляет элемент в голову двунаправленной очереди. Если в очереди нет места, выбрасывает IllegalStateException
    + `peekFirst() -> Е` - возвращает элемент, находящийся в голове двунаправленной очереди. Возвращает null, если очередь пуста
    + `peekLast() -> Е`- возвращает элемент, находящийся в хвосте двунаправленной очереди. Возвращает null, если очередь пуста
    + `pollFirst() -> Е`- возвращает элемент, находящийся в голове двунаправленной очереди, одновременно удаляя его из очереди. Возвращает null, если очередь пуста
    + `pollLast() -> Е` - возвращает элемент, находящийся в хвосте двунаправленной очереди, одновременно удаляя его из очереди. Возвращает null, если очередь пуста
    + `removeLast() -> Е` - возвращает элемент, находящийся в конце двунаправленной очереди, удаляя его в процессе. Если очередь пуста, выбрасывает NoSuchElementException
    + `removeFirst() -> Е` - возвращает элемент, находящийся в голове двунаправленной очереди, одновременно удаляя его из очереди. Если очередь пуста, выбрасывает NoSuchElementException
    + `removeLastOccurrence(Object obj) -> boolean` - удаляет последнее вхождение obj из двунаправленной очереди. Возвращает true в случае успеха и false если очередь не содержала obj
    + `removeFirstOccurrence(Object obj) -> boolean` - удаляет первое вхождение obj из двунаправленной очереди. Возвращает true в случае успеха и false, если очередь не содержала obj

[к оглавлению](#Java-Collections-Framework)

## `ArrayDeque`
+ Реализация двунаправленной очереди.
+ Расширяет класс `AbstractCollection`, реализует интерфейс `Deque`.
+ Внутри лежат поля :
    + `Object[] elements`, которое хранит элементы коллекции
    + `int head`, которое хранит индекс элемента в массиве, который сейчас является головой очереди. Это нужно для того, чтобы при каждом доставании элемента из головы не копировать массив
    + `int tail`, которое хранит индекс, в которой добавится следующее значение, вставляемое в хвост
    + `MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8`, статическое поле, которое указывает максимальное значение массива, при превышении которого последует `OutOfMemoryError`
+ Размер внутреннего массива `elements` по умолчанию равен `16`.
+ Есть несколько конструкторов :
    + `ArrayDeque()` - создает пустую двунаправленную очередь с начальной вместимостью `16`
    + `ArrayDeque(Collection<? extends E> c)` - создает двунаправленную очередь из элементов переданной коллекции в том порядке, в котором они возвращаются с помощью итератора переданной коллекци
    + `ArrayDeque(int numElements)` - создает пустую двунаправленную очередь с начальной вместимостью `numElements`
+ Замена массива на более большой происходит при 100-процентной заполнености и в зависимости от текущего размера прирост ячеек будет разным. Для маленького размера массив увеличивается в `2` раза, для более больших - в `1.5` раза.
+ Замена массива происходит быстро за счет использования `System.arrayCopy()`.
+ Не позволяет добавлять `null` элементы.
+ Позволяет удалять элементы из середины с помощью методов `removeFirstOccurance(Object obj)` и `removeLastOccurance(Object obj)`.
+ `ArrayDeque` появился в Java 6.
+ В документации сказано, что `ArrayDeque` работает быстрее по _LIFO_, чем `Stack` и быстрее по _FIFO_, чем `LinkedList`.
+ `ArrayDeque` не является синхронизированным.

[к оглавлению](#Java-Collections-Framework)

## `PriorityQueue`
+ Реализация односторонней неограниченной очереди с приоритетами. Также она является по умолчанию реализацией min-heap(кучи с минимальным значением сверху).
+ Расширяет класс `AbstractQueue`, который в свою очередь реализует интерфейс `Queue`.
+ Внутри лежат поля :
    + `Object[] queue`, которое хранит элементы коллекции
    + `int size`, которое хранит текущий размер коллекции
    + `Comparator<? super E> comparator`, которое хранит компаратор, согласно которому будут вставляться элементы в очередь. Если он `null`, то они будут вставляться в натуральном порядке
    + `DEFAULT_INITIAL_CAPACITY = 11`, изначальная размерность массива `queue` по умолчанию
    + `int modCount`, счетчик модификации для реализации `fail-fast` итерирования
+ Размер очереди неограничен, но мы можем задать начальный ее размер в одном из конструкторов.
+ Замена массива на более большой происходит при 100-процентной заполнености и в зависимости от текущего размера прирост ячеек будет разным. Для маленького размера массив увеличивается в `2` раза, для более больших - в `1.5` раза.
+ Замена массива происходит быстро за счет использования `System.arrayCopy()`.
+ Не позволяет добавлять `null` элементы, а также элементы, которые не реализуют интерфейс `Comparable`.
+ Позволяет удалять элементы из середины с помощью метода `remove(Object obj)`.
+ `PriorityQueue` появилась в Java 5.
+ `PriorityQueue` не является синхронизированной.

[к оглавлению](#Java-Collections-Framework)

## `Vector`
+ Реализует синхронизированный динамический массив.
+ Расширяет класс `AbstractList`, реализует интерфейс `List`.
+ Внутри лежат поля :
    + `Object[] elementData`, которое хранит элементы коллекции
    + `int elementCount`, которое хранит текущий размер коллекции
    + `int capacityIncrement`, которое хранит количество ячеек, на которое будет увеличиваться внутренний массив при каждом расширении. Если его задать как `0` или меньше, массив каждый раз будет увеличиваться в `2` раза
+ У класса `Vector` есть `4` конструктора :
    + `Vector()` - создает вектор с дефолтным размером массива в `10` элементов. Увеличиваться он будет каждый раз в `2` раза
    + `Vector(int initialCapacity)` - создает вектор с указанным размером массива. Увеличиваться он будет каждый раз в `2` раза
    + `Vector(int initialCapacity, int capacityIncrement)` - создает вектор с указанным размером массива. Увеличиваться он будет каждый раз на `capacityIncrement` ячеек
    + `Vector(Collection<? extends E> c)` - создает вектор из переданной в аргументе коллекции
+ В `Vector`, также как и в `ArrayList`, используется нативный метод `System.arraycopy`.
+ В `Vector` все методы синхронизированы, поэтому он медленнее чем `ArrayList`, но при этом потокобезопасен.
+ Замена массива на более большой происходит при 100-процентной заполнености.
+ Позволяет добавлять `null` элементы.
+ `Vector` содержит устаревшие методы, которые не являются частью структуры коллекций
+ `Vector` появился в Java 1.

[к оглавлению](#Java-Collections-Framework)

## `Stack`
+ Реализует синхронизированный стек, работающий по принципу `FIFO (First In First Out)`.
+ Расширяет класс `Vector`.
+ Добавляет свой пустой конструктор, а также 5 методов :
    + `push(E item) -> E` - добавляет элемент "на вершину стека", по сути - в конец массива
    + `pop() -> E` - получает элемент с "вершины стека" и удаляет его из стека, по сути - последний элемент массива
    + `peek() -> E` - получает последний элемент массива
    + `empty() -> boolean` - проверяет, пуст ли стек (`elementCount == 0`)
    + `search(Object o) -> int` - возвращает смещение элемента от вершины стека (`size() - i`)
+ Все методы в `Stack` синхронизированы.
+ Замена массива на более большой происходит при 100-процентной заполнености.
+ Позволяет добавлять `null` элементы.
+ `Stack` появился в Java 1.

[к оглавлению](#Java-Collections-Framework)

## `Iterator`
+ _Итератор_ - это сущность, которая позволяет нам поочередно перебирать элементы любой коллекции, используя один и тот же интерфейс, и при этом не зная ничего о внутренней структуре коллекции.
+ В интерфейсе `Iterator` есть 4 метода :
    + `hasNext() -> boolean` - проверяет, есть ли следующий элемент в коллекции.
    + `next() -> E` - возвращает следующий элемент в коллекции. Если следующего элемента в коллекции нет, выбрасывает `NoSuchElementException`.
    + `remove() -> void` - удаляет последний возвращенный элемент из коллекции. Является необязательным(например, для read-only коллекций), поэтому дефолтная реализация в интерфейсе выбрасывает `UnsupportedOperationException`. Также может выбросить `IllegalStateException`, если метод `next()` не был вызван, или после крайнего его вызова уже был вызван `remove()`.
    + `forEachRemaining(Consumer<? super E> action) -> void` - применяет переданное действие ко всем следующим элементам в коллекции. Добавлен в Java 8. Имеет дефолтную реализацию в интерфейсе.
+ Итераторы реализовуются как внутренние классы коллекций.
+ Метод для получения итератора определен в интерфейсе `Iterable`, называется `iterator()`, а интерфейс `Iterable` в свою очередь наследуется интерфейсом `Collection`.
+ Является новой версией `Enumeration` и получается из его метода `asIterator()`. В `Enumeration` есть `3` метода - аналогичные `hasMoreElements() -> boolean` и `nextElement() -> E`, а также уже упомянутый метод `asIterator() -> Iterator<E>`, и нету метода `remove`.

[к оглавлению](#Java-Collections-Framework)

## `ListIterator`
+ Специальный итератор для списков, который предоставляет больше возможностей.
+ Расширяет интерфейс `Iterator`. 
+ Позволяет обходить список в двух направлениях.
+ Позволяет добавлять новые значения и заменять существующие в списке.
+ Помимо `4`-х методов `Iterator`, добавляет `6` новых :
    + `add(E e) -> void` - добавляет элемент перед тем, что был возвращен последним.
    + `set(E e) -> void` - меняет последний возвращенный элемент на тот, что передан в аргументе.
    + `hasPrevious() -> boolean` - проверяет, есть ли предыдущий элемент в коллекции. (после вызовы `next()` предыдущим будет считаться возвращенный элемент)
    + `previous() -> E` - возвращает предыдущий элемент из коллекции.
    + `previousIndex() -> int` - возвращает индекс предыдущего элемента из коллекции.
    + `nextIndex() -> int` - возвращает индекс следующего элемента из коллекции.
+ Если вызвать подряд `next()` и `previous()`, вернется один и тот же элемент.

[к оглавлению](#Java-Collections-Framework)

## `Spliterator`
+ Сущность, которая используется для обхода и разбиения последовательностей.
+ Базовая утилита для `Streams`, в особенности для параллельных.
+ Метод, который возвращает `Spliterator`, называется одноименно  - `spliterator()` и определен в интерфейсе `Iterable`, который наследуется интерфейсом `Collection`.
+ В интерфейсе `Spliterator` `8` методов, `4` из которых дефолтные :
    + `tryAdvance(Consumer<? super T> action) -> boolean` - один из основных, совмещает в себе методы `hasNext()` и `next()` обычного итератора. Если есть следующий элемент, проводит над ни переданное действие и возвращает `true`, иначе просто возвращает `false`.
    + `trySplit() -> Spliterator<T>` - если данный `Spliterator` может быть разделен, то пытается разделить его на `2` части. При этом возвращается `Spliterator`, который будет проходить по первой части последовательности, а изначальный `Spliterator` перепрыгнет на вторую часть. В таких коллекциях, как например `ArrayList`, последовательность действительно будет поделена пополам, но, например, в `HashSet` она будет поделена пополам не по количеству всех элементов, а по ячейкам в массиве, то есть количество элементов для двух сплитераторов может выйти очень неравномерным. Для бесконечной последовательности ситуация похожа, первый сплитератор получит ограниченную последовательность, а второй бесконечную.
    + `estimateSize() -> long` - возвращает количество оставшихся элементов для `SIZED` - сплитераторов и как можно более точную оценку в других случаях. Если элементов бесконечное количество или посчитать его слишком затратно, вернет `Long.MAX_VALUE`.
    + `characteristics() -> int` - возвращает битовую маску характеристик сплитератора. Их `8`:
        + `ORDERED` — если порядок данных имеет значение. К примеру, сплитератор от `HashSet` не имеет этой характеристики, потому что порядок данных в `HashSet` зависит от реализации. Отсутствие этой характеристики автоматически переведёт параллельный поток в неупорядоченный режим, благодаря чему он сможет работать быстрее. Раз в источнике данных порядка не было, то и дальше можно за ним не следить.
        + `DISTINCT` — если элементы заведомо уникальны. Любой `Set` или поток после операции `distinct()` создаёт сплитератор с такой характеристикой. Например, операция `distinct()` на потоке из `Set` выполняться не будет вообще и, стало быть, времени лишнего не займёт.
        + `SORTED` — если элементы сортированы. В таком случае обязательно вернуть и `ORDERED` и переопределить метод `getComparator()`, вернув компаратор сортировки или `null` для «естественного порядка». Сортированные коллекции (например, `TreeSet`) создают сплитератор с такой характеристикой, и с ней потоковая операция `sorted()` может быть пропущена.
        + `SIZED` — если известно точное количество элементов сплитератора. Такую характеристику возвращают сплитераторы всех коллекций. После некоторых потоковых операций (например, `map()` или `sorted()`) она сохраняется, а после других (скажем, `filter()` или `distinct()`) — теряется. Она полезна для сортировки или, скажем, операции `toArray()`: можно заранее выделить массив нужного размера, а не гадать, сколько элементов понадобится.
        + `SUBSIZED` — если известно, что все дочерние сплитераторы также будут знать свой размер. Эту характеристику возвращает сплитератор от `ArrayList`, потому что при делении он просто разбивает диапазон значений на два диапазона известной длины. А вот `HashSet` её не вернёт, потому что он разбивает хэш-таблицу, для которой не известно, сколько содержится элементов в каждой половине. Соответственно дочерние сплитераторы уже не будут возвращать и `SIZED`.
        + `NONNULL` — если известно, что среди элементов нет `null`. Эту характеристику возвращает, например, сплитератор, созданный `ConcurrentSkipListSet`: в эту структуру данных `null` поместить нельзя. Также её возвращают все сплитераторы, созданные на примитивных типах.
        + `IMMUTABLE` — если известно, что источник данных в процессе обхода заведомо не может измениться. Сплитераторы от обычных коллекций такую характеристику не возвращают, но её выдаёт, например, сплитератор от `Collections.singletonList()`, потому что этот список изменить нельзя.
        + `CONCURRENT` — если известно, что сплитератор остаётся рабочим после любых изменений источника. Такую характеристику сообщают сплитераторы коллекций из `java.util.concurrent`. Если сплитератор не имеет характеристик `IMMUTABLE` и `CONCURRENT`, то хорошо бы заставить его работать в _fail-fast_ режиме, чтобы он кидал `ConcurrentModificationException`, если заметит, что источник изменился.
        
        Насколько известно, последние три характеристики сейчас потоками никак не используются (в том числе в коде Java 9).
    + `default forEachRemaining(Consumer<? super T> action) -> void` - выполняет для каждого следующего элемента переданное действие. В дефолтной реализации просто в `do-while` вызывается `tryAdvance()`.
    + `default getExactSizeIfKnown() -> long` - возвращает точный размер последовательности - `estimateSize()`, если свойство `SIZED == true`, или `-1L` в другом случае.
    + `default hasCharacteristics(int characteristics) -> boolean` - проверяет, есть ли у этого `Spliterator` все переданные характеристики.
    + `default getComparator() -> Comparator<? super T>` - возвращает компаратор, если источник последовательности сортирован (свойство `SIZED == true`). В дефолтной реализации бросает `IllegalStateException`.
+ `Spliterator` появился в Java 8.

[к оглавлению](#Java-Collections-Framework)
