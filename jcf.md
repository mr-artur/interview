# Java Collections Framework

## Что такое _«коллекция»_?
_Коллекция_ - это объект, структура данных, которая служит наобором других объектов. Данными в коллекции могут быть числа, строки, пользовательские классы и т.п.

## Какие преимущества коллекций?
1. Уменьшение затрат времени на написание кода
2. Улучшение производительности за счет использования эффективных алгоритмов под капотом коллекций
3. Универсальный способ хранения и передачи данных, что упрощает взаимодействий разных частей кода
4. Простота использования, поскольку необходимо выучить только самые основные интерфейсы и поддерживаемые операции.

## Иерархия Коллекций
![alt text](https://i.ibb.co/zrY08Hw/Untitled-Diagram-1.png)

## `ArrayList`
+ Внутри `ArrayList` лежит массив `Object[]`, а так же `int size`, размер коллекции, учет которого ведется вручную, поскольку он в большинстве случаев не совпадает с длинной массива.
+ Дефолтный изначальный размер массива внутри `ArrayList` равняется `10`.
+ При вставке в список, если размера данного массива недостаточно, производится копирование текущего массива в новый с помощью `Arrays.copy`, который под капотом использует нативный метод `System.arraycopy`. Размер нового массива рассчитывается по формуле `(size * 3) / 2 + 1`. Грубо говоря, размер увеличивается в полтора раза.
+ Нахождение элемента по индексу имеет худшую временную сложность __O(1)__, поскольку внутри массив и адрес элемента в нем можно рассчитать исходя из адреса массива и смещения согласно размеру элементов.
+ Нахождение элемента по значению имеет худшую временную сложность __O(N)__, поскольку придется потенциально перебрать все элементы, чтобы найти нужный.
+ Вставка элемента в начало или середину списка имеет временную сложность __O(N)__, при этом если размера массива недостаточно, еще будет произведено дополнительное его копирование в больший массив.
+ Вставка элемента в конец имеет худшую временную сложность __O(1)__.
+ При удалении элемента из `ArrayList` уменьшается `size`, но фактический размер массива остается тем же. Его можно было бы уменьшить явным вызовом `trimToSize()`.
+ Удаление последнего элемента по индексу имеет худшую сложность __O(1)__.
+ Удаление элемента по первому индексу или из середины списка имеет худшую сложность __O(N)__.
+ Удаление элемента по значению имеет худшую временную сложность __O(N)__, поскольку необходимо перебором найти элемент и если он последний, то обнулить его и уменьшить размер массива, если нет, то еще и копировать часть массива которая была правее удаленного значения.
+ `ArrayList` не является синхронизированным
+ Позволяет хранить любые значения, в том числе и `null`

## Когда следует использовать `ArrayList`?

1. Когда нам не нужна уникальность элементов списка.
2. Когда нам не нужно учитывать работу с многопоточностью.
3. Когда нас устраивает, что в коллекции могут храниться null-значения.
4. Когда нам нужна упорядоченная коллекция

## `LinkedList`
+ Внутри `LinkedList` работает с объектами вложенного статического класса `Node`. Они содержат в себе поля `E item`, `Node<E> prev` и `Node<E> next`. То есть, каждый элемент коллекции будет содержать данные и ссылки на предыдущий и следующий элемент. Также внутри `LinkedList` хранятся две ссылки - `Node<E> first` и `Node<E> last` - на первый и последний элемент соответственно.
+ Нахождение элемента по индексу или по значению имеет худшую временную сложность __O(N)__.
+ Нахождение первого или последнего элемента имеет худшую временную сложность __O(1)__.
+ Вставка элемента в середину по индексу имеет худшую временную сложность __O(N)__.
+ Вставка элемента в середину по индексу с использованием `ListIterator` имеет худшую временную сложность __O(1)__, не учитывая худшей временной сложности __O(N)__ для поиска ссылки при создании `ListIterator`.
+ Вставка элемента в начало или конец имеет худшую временную сложность __O(1)__.
+ Удаление последнего или первого элемента имеет худшую временную сложность __O(1)__.
+ Удаление элемента из середины по индексу имеет худшую временную сложность, аналогичную вставке - __O(N)__ или с помощью `ListIterator` - __O(1)__.
+ Удаление элемента по значению имеет худшую временную сложность __O(N)__.
+ Из `LinkedList` можно организовывать стек или очередь со временем доступа __O(1)__.
+ `LinkedList` не является синхронизированным
+ Позволяет хранить любые значения, в том числе и `null`

## Когда следует использовать `LinkedList`?

1. В теории, когда нужно часто вставлять элементы в начало списка и вставлять/удалять элементы в/из середины, но есть популярное мнение, что это все равно не выгоднее ни по времени, ни по расходу памяти, чем `ArrayList`.

## `HashMap`
+ Внутри `HashMap` работает с объектами вложенного статического класса `Node`. Они содержат 4 поля : `final int hash`, `final K key`, `V value`, `Node<K,V> next`. 
+ Сам объект хеш-таблицы содержит :
    + коеффициент загрузки `loadFactor`
    + таблицу для хранения нод `Node<K,V>[] table`
    + множество входящих значений для кеширования `Set<Map<Entry<K,V>> entrySet` (для `keySet()` и `values()` используются поля `AbstractMap`)
    + количество элементов таблицы `size`
    + порог размера, при достижении которого хеш-таблица будет увеличена вдвое `int threshold`
    + количество структурных модификаций таблицы `int modCount` (используется для _fail-fast_ итерирования по хеш-таблице)
+ Дефолтный размер массива внутри хеш-таблицы равняется `16`.
+ Ключи и значения могут быть null, при этом ключ null в таблице может быть всего один. Он будет храниться в первой ячейке.
+ В конструкторы можно передать свои коэффициент загрузки и начальный размер таблицы (внутреннего массива)
+ Максимальный размер хеш-таблицы - `1073741824`(половина максимального значения `int`).
+ Добавление элемента в `HashMap` имеет худшую временную сложность __O(1)__, так как новые элементы всегда вставляются в начало цепочки
+ Операции получения и удаления элемента могут выполняться как за время __O(1)__, если хеш-функция равномерно распределяет элементы и отсутствуют коллизии, так и за время __O(N)__, если все элементы находятся в одной цепочке.
+ Ключи и значения могут быть любых типов. Для хранения примитивных типов используются классы-обертки.
+ `HashMap` не является синхронизированным
