# Java Collections Framework

## Что такое _«коллекция»_?
_Коллекция_ - это объект, структура данных, которая служит наобором других объектов. Данными в коллекции могут быть числа, строки, пользовательские классы и т.п.

## Какие преимущества коллекций?
1. Уменьшение затрат времени на написание кода
2. Улучшение производительности за счет использования эффективных алгоритмов под капотом коллекций
3. Универсальный способ хранения и передачи данных, что упрощает взаимодействий разных частей кода
4. Простота использования, поскольку необходимо выучить только самые основные интерфейсы и поддерживаемые операции.

## Иерархия Коллекций
![alt text](https://i.ibb.co/zrY08Hw/Untitled-Diagram-1.png)

## `ArrayList`
+ Внутри `ArrayList` лежит массив `Object[]`, а так же `int size`, размер коллекции, учет которого ведется вручную, поскольку он в большинстве случаев не совпадает с длинной массива.
+ Дефолтный изначальный размер массива внутри `ArrayList` равняется `10`.
+ При вставке в список, если размера данного массива недостаточно, производится копирование текущего массива в новый с помощью `Arrays.copy`, который под капотом использует нативный метод `System.arraycopy`. Размер нового массива рассчитывается по формуле `(size * 3) / 2 + 1`. Грубо говоря, размер увеличивается в полтора раза.
+ Нахождение элемента по индексу имеет худшую временную сложность __O(1)__, поскольку внутри массив и адрес элемента в нем можно рассчитать исходя из адреса массива и смещения согласно размеру элементов.
+ Нахождение элемента по значению имеет худшую временную сложность __O(N)__, поскольку придется потенциально перебрать все элементы, чтобы найти нужный.
+ Вставка элемента в начало или середину списка имеет временную сложность __O(N)__, при этом если размера массива недостаточно, еще будет произведено дополнительное его копирование в больший массив.
+ Вставка элемента в конец имеет худшую временную сложность __O(1)__.
+ При удалении элемента из `ArrayList` уменьшается `size`, но фактический размер массива остается тем же. Его можно было бы уменьшить явным вызовом `trimToSize()`.
+ Удаление последнего элемента по индексу имеет худшую сложность __O(1)__.
+ Удаление элемента по первому индексу или из середины списка имеет худшую сложность __O(N)__.
+ Удаление элемента по значению имеет худшую временную сложность __O(N)__, поскольку необходимо перебором найти элемент и если он последний, то обнулить его и уменьшить размер массива, если нет, то еще и копировать часть массива которая была правее удаленного значения.
+ `ArrayList` не является синхронизированным
+ Позволяет хранить любые значения, в том числе и `null`

## Когда следует использовать `ArrayList`?

1. Когда нам не нужна уникальность элементов списка.
2. Когда нам не нужно учитывать работу с многопоточностью.
3. Когда нас устраивает, что в коллекции могут храниться null-значения.
4. Когда нам нужна упорядоченная коллекция

## `LinkedList`
+ Внутри `LinkedList` работает с объектами вложенного статического класса `Node`. Они содержат в себе поля `E item`, `Node<E> prev` и `Node<E> next`. То есть, каждый элемент коллекции будет содержать данные и ссылки на предыдущий и следующий элемент. Также внутри `LinkedList` хранятся две ссылки - `Node<E> first` и `Node<E> last` - на первый и последний элемент соответственно.
+ Нахождение элемента по индексу или по значению имеет худшую временную сложность __O(N)__.
+ Нахождение первого или последнего элемента имеет худшую временную сложность __O(1)__.
+ Вставка элемента в середину по индексу имеет худшую временную сложность __O(N)__.
+ Вставка элемента в середину по индексу с использованием `ListIterator` имеет худшую временную сложность __O(1)__, не учитывая худшей временной сложности __O(N)__ для поиска ссылки при создании `ListIterator`.
+ Вставка элемента в начало или конец имеет худшую временную сложность __O(1)__.
+ Удаление последнего или первого элемента имеет худшую временную сложность __O(1)__.
+ Удаление элемента из середины по индексу имеет худшую временную сложность, аналогичную вставке - __O(N)__ или с помощью `ListIterator` - __O(1)__.
+ Удаление элемента по значению имеет худшую временную сложность __O(N)__.
+ Из `LinkedList` можно организовывать стек или очередь со временем доступа __O(1)__.
+ `LinkedList` не является синхронизированным
+ Позволяет хранить любые значения, в том числе и `null`

## Когда следует использовать `LinkedList`?

1. В теории, когда нужно часто вставлять элементы в начало списка и вставлять/удалять элементы в/из середины, но есть популярное мнение, что это все равно не выгоднее ни по времени, ни по расходу памяти, чем `ArrayList`.
