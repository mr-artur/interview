# Алгоритмы
+ [Пузырьковая сортировка (_Bubble sorting)_](#Пузырьковая-сортировка-Bubble-sorting)
    + [Анимация пузырьковой сортировки](#Анимация-пузырьковой-сортировки)
    + [Реализация пузырьковой сортировки на Java](#Реализация-пузырьковой-сортировки-на-Java)
+ [Сортировка выбором (_Sorting by selection_)](#Сортировка-выбором-Sorting-by-selection)
    + [Анимация сортировки выбором](#Анимация-сортировки-выбором)
    + [Алгоритм сортировки выбором](#Алгоритм-сортировки-выбором)
    + [Реализация сортировки выбором на Java](#Реализация-сортировки-выбором-на-Java)
+ [Сортировка вставками (_Insertion sorting_)](#Сортировка-вставками-Insertion-sorting)
    + [Анимация сортировки вставками](#Анимация-сортировки-вставками)
    + [Реализация сортировки вставками на Java](#Реализация-сортировки-вставками-на-Java)
+ [Сортировка слиянием (_Merge Sorting_)](#Сортировка-слиянием-Merge-Sorting)
    + [Анимация сортировки слиянием](#Анимация-сортировки-слиянием)
    + [Анимация сортировки слиянием с нечетным количеством элементов](#Анимация-сортировки-слиянием-с-нечетным-количеством-элементов)
    + [Алгоритм сортировки слиянием](#Алгоритм-сортировки-слиянием)
    + [Реализация сортировки слиянием на Java](#Реализация-сортировки-слиянием-на-Java)
    + [Преимущества сортировки слиянием](#Преимущества-сортировки-слиянием)
    + [Недостатки сортировки слиянием](Недостатки-сортировки-слиянием)
+ [Быстрая сортировка (_Quick sorting_)](#Быстрая-сортировка-Quick-sorting)
    + [Анимация итерации быстрой сортировки](#Анимация-итерации-быстрой-сортировки)
    + [Алгоритм быстрой сортировки](#Алгоритм-быстрой-сортировки)
    + [Реализация быстрой сортировки на Java](#Реализация-быстрой-сортировки-на-Java)
    + [Преимущества быстрой сортировки](#Преимущества-быстрой-сортировки)
    + [Недостатки быстрой сортировки](#Недостатки-быстрой-сортировки)
    
## Пузырьковая сортировка (_Bubble sorting_)

__Худшее время__: _O(n²)_

Смысл пузырьковой сортировки состоит в том, что ты просто проходим `n-1` раз по массиву и сравниваем каждый элемент, начиная со второго, с предыдущим. Если они стоят неправильно относительно друга, мы меняем их местами.

[к оглавлению](#Алгоритмы)

#### Анимация пузырьковой сортировки :

![alt text](https://thumbs.gfycat.com/ExaltedInconsequentialDwarfrabbit-size_restricted.gif)

[к оглавлению](#Алгоритмы)

#### Реализация пузырьковой сортировки на Java :
```java
for (int i = 0; i < a.length - 1; i++) {
    for (int j = 0; j < a.length - i - 1; j++) {
        if (a[j] > a[j + 1]) {
            int temp = a[j];
            a[j] = a[j + 1];
            a[j + 1] = temp;
        }
    }
}
```

[к оглавлению](#Алгоритмы)

## Сортировка выбором (_Sorting by selection_)

__Худшее время__: _O(n²)_

Смысл сортировки выбором состоит в том, что на каждой его итерации мы ищем наименьший элемент в нашем массиве и вставляем его в первую ячейку массива, после чего уменьшаем массив для следующей итерации на `1`, на ту самую первую ячейку.

[к оглавлению](#Алгоритмы)

#### Анимация сортировки выбором :

![alt text](https://www.codingconnect.net/wp-content/uploads/2016/09/Selection-Sort.gif)

[к оглавлению](#Алгоритмы)

#### Алгоритм сортировки выбором :
1. Находим номер минимального значения в текущем списке;
2. Производим обмен этого значения со значением первой не отсортированной позиции (обмен не нужен, если минимальный элемент уже находится на данной позиции);
3. Теперь сортируем хвост списка, исключив из рассмотрения уже отсортированные элементы.

[к оглавлению](#Алгоритмы)

#### Реализация сортировки выбором на Java :
```java
for(int i = 0;i<arr.length;i++) {
    /*
     * Предполагаем, что первый элемент (в каждом подмножестве элементов) ==
     * является минимальным
     */
    int min = arr[i];
    int min_i = i;
    /*
     * В оставшейся части подмножества ищем элемент, который меньше
     * предположенного минимума
     */
    for (int j = i + 1; j < arr.length; j++) {
    // Если находим, запоминаем его индекс
        if (arr[j] < min) {
            min = arr[j];
            min_i = j;
        }
    }
    /*
     * Если нашелся элемент, меньший, чем на текущей позиции, меняем их
     * местами
     */
    if (i != min_i) {
        int tmp = arr[i];
        arr[i] = arr[min_i];
        arr[min_i] = tmp;
    }
}
```

[к оглавлению](#Алгоритмы)

## Сортировка вставками (_Insertion sorting_)

__Худшее время__: _O(n²)_

Смысл сортировки вставками состоит в том, что мы на каждом шаге добавляем один элемент из исходного массива в результирующий таким образом, чтобы результирующий массив при этом всегда был отсортирован. То есть, каждый новый элемент добавляется в результирующий массив на такое место, чтобы справа от него были элементы больше или равны ему, а слева меньше или равны ему (в случае сортировки по возрастанию).

Метод выбора очередного элемента из исходного массива произволен; может использоваться практически любой алгоритм выбора. Обычно (и с целью получения устойчивого алгоритма сортировки), элементы вставляются по порядку их появления во входном массиве.

[к оглавлению](#Алгоритмы)

#### Анимация сортировки вставками :

![alt text](https://www.globalsoftwaresupport.com/wp-content/uploads/2017/02/ezgif.com-video-to-gif-13-1.gif)

[к оглавлению](#Алгоритмы)

#### Реализация сортировки вставками на Java :
```java
int key;
for (int i = 1; i < array.length; i++) {
    key = array[i];
    int j = i - 1;
    while (j >= 0 && array[j] > key) {
        array[j + 1] = array[j];
        j = j - 1;
    }
    array[j + 1] = key;
}
```

[к оглавлению](#Алгоритмы)

## Сортировка слиянием (_Merge Sorting_)

__Худшее время__: _O(n log n)_

Сортировка слиянием является рекурсивным алгоритмом, работающим по принципу "разделяй и властвуй". Суть данного алгоритма в том, что исходный массив на каждой рекурсивной итерации делится пополам и так пока размерность массива не достигнет `1`. Потом эти маленькие массивы начинают склеиваться обратно в отсортированные. 

[к оглавлению](#Алгоритмы)

#### Анимация сортировки слиянием :

![alt text](https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif)

[к оглавлению](#Алгоритмы)

#### Анимация сортировки слиянием с нечетным количеством элементов :

![alt text](https://gifimage.net/wp-content/uploads/2018/11/merge-sort-animation-gif-3.gif)

[к оглавлению](#Алгоритмы)

#### Алгоритм сортировки слиянием :
1. Сортируемый массив разбивается на две части примерно одинакового размера.
2. Каждая из получившихся частей сортируется отдельно.
3. Два получившихся упорядоченных массива соединяются в один. При этом наименьший из первых элементов двух массивов записывается в результирующий массив, и эта операция повторяется, пока не закончатся элементы в этих двух массивах.

[к оглавлению](#Алгоритмы)

#### Реализация сортировки слиянием на Java :
```java
public static int[] mergesort(int[] array1) {
    int[] buffer1 = Arrays.copyOf(array1, array1.length);
    int[] buffer2 = new int[array1.length];
    int[] result = mergesortInner(buffer1, buffer2, 0, array1.length);
    return result;
}
/**
 * @param buffer1 Массив для сортировки.
 * @param buffer2 Буфер. Размер должен быть равен размеру buffer1.
 * @param startIndex Начальный индекс в buffer1 для сортировки.
 * @param endIndex Конечный индекс в buffer1 для сортировки.
 * @return
 */
public static int[] mergesortInner(int[] buffer1, int[] buffer2, int startIndex, int endIndex) {
    if (startIndex >= endIndex - 1) {
        return buffer1;
    }
        
    // уже отсортирован.
    int middle = startIndex + (endIndex - startIndex) / 2;
    int[] sorted1 = mergesortInner(buffer1, buffer2, startIndex, middle);
    int[] sorted2 = mergesortInner(buffer1, buffer2, middle, endIndex);
        
    // Слияние
    int index1 = startIndex;
    int index2 = middle;
    int destIndex = startIndex;
    int[] result = sorted1 == buffer1 ? buffer2 : buffer1;
    while (index1 < middle && index2 < endIndex) {
        result[destIndex++] = sorted1[index1] < sorted2[index2] ? sorted1[index1++] : sorted2[index2++];
    }
    while (index1 < middle) {
        result[destIndex++] = sorted1[index1++];
    }
    while (index2 < endIndex) {
        result[destIndex++] = sorted2[index2++];
    }
    return result;
}
```

[к оглавлению](#Алгоритмы)

#### Преимущества сортировки слиянием :
+ Быстрый. Примерно _O(n log n)_ операций.
+ Можно использовать на связанных списках.
+ Можно сделать реализацию, использующую параллельные потоки.
+ Устойчив, так как сохраняет порядок равных элементов.

[к оглавлению](#Алгоритмы)

#### Недостатки сортировки слиянием :
+ Необходимость дополнительной памяти для буфера.
+ На почти отсортированных массивах работает также, как и на неотсортированных.

[к оглавлению](#Алгоритмы)

## Быстрая сортировка (_Quick sorting_)

__Худшее время__: _O(n²)_, но при этом почти всегда выполняется за _O(n log n)_.

Один из самых быстрых известных алгоритмов сортировки. 

Суть алгоритма быстрой сортировки состоит в том, что мы на каждой рекурсивной итерации выбираем неким образом опорный элемент и перемещаем остальные элементы в массиве так, чтобы те, что меньше опорного элемента, стояли слева, а те, что больше - справа. После этого к массивам которые образовались слева и справа, если их размер больше `1`, рекурсивно применяются эти же шаги.

[к оглавлению](#Алгоритмы)

#### Анимация итерации быстрой сортировки :

![alt text](https://thumbs.gfycat.com/PleasantCloseEyelashpitviper-size_restricted.gif)

[к оглавлению](#Алгоритмы)

#### Алгоритм быстрой сортировки :

1. Выбирается элемент каким-либо образом. Существуют разные способы выбора элемента, но алгоритм работает с любым выбранным элементом. Это может быть самый первый, либо самый последний элемент массива, либо элемент где-то посередине. Этот элемент называется опорным.
2. Элементы в массиве перемещаются так, что элементы меньше опорного оказываются слева от него, а элементы больше опорного — справа.
3. К подмассивам слева и справа от опорного применяются первые два шага, если в этих подмассивах больше одного элемента.

От выбора опорного элемента работоспособность алгоритма не ломается, но может ухудшаться или улучшаться производительность. Может выбираться первый элемент, или последний, или средний и т. д.

[к оглавлению](#Алгоритмы)

#### Реализация быстрой сортировки на Java :
```java
/**
 * Реализуем алгоритм быстрой сортировки
 * @param array1 Массив, в котором нужно упорядочить элементы.
 * @param startIndex Начальный индекс в массиве (включая).
 * @param endIndex Конечный индекс в массиве (не включая)
 */
public static void quicksort(int[] array1, int startIndex, int endIndex) {
    int pivotValue = getPivot(array1, startIndex, endIndex);
    int currentStartIndex = startIndex;
    int currentEndIndex = endIndex;
        
    while (currentStartIndex < currentEndIndex) {
        while (array1[currentStartIndex] < pivotValue) {
            currentStartIndex++;
        } 
        while ((array1[currentEndIndex] > pivotValue) && (currentEndIndex > currentStartIndex)) {
            currentEndIndex--;
        }
        if (currentStartIndex < currentEndIndex) {
            swap(array1, currentStartIndex, currentEndIndex);
            if (currentEndIndex - currentStartIndex > 1) {
                currentStartIndex++;
                currentEndIndex--;
            } else {
                break;
            }
        }
    }
    if ((currentStartIndex > startIndex) && (currentStartIndex - startIndex > 1))
        quicksort(array1, startIndex, currentStartIndex);
    if ((endIndex > currentEndIndex) && (endIndex - currentEndIndex > 1))
        quicksort(array1, currentEndIndex , endIndex);
    }
    
/**
 * Меняет местами элементы массива с индексами index1 и index2.
 * @param array1 Массив.
 * @param index1 Индекс элемента 1.
 * @param index2 Индекс элемента 2.
 */
private static void swap(int[] array1, int index1, int index2) {
    int buffer = array1[index1];
    array1[index1] = array1[index2];
    array1[index2] = buffer;
}
    
/**
 * 
 * @param array1
 * @param lowIndex
 * @param highIndex
 * @return Значение опорного элемента. В этой реализации опорный элемент -
 *  это последний элемент в массиве.
 */
public static int getPivot(int[] array1, int startIndex, int endIndex) {
    return array1[endIndex - 1];
}
```

[к оглавлению](#Алгоритмы)

#### Преимущества быстрой сортировки :
+ Высокая скорость. Почти всегда примерно _O(n log n)_ операций.
+ Относительная простота.
+ Допускает распараллеливание, так как подмассивы могут сортироваться параллельно.
+ Может быть использован для связанных списков.

[к оглавлению](#Алгоритмы)

#### Недостатки быстрой сортировки :
+ При неудачных входных данных может дать до O(n²) по скорости (если исходный массив уже отсортирован) но стоит заметить, что такие ситуации будут очень редко.
+ Если делать прямую реализацию с рекурсивными вызовами, то может привести к переполнению стека.
+ Неустойчив, так как меняет порядок равных элементов.

[к оглавлению](#Алгоритмы)
