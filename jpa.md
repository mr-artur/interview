# JPA
+ [Что такое _«ORM»_?](#Что-такое-ORM)
+ [Что такое _«JPA»_?](#Что-такое-JPA)
+ [Из чего состоит _«JPA»_?](#Из-чего-состоит-JPA)
+ [Чем отличается _JPA_ от _Hibernate_?](#Чем-отличается-JPA-от-Hibernate)
+ [Можно ли использовать _JPA_ с _NoSQL_ базами данных?](#Можно-ли-использовать-JPA-с-NoSQL-базами-данных)
+ [_JPQL_](#JPQL)
    + [Полиморфизм в _JPQL_](#Полиморфизм-в-JPQL)

## Что такое _«ORM»_?
_ORM_ (Object-Relational Mapping) - это концепция, основанная на том, что объект можно представить как данные в базе днанных и наоброот. Данную концепцию воплощает спецификация _JPA_. 

[к оглавлению](#JPA)

## Что такое _«JPA»_?
+ _JPA_ (Java Persistence API) - это спецификация _ORM_ фреймворка в Java, которая описывает систему для хранения Java объектов в реляционных БД в удобном виде.
+ _JPA_ - это спецификация (документ, утвержденный как стандарт, описывающий все аспекты технологии), часть EJB3 спецификации.
+ Сам _JPA_ не умеет ни сохранять, ни управлять объектами. Он только определяет правила, по которым все будет работать. JPA также определяет интерфейсы, которые должны будут реализовываться провайдерами. Также JPA определяет, как должны описываться метаданные, и как должны работать провайдеры. Дальше, каждый провайдер, реализуя эту спецификацию, определяет получение, сохранение и управление объектами. У каждого провайдера реализация разная.
+ У JPA_ есть такие провайдеры :
    + Hibernate
    + Oracle TopLink
    + Apache OpenJPA
        
[к оглавлению](#JPA)

## Из чего состоит _«JPA»_?
_JPA_ состоит из `3`-х частей :
+ __API__ - это набор интерфейсов в пакете `javax.persistence`, которые помогают организовать взаимодействие с ORM провайдером.
+ __JPQL__ - это объектный язык запросов. Он очень похож на SQL, но запросы в нем выполняются в терминах объектов.
+ __Metadata__ - это набор аннотаций, которые мы можем использовать для описания метаданные отображений объектов. Это помогает _JPA_ узнать, какой объект в какую таблицу нужно сохранить. Метаданные описываются двумя способами :
    + через xml-файл
    + через аннотации

[к оглавлению](#JPA)

## Чем отличается _JPA_ от _Hibernate_?
Отличие в том, что _Hibernate_ - это один из самых популярных провайдеров, которые реализуют спецификацию _JPA_. То есть, _JPA_ описывает только правила и API системы хранения объектов, а _Hibernate_ реализует эти описания, при чем в _Hibernate_ есть также свои дополнительные возможности, которые не описаны в спецификации _JPA_.

[к оглавлению](#JPA)

## Можно ли использовать _JPA_ с _NoSQL_ базами данных?
Спецификация _JPA_ говорит только об отображении Java объектов в таблицы реляционных баз данных, но несмотря на это, есть ряд _ORM_ провайдеров для _NoSQL_ баз данных, реализующих _JPA_. Их примеры : 
+ Kundera
+ DataNucleus
+ ObjectDB

Естественно, при этом не все специфичные особенности спецификации именно для реляционных БД переносятся при этом на _NoSQL_ базы полностью.

[к оглавлению](#JPA)

## _JPQL_
+ _JPQL_ (Java Persistence Query Language) - это язык запросов в спецификации _JPA_, который похож на SQL, но при этом отличается тем, что его запросы записываются в терминах объектов.
+ Вместо имен и колонок таблиц данных, в _JPQL_ используются имена классов Entity, а также их атрибуты.
+ В качестве параметров запросов, в _JPQL_ также используются типы данных атрибутов Entity.
+ В отличии от SQL, в JPQL есть автоматический полиморфизм.
+ В JPQL есть функции, которых нету в SQL, такие как например :
    + `KEY` (ключ мапы)
    + `VALUE` (значение мапы)
    + `TREAT` (downcasting - приведение суперкласса к объекту - наследнику)
    + `ENTRY`
    + и т.д.

[к оглавлению](#JPA)

### Полиморфизм в _JPQL_
+ Полиморфизм в _JPQL_ - это то, что каждый запрос к Entity возвращает не только объекты Entity, но и объекты всех наследников Entity, вне зависимости от стратегии наследования.
+ Например, запрос `SELECT * FROM Animal` вернет не только объекты класса `Animal`, но и объекты классов условных `Dog` и `Cat` - наследников `Animal`.
+ Чтобы отключить полиморфизм в _JPQL_, используется функция `TYPE` в `WHERE` - условии. Используется это так :
```jpaql
SELECT * FROM Animal a WHERE TYPE(a) IN (Animal, Cat)
```
Такой запрос уже не вернет объекты типа `Dog`.

[к оглавлению](#JPA)
