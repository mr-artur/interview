# JPA
+ [Что такое _«ORM»_?](#Что-такое-ORM)
+ [Что такое _«JPA»_?](#Что-такое-JPA)
+ [Из чего состоит _«JPA»_?](#Из-чего-состоит-JPA)
+ [Чем отличается _JPA_ от _Hibernate_?](#Чем-отличается-JPA-от-Hibernate)
+ [Можно ли использовать _JPA_ с _NoSQL_ базами данных?](#Можно-ли-использовать-JPA-с-NoSQL-базами-данных)
+ [_JPQL_](#JPQL)
    + [Полиморфизм в _JPQL_](#Полиморфизм-в-JPQL)
+ [_Criteria API_](#Criteria-API)
+ [_Entity_](#Entity)
    + [Требования к _Entity_ классам в _JPA_](#Требования-к-Entity-классам-в-JPA)
    + [Типы данных, допустимые для атрибутов _Entity_ класса](#Типы-данных-допустимые-для-атрибутов-Entity-класса)
    + [Типы данных, допустимые для `Id` _Entity_ класса](#Типы-данных-допустимые-для-Id-Entity-класса)

## Что такое _«ORM»_?
_ORM_ (Object-Relational Mapping) - это концепция, основанная на том, что объект можно представить как данные в базе днанных и наоброот. Данную концепцию воплощает спецификация _JPA_. 

[к оглавлению](#JPA)

## Что такое _«JPA»_?
+ _JPA_ (Java Persistence API) - это спецификация _ORM_ фреймворка в Java, которая описывает систему для хранения Java объектов в реляционных БД в удобном виде.
+ _JPA_ - это спецификация (документ, утвержденный как стандарт, описывающий все аспекты технологии), часть EJB3 спецификации.
+ Сам _JPA_ не умеет ни сохранять, ни управлять объектами. Он только определяет правила, по которым все будет работать. JPA также определяет интерфейсы, которые должны будут реализовываться провайдерами. Также JPA определяет, как должны описываться метаданные, и как должны работать провайдеры. Дальше, каждый провайдер, реализуя эту спецификацию, определяет получение, сохранение и управление объектами. У каждого провайдера реализация разная.
+ У JPA_ есть такие провайдеры :
    + Hibernate
    + Oracle TopLink
    + Apache OpenJPA
        
[к оглавлению](#JPA)

## Из чего состоит _«JPA»_?
_JPA_ состоит из `3`-х частей :
+ __API__ - это набор интерфейсов в пакете `javax.persistence`, которые помогают организовать взаимодействие с ORM провайдером.
+ __JPQL__ - это объектный язык запросов. Он очень похож на SQL, но запросы в нем выполняются в терминах объектов.
+ __Metadata__ - это набор аннотаций, которые мы можем использовать для описания метаданные отображений объектов. Это помогает _JPA_ узнать, какой объект в какую таблицу нужно сохранить. Метаданные описываются двумя способами :
    + через xml-файл
    + через аннотации

[к оглавлению](#JPA)

## Чем отличается _JPA_ от _Hibernate_?
Отличие в том, что _Hibernate_ - это один из самых популярных провайдеров, которые реализуют спецификацию _JPA_. То есть, _JPA_ описывает только правила и API системы хранения объектов, а _Hibernate_ реализует эти описания, при чем в _Hibernate_ есть также свои дополнительные возможности, которые не описаны в спецификации _JPA_.

[к оглавлению](#JPA)

## Можно ли использовать _JPA_ с _NoSQL_ базами данных?
Спецификация _JPA_ говорит только об отображении Java объектов в таблицы реляционных баз данных, но несмотря на это, есть ряд _ORM_ провайдеров для _NoSQL_ баз данных, реализующих _JPA_. Их примеры : 
+ Kundera
+ DataNucleus
+ ObjectDB

Естественно, при этом не все специфичные особенности спецификации именно для реляционных БД переносятся при этом на _NoSQL_ базы полностью.

[к оглавлению](#JPA)

## _JPQL_
+ _JPQL_ (Java Persistence Query Language) - это язык запросов в спецификации _JPA_, который похож на SQL, но при этом отличается тем, что его запросы записываются в терминах объектов.
+ Вместо имен и колонок таблиц данных, в _JPQL_ используются имена классов Entity, а также их атрибуты.
+ В качестве параметров запросов, в _JPQL_ также используются типы данных атрибутов Entity.
+ В отличии от SQL, в JPQL есть автоматический полиморфизм.
+ В JPQL есть функции, которых нету в SQL, такие как например :
    + `KEY` (ключ мапы)
    + `VALUE` (значение мапы)
    + `TREAT` (downcasting - приведение суперкласса к объекту - наследнику)
    + `ENTRY`
    + и т.д.
+ У JPQL есть два важных недостатка, которые решаются с помощью использования _Criteria API_ :
    + Запросы _JPQL_ жестко определяются на стадии компиляции и во время исполнения их не изменить.
    + Запросы _JPQL_ никак не связаны с реальными сущностями, и если сущность изменяется, то никто не скажет, что запрос больше неверен, до тех пор, пока его не попытаются выполнить.

[к оглавлению](#JPA)

### Полиморфизм в _JPQL_
+ Полиморфизм в _JPQL_ - это то, что каждый запрос к Entity возвращает не только объекты Entity, но и объекты всех наследников Entity, вне зависимости от стратегии наследования.
+ Например, запрос `SELECT * FROM Animal` вернет не только объекты класса `Animal`, но и объекты классов условных `Dog` и `Cat` - наследников `Animal`.
+ Чтобы отключить полиморфизм в _JPQL_, используется функция `TYPE` в `WHERE` - условии. Используется это так :
```jpaql
SELECT * FROM Animal a WHERE TYPE(a) IN (Animal, Cat)
```
Такой запрос уже не вернет объекты типа `Dog`.

[к оглавлению](#JPA)

## _Criteria API_
+ _Criteria API_ - это тоже язык запросов, похожий на _JPQL_, однако запросы в нем основаны на методах и объектах.
+ Запросы с помощью _Criteria API_ выглядят вот так :
![alt text](https://3.bp.blogspot.com/-HLFfj8qlqwE/Vvv8RVqXM-I/AAAAAAAAAeY/Qogvb2_Ie0o2NfFJCU5NVE7W4eYjYXloQ/s640/JPQL.jpg)
+ _Criteria Api_ помогает строить динамические и гибкие запросы к БД. Можно также сказать, что он решает такие две проблемы _JPQL_ :
    + Запросы _JPQL_ жестко определяются на стадии компиляции и во время исполнения их не изменить.
    + Запросы _JPQL_ никак не связаны с реальными сущностями, и если сущность изменяется, то никто не скажет, что запрос больше неверен, до тех пор, пока его не попытаются выполнить.

[к оглавлению](#JPA)

## _Entity_
+ _Entity_ - это легковесный хранимый объект бизнес-логики (persistent domain object).
+ Entity класс __может__ наследоваться от другого entity класса.
+ Класс, который не является entity, __может__ наследоваться от entity класса.
+ Entity __может__ наследовать от не-entity классов.
+ Entity __может__ быть абстрактным классом. При этом его все равно нельзя создать объекты именно этого класса (обычно используется для наследования).

[к оглавлению](#JPA)

## Требования к _Entity_ классам в _JPA_
1. Entity класс должен быть помечен аннотацией `@Entity` или описан в xml-конфигурации.
2. Entity класс должен содержать первичный ключ (`@Id`), то есть атрибут или группу атрибутов, которые определяют уникальность этой записи в БД.
3. Entity класс должен содержать `public` или `protected` конструктор без аргументов.
4. Entity класс должен быть классом верхнего уровня (top-level class). Это означает, что он не должен быть вложенным классом.
5. Entity класс не должен быть `enum` - ом или интерфейсом.
6. Entity класс не должен быть финальным классом (final class).
7. Entity класс не должен содержать финальные поля или методы, если они участвуют в маппинге.
8. Поля Entity класса должны быть `private`, с наличием сеттеров и геттеров к ним.
9. Если экземпляры Entity класса должны использоваться удаленно как отдельные объекты, то сам класс должен реализовать `Serializable`.

[к оглавлению](#JPA)

## Типы данных, допустимые для атрибутов _Entity_ класса
1. Примитивные типы и их обертки
2. Строки
3. Любые типы, имплементирующие `Serializable`
4. Enums
5. Entity types
6. Embeddable классы
7. Коллекции типов 1 - 6

[к оглавлению](#JPA)

## Типы данных, допустимые для `Id` _Entity_ класса
+ В случае, если ключ не автогенерируемый, можно использовать следующие типы данных для того, чтобы они работали в любой БД :
    1. Примитивные типы и их обертки.
    2. Строки
    3. BigDecimal и BigInteger.
    4. java.util.Date и java.sql.Date. 
    
+ В случае автогенерированого ключа, допустимы только числовые типы. В случае использования других типов данных в первичном ключе, он может работать только для некоторых баз данных, т.е., становится не переносимым.

[к оглавлению](#JPA)
