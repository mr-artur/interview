# JPA
+ [Что такое _«ORM»_?](#Что-такое-ORM)
+ [Что такое _«JPA»_?](#Что-такое-JPA)
+ [Из чего состоит _«JPA»_?](#Из-чего-состоит-JPA)
+ [Чем отличается _JPA_ от _Hibernate_?](#Чем-отличается-JPA-от-Hibernate)
+ [Можно ли использовать _JPA_ с _NoSQL_ базами данных?](#Можно-ли-использовать-JPA-с-NoSQL-базами-данных)
+ [_JPQL_](#JPQL)
    + [Полиморфизм в _JPQL_](#Полиморфизм-в-JPQL)
+ [_Criteria API_](#Criteria-API)
+ [_Entity_](#Entity)
    + [Требования к _Entity_ классам в _JPA_](#Требования-к-Entity-классам-в-JPA)
    + [Типы данных, допустимые для атрибутов _Entity_ класса](#Типы-данных-допустимые-для-атрибутов-Entity-класса)
    + [Типы данных, допустимые для `Id` _Entity_ класса](#Типы-данных-допустимые-для-Id-Entity-класса)
+ [_Embeddable_ классы](#Embeddable-классы)
    + [Требования к _Embeddable_ классам в _JPA_](#Требования-к-Embeddable-классам-в-JPA)
+ [Типы связей между _Entity_](#Типы-связей-между-Entity)
+ [Типы _Fetch_ стратегии](#Типы-Fetch-стратегии)
   
## Что такое _«ORM»_?
_ORM_ (Object-Relational Mapping) - это концепция, основанная на том, что объект можно представить как данные в базе днанных и наоброот. Данную концепцию воплощает спецификация _JPA_. 

[к оглавлению](#JPA)

## Что такое _«JPA»_?
+ _JPA_ (Java Persistence API) - это спецификация _ORM_ фреймворка в Java, которая описывает систему для хранения Java объектов в реляционных БД в удобном виде.
+ _JPA_ - это спецификация (документ, утвержденный как стандарт, описывающий все аспекты технологии), часть EJB3 спецификации.
+ Сам _JPA_ не умеет ни сохранять, ни управлять объектами. Он только определяет правила, по которым все будет работать. JPA также определяет интерфейсы, которые должны будут реализовываться провайдерами. Также JPA определяет, как должны описываться метаданные, и как должны работать провайдеры. Дальше, каждый провайдер, реализуя эту спецификацию, определяет получение, сохранение и управление объектами. У каждого провайдера реализация разная.
+ У JPA_ есть такие провайдеры :
    + Hibernate
    + Oracle TopLink
    + Apache OpenJPA
        
[к оглавлению](#JPA)

## Из чего состоит _«JPA»_?
_JPA_ состоит из `3`-х частей :
+ __API__ - это набор интерфейсов в пакете `javax.persistence`, которые помогают организовать взаимодействие с ORM провайдером.
+ __JPQL__ - это объектный язык запросов. Он очень похож на SQL, но запросы в нем выполняются в терминах объектов.
+ __Metadata__ - это набор аннотаций, которые мы можем использовать для описания метаданные отображений объектов. Это помогает _JPA_ узнать, какой объект в какую таблицу нужно сохранить. Метаданные описываются двумя способами :
    + через xml-файл
    + через аннотации

[к оглавлению](#JPA)

## Чем отличается _JPA_ от _Hibernate_?
Отличие в том, что _Hibernate_ - это один из самых популярных провайдеров, которые реализуют спецификацию _JPA_. То есть, _JPA_ описывает только правила и API системы хранения объектов, а _Hibernate_ реализует эти описания, при чем в _Hibernate_ есть также свои дополнительные возможности, которые не описаны в спецификации _JPA_.

[к оглавлению](#JPA)

## Можно ли использовать _JPA_ с _NoSQL_ базами данных?
Спецификация _JPA_ говорит только об отображении Java объектов в таблицы реляционных баз данных, но несмотря на это, есть ряд _ORM_ провайдеров для _NoSQL_ баз данных, реализующих _JPA_. Их примеры : 
+ Kundera
+ DataNucleus
+ ObjectDB

Естественно, при этом не все специфичные особенности спецификации именно для реляционных БД переносятся при этом на _NoSQL_ базы полностью.

[к оглавлению](#JPA)

## _JPQL_
+ _JPQL_ (Java Persistence Query Language) - это язык запросов в спецификации _JPA_, который похож на SQL, но при этом отличается тем, что его запросы записываются в терминах объектов.
+ Вместо имен и колонок таблиц данных, в _JPQL_ используются имена классов Entity, а также их атрибуты.
+ В качестве параметров запросов, в _JPQL_ также используются типы данных атрибутов Entity.
+ В отличии от SQL, в JPQL есть автоматический полиморфизм.
+ В JPQL есть функции, которых нету в SQL, такие как например :
    + `KEY` (ключ мапы)
    + `VALUE` (значение мапы)
    + `TREAT` (downcasting - приведение суперкласса к объекту - наследнику)
    + `ENTRY`
    + и т.д.
+ У JPQL есть два важных недостатка, которые решаются с помощью использования _Criteria API_ :
    + Запросы _JPQL_ жестко определяются на стадии компиляции и во время исполнения их не изменить.
    + Запросы _JPQL_ никак не связаны с реальными сущностями, и если сущность изменяется, то никто не скажет, что запрос больше неверен, до тех пор, пока его не попытаются выполнить.

[к оглавлению](#JPA)

### Полиморфизм в _JPQL_
+ Полиморфизм в _JPQL_ - это то, что каждый запрос к Entity возвращает не только объекты Entity, но и объекты всех наследников Entity, вне зависимости от стратегии наследования.
+ Например, запрос `SELECT * FROM Animal` вернет не только объекты класса `Animal`, но и объекты классов условных `Dog` и `Cat` - наследников `Animal`.
+ Чтобы отключить полиморфизм в _JPQL_, используется функция `TYPE` в `WHERE` - условии. Используется это так :
```jpaql
SELECT * FROM Animal a WHERE TYPE(a) IN (Animal, Cat)
```
Такой запрос уже не вернет объекты типа `Dog`.

[к оглавлению](#JPA)

## _Criteria API_
+ _Criteria API_ - это тоже язык запросов, похожий на _JPQL_, однако запросы в нем основаны на методах и объектах.
+ Запросы с помощью _Criteria API_ выглядят вот так :
![alt text](https://3.bp.blogspot.com/-HLFfj8qlqwE/Vvv8RVqXM-I/AAAAAAAAAeY/Qogvb2_Ie0o2NfFJCU5NVE7W4eYjYXloQ/s640/JPQL.jpg)
+ _Criteria Api_ помогает строить динамические и гибкие запросы к БД. Можно также сказать, что он решает такие две проблемы _JPQL_ :
    + Запросы _JPQL_ жестко определяются на стадии компиляции и во время исполнения их не изменить.
    + Запросы _JPQL_ никак не связаны с реальными сущностями, и если сущность изменяется, то никто не скажет, что запрос больше неверен, до тех пор, пока его не попытаются выполнить.

[к оглавлению](#JPA)

## _Entity_
+ _Entity_ - это легковесный хранимый объект бизнес-логики (persistent domain object).
+ Entity класс __может__ наследоваться от другого entity класса.
+ Класс, который не является entity, __может__ наследоваться от entity класса.
+ Entity __может__ наследовать от не-entity классов.
+ Entity __может__ быть абстрактным классом. При этом его все равно нельзя создать объекты именно этого класса (обычно используется для наследования).

[к оглавлению](#JPA)

## Требования к _Entity_ классам в _JPA_
1. Entity класс должен быть помечен аннотацией `@Entity` или описан в xml-конфигурации.
2. Entity класс должен содержать первичный ключ (`@Id`), то есть атрибут или группу атрибутов, которые определяют уникальность этой записи в БД.
3. Entity класс должен содержать `public` или `protected` конструктор без аргументов.
4. Entity класс должен быть классом верхнего уровня (top-level class). Это означает, что он не должен быть вложенным классом.
5. Entity класс не должен быть `enum` - ом или интерфейсом.
6. Entity класс не должен быть финальным классом (final class).
7. Entity класс не должен содержать финальные поля или методы, если они участвуют в маппинге.
8. Поля Entity класса должны быть `private`, с наличием сеттеров и геттеров к ним.
9. Если экземпляры Entity класса должны использоваться удаленно как отдельные объекты, то сам класс должен реализовать `Serializable`.

[к оглавлению](#JPA)

## Типы данных, допустимые для атрибутов _Entity_ класса
1. Примитивные типы и их обертки
2. Строки
3. Любые типы, имплементирующие `Serializable`
4. Enums
5. Entity types
6. Embeddable классы
7. Коллекции типов 1 - 6

[к оглавлению](#JPA)

## Типы данных, допустимые для `Id` _Entity_ класса
+ В случае, если ключ не автогенерируемый, можно использовать следующие типы данных для того, чтобы они работали в любой БД :
    1. Примитивные типы и их обертки.
    2. Строки
    3. BigDecimal и BigInteger.
    4. java.util.Date и java.sql.Date. 
    
+ В случае автогенерированого ключа, допустимы только числовые типы. В случае использования других типов данных в первичном ключе, он может работать только для некоторых баз данных, т.е., становится не переносимым.

[к оглавлению](#JPA)

## _Embeddable_ классы
+ _Embeddable_ класс (Встраиваемый) - это такой класс, который используется только как часть _Entity_ классов. 
+ В целом, такие классы служат для вынесения каких-то общих атрибутов из _Entity_ классов. То есть, можно считать, что _JPA_ просто встраивает в _Entity_ вместо объекта встраемового типа те атрибуты, которые он содержит.
+ _Entity_ могут содержать как одиночные объекты `Embeddable` классов, так и их коллекции.
+ _Embeddable_ классы могут быть использованы как ключи или значения _Map_.
+ Во время выполнения каждый _Embeddable_ объект принадлежит только одному экземпляру _Entity_, то есть, не может быть использован для передачи данных между _Entity_ объектами.
+ Каждый _Embeddable_ класс __может__ внутри содержать объекты других _Embeddable_ классов.
+ _Embeddable_ класс __может__  содержать связи с другими _Entity_ или их коллекциями, но только в случае, если такой класс не используется как первичный ключ или ключ map-ы.

[к оглавлению](#JPA)

## Требования к _Embeddable_ классам в _JPA_
1. Такие классы должны удовлетворять тем же требованиям, что и _Entity_, за исключением двух :
    + Они не обязаны содержать первичный ключ.
    + Они не обязаны быть отмечены аннотацией `@Entity`.
2. _Embeddable_ класс должен быть отмечен специальной аннотацией `@Embeddable` или быть описанным в xml-конфигурации JPA.

[к оглавлению](#JPA)

## Типы связей между _Entity_
Все типы связей между _Entity_ в JPA можно поделить на `2` большие группы :
+ _Bidirectional_ - ссылка на связанную `Entity` находится в обеих из них, при этом одна из них является владельцем отношения (это важно при каскадном удалении, при этом при удалении владельца будет удален и второй участник связи, но не наоброот).
+ _Unidirectional_ - ссылка на связанную `Entity` находится только в одной из них, то есть вторая сущность о первой не знает.

Также можно выделить `4` основных вида связей :
1. _One-to-One_ - связь один-к-одному, когда один объект `Entity` может быть связан не более чем с одним объектом другого `Entity`.
2. _One-to-Many_ - связь один-ко-многим, когда в одном объекте `Entity` содержится коллекция объектов другого `Entity`.
3. _Many-to-One_ - связь многие-к-одному, когда один объект `Entity` содержится в коллекции объекта другого `Entity`. Обратная для _One-to-Many_.
4. _Many-to-Many_ - связь многие-ко-многим, когда один объект `Entity` содержит коллекцию объектов другого `Entity`, и наоборот.

Таким образом, если совместить эти две классификации, выйдет, то всего возможных типов связей между _Entity_ в JPA всего `8` штук.

[к оглавлению](#JPA)

## Типы _Fetch_ стратегии
В _JPA_ описаны `2` типа fetch стратегии :
+ _EAGER_ - данные поля будут загружены сразу. Данная стратегия по умолчанию используется в отношениях :
    + _One-to-One_
    + _Many-to-One_
+ _LAZY_ - данные поля будут загружены только в момент первого обращения к ним. Данная стратегия используется по умолчанию в отношениях :
    + _One-to-Many_
    + _Many-to-Many_
    
[к оглавлению](#JPA)
