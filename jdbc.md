# JDBC
+ [Что такое _«JDBC»_?](#Что-такое-JDBC)
+ [Для чего нужен _JDBC_?](#Для-чего-нужен-JDBC)
+ [Архитектура _JDBC_](#Архитектура-JDBC)
+ [`DriverManager`](#DriverManager)
+ [Драйверы](#Драйверы)
    + [Типы драйверов](#Типы-драйверов)
    + [Какой тип драйвера выбрать?](#Какой-тип-драйвера-выбрать?)
+ [`Connection`](#Connection)
    + [Регистрация драйвера](#Регистрация-драйвера)
    + [Передача информации о БД](#Передача-информации-о-БД)
    + [Создание соединения](#Создание-соединения)
    + [Закрытие соединения](#Закрытие-соединения)
+ [Утверждения (Statements)](#Утверждения-Statements)
    + [`Statement`](#Statement)
        + [Создание экземпляра `Statement`](#Создание-экземпляра-Statement)
        + [Методы `Statement`](#Методы-Statement)
        + [Закрытие экземпляра `Statement`](#Закрытие-экземпляра-Statement)
    + [`PreparedStatement`](#PreparedStatement)
        + [Создание экземпляра `PreparedStatement`](#Создание-экземпляра-PreparedStatement)
        + [Методы `PreparedStatement`](#Методы-PreparedStatement-)
        + [Закрытие экземпляра `PreparedStatement`](#Закрытие-экземпляра-PreparedStatement)
    + [`CallableStatement`](#CallableStatement)
        + [Создание экземпляра `CallableStatement`](#Создание-экземпляра-CallableStatement)
        + [Закрытие экземпляра `CallableStatement`](#Закрытие-экземпляра-CallableStatement)    
+ [`ResultSet`](#ResultSet)
    + [Конфигурация `ResultSet`](#Конфигурация-ResultSet)
    + [Пример конфигурации `ResultSet`](#Пример-конфигурации-ResultSet)
    + [Методы `ResultSet`](#Методы-ResultSet)
    + [Пример получения данных из `ResultSet`](#Пример-получения-данных-из-ResultSet)
+ [Транзакции в JDBC](#Транзакции-в-JDBC)
+ [`SQLException`](#SQLException)
+ [Обработка пакетов (Batch)](#Обработка-пакетов-Batch)
    + [Порядок выполнения запросов в пакете](#Порядок-выполнения-запросов-в-пакете)

## Что такое _«JDBC»_?
+ _JDBC_ (Java Database Connectivity) - это стандартный API для работы с разными базами данных в языке Java.
+ Для работы с конкретной базой данных необходимо установить специальный драйвер для нее, который является адаптером Java-приложения под конкретную БД.
+ _JDBC_ входит в стандартную библиотеку Java. Его классы находятся в пакетах `java.sql` и `javax.sql`.

[к оглавлению](#JDBC)

## Для чего нужен _JDBC_?
_JDBC_ решает следующие задачи :
+ Создание соединения с БД.
+ Создание _SQL_ - выражений.
+ Выполнение _SQL_ - запросов.
+ Получение данных из базы, их обновление, удаление, а также вставка новых.

[к оглавлению](#JDBC)

## Архитектура _JDBC_
+ Архитектура _JDBC_ может быть как `2` - х звенной, так и `3` - х звенной, но в общем случае она состоит из `2` - х слоев :
    + JDBC API - обеспечивает соединение приложения с JDBC Manager.
    + JDBC Driver API - обеспечивает соединение JDBC Manager с драйвером.
+ JDBC API использует менеджер драйверов и специальные драйверы БД для обеспечения подключения к базам данных.
+ JDBC Manager проверяет соответствие драйвера с конкретной БД. Он поддерживает использование нескольких драйверов одновременно для одновременной работы с несколькими БД.

Схематично JDBC можно представить в таком виде :

![alt text](https://pro-java.ru/wp-content/uploads/2015/03/JDBC-Architecture.gif)

[к оглавлению](#JDBC)

## `DriverManager`
+ `DriverManager` - это ключевая сущность JDBC, которая управляет списком драйверов БД. 
+ `DriverManager` позволяет нам указывать ему, какие драйвера необходимо загрузить в его список.
+ `DriverManager` также позволяет устанавливать соединение с базами данных с помощью вызова `DriverManager.getConnection`, который принимает в качестве аргументов параметры подключения. `DriverManager` смотрит на `URL`, переданный как аргумент, и опрашивает имеющиеся драйверы в поиске подходящего. После он устанавливает соединение с БД с помощью ПЕРВОГО подошедшего по урлу драйвера.

[к оглавлению](#JDBC)

## Драйверы
+ _Драйвер_ - это сущность, которая непосредственно отвечает за взаимодействие с опреденной БД. Работать нам с ней приходится крайне редко, так как вместо этого мы используем объекты `DriverManager`, которые управляют драйверами.
+ Именно драйвер дает нам возможность открывать соединения, выполнять `SQL` - запросы и т.п.
+ Чтобы БД могла работать с _JDBC_, ее разработчики должны написать соответствующую имплементацию интерфейса `java.sql.Driver`.

[к оглавлению](#JDBC)

## Типы драйверов
+ ___Тип 1_. JDBC - ODBC транслятор__.
    + Этот тип драйвера транслирует JDBC в установленный на каждой клиентской машине ODBC (Open Database Connectivity). Использование ODBC требует конфигурации DSN, который является целевой БД.
    + Схема работы JDBC - ODBC транслятора :
    
        ![alt text](https://i0.wp.com/proselyte.net/wp-content/uploads/2016/03/jdbc-driver-type1.jpg?resize=300%2C254&ssl=1)
    + Изначально, именно этот тип драйверов был самым используемым, так как большинство БД поддерживало только ODBC.

+ ___Тип 2_. JDBC - нативный API__.
    + В этом драйвере JDBC API преобразовывается в уникальный для каждой БД нативный C/C++ API. 
    + Его принцип работы довольно схож с драйвером первого типа.
    + Схема работы JDBC - нативный API драйвера :
    
        ![alt text](https://i0.wp.com/proselyte.net/wp-content/uploads/2016/03/jdbc-driver-type2.jpg?resize=300%2C254&ssl=1)
    + Если мы меняем БД, то нам необходимо изменить и нативный API, который будет работать с конкретной БД.
    
+ ___Тип 3_. JDBC - Драйвер на основе библиотеки Java__.
    + Этот тип драйверов использует трехзвенный подход для получения доступа к БД.
    + Для связи с промежуточным сервером используется стандартный сетевой сокет. Информация, полученная от этого сокета, транслируется промежуточным сервером в формат, который необходим конкретной БД и направляется в сервер БД.
    + Схема работы JDBC - Драйвера на основе библиотеки Java : 
        
        ![alt text](https://i2.wp.com/proselyte.net/wp-content/uploads/2016/03/jdbc-driver-type3.jpg?resize=300%2C227&ssl=1)
    + Этот подход является крайне гибким, так как нет необходимости устанавливать ПО на стороне клиента и один драйвер способен обеспечить доступ к различным БД.

+ ___Тип 4_. Чистая Java__.
    + Этот тип драйверов разработан полностью с использованием языка программирования Java и работает с БД через сокетное соединение.
    + Главное преимущество такого драйвера - это наибольшая производительность, и обычно такие драйверы предоставляются разработчиками БД.
    + Схема работы драйвера на чистой Java :
    
        ![alt text](https://i2.wp.com/proselyte.net/wp-content/uploads/2016/03/jdbc-driver-type4.jpg?resize=300%2C275&ssl=1)   
    + Еще одно преимущество такого типа драйвера - это невероятная гибкость. Нам не нужно устанавливать никакого дополнительного программного обеспечения.
    + Ярким примером такого драйвера является _MySQL Connector/J_.

[к оглавлению](#JDBC)

## Какой тип драйвера выбрать?
+ Когда мы работаем с такими БД, как MySQL, Oracle и т.д., наиболее предпочтительным будет использования драйвера типа `4`.
+ Если наше приложение использует различные виды БД, то тип `3` будет более приемлемым.
+ Если для нашей БД еще нет драйверов `3` или `4`, то мы будем вынуждены использовать драйвер под номером `2`.
+ Драйвер типа `1` обычно не используется в коммерческой разработке.   

[к оглавлению](#JDBC) 

## `Connection`
`Connection` - это тип объектов соединения с базой данных. Он создается с помощью перегруженного метода `DriverManager.getConnection()` и позволяет нам выполнять `SQL` - запросы.

Для того, чтобы установить соединение с базой банных, необходимо выполнить `3` шага :
1. Зарегистрировать JDBC драйвер.
2. Передать информацию для соединения с БД (URL, имя пользователя и пароль) - шаг фактически общий с третим.
3. Создать соединение с помощью `DriverManager.getConnection()`.

[к оглавлению](#JDBC) 

### Регистрация драйвера
Регистрацию драйвера можно осуществить `2` - мя способами :
##### 1. С помощью статического метода `DriverManager.registerDriver()`.

В коде это выглядит так :
```java
try {
    Driver driver = new com.mysql.jdbc.Driver();
    DriverManager.registerDriver(driver);
} catch (SQLException e) {
    System.out.println("Unable to load driver class.");
    e.printStackTrace();
}
```

##### 2. С помощью `Class.forName()`.

Этот способ является более распространенным. Мы используем `Class.forName()` для динамической загрузки класса драйвера в память, после чего происходит его автоматическая регистрация. 

Данный способ является более предпочтительным, так как он обеспечивает конфигурируемую и переносимую регистрацию драйверов.

В коде он выглядит так :
```java
try {
    Class.forName("com.mysql.jdbc.Driver");
} catch (ClassNotFoundException e) {
    System.out.println("Unable to load class.");
    e.printStackTrace();
}
```

[к оглавлению](#JDBC) 

### Передача информации о БД
После того, как мы зарегистрировали наш драйвер, мы можем установить соединение с помощью метода `DriverManager.getConnection()`.

Этот метод имеет `3` перегруженных варианта :
+ `getConnection(String url)`
+ `getConnection(String url, Properties props)`
+ `getConnection(String url, String user, String password)`

Как видим, каждый из этих методов требует URL нашей БД. Поэтому, нам необходимо передавать информацию о БД.

URL для разных баз данных будет различен, так же как и драйвер. Например :
+ MySQL : URL : `jdbc:mysql://hostname/databaseName`, Driver name : `jdbc:mysql://hostname/databaseName`.
+ Oracle : URL : `jdbc:oracle:thin:@hostname:portNumber/databaseName`, Driver name : `oracle.jdbc.driver.OracleDriver`.

[к оглавлению](#JDBC) 

### Создание соединения
После того, как мы зарегистрировали драйвер и передали всю необходимую информацию о БД, мы можем создать физическое соединение с БД.

Пример создания соединения с БД MySQL :
```java
String URL = "jdbc:mysql://localhost/exampledb";
String USER = "root";
String PASSWORD = "root";
Connection connection = DriverManger.getConnection(URL, USER, PASSWORD);
```

[к оглавлению](#JDBC) 

### Закрытие соединения
После того, как мы закончим программу, необходимо закрыть все соединения и освободить ресурсы. Если мы не сделаем это вручную, это сделает сборщик мусора при уничтожении объектов, которые не используются.

Но полагаться на сборщик мусора - это крайне плохая идея и дурной тон.

Можно закрыть соединение либо явно (так делали раньше в блоке `final`) :
```java
connection.close();
```
Либо более современным способом - использовать автоматическое освобождение ресурсов с помощью конструкции `try-with-resources` :
```java
try (Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD)) {
    ...
}
```

[к оглавлению](#JDBC)

## Утверждения (Statements)
Утверждения - это интерфейсы, которые помогают нам взаимодействовать с БД и реализуются каждым драйвером.

Их существует `3` :
+ `Statement` - интерфейс, который используется для доступа к БД в общих целях. Он крайне полезен, когда мы используем статические SQL - выражения во время работы программы. Этот интерфейс не принимает никаких параметров.
+ `PreparedStatement` - интерфейс, который используется в случае, когда мы планируем использовать выражения SQL множество раз. Он принимает параметры во время работы программы.
+ `CallableStatement` - интерфейс, который позволяет нам получить доступ к различным процедурам БД. Он также принимает значения во время работы программы.

[к оглавлению](#JDBC)

## `Statement`
+ `Statement` - это интерфейс, который используется для проведения операций с БД. Он является самым простым среди трех разных стейтментов, а также является parent-классом для `PreparedStatement` (тот в свою очередь parent для `CallableStatement`).
+ `Statement` обычно используется для работы со статическими SQL - запросами, которые не рассчитаны на переиспользование.
+ Объект `Statement` получается с помощью вызова метода `connection.getStatement()`.

[к оглавлению](#JDBC)

### Создание экземпляра `Statement`
Прежде, чем мы сможем использовать `Statement`, нам необходимо получить его экземпляр. Для этого используется метод `Connection.createStatement()`.

В коде создание `Statement` выглядит следующим образом :
```java
try (Statement statement = connection.createStatement()){
    ...
} catch (SQLException e) {
    e.printStackTrace();
}
```

[к оглавлению](#JDBC)

### Методы `Statement`
После создания экземпляра `Statement` мы можем его использовать для выполнения SQL-запросов.

Для этой цели интерфейс `Statement` имеет три метода, которые реализуются каждой конкретной реализации JDBC драйвера :
+ `execute(String sql) -> boolean` - используется для любых SQL-запросов и возвращает `true`, если команда может вернуть набор строк (`SELECT`) и `false` для остальных операторов.
+ `executeUpdate(String sql) -> int` - выполняет такие SQL-команды, как `INSERT`, `UPDATE`, `DELETE`, `CREATE TABLE`, `DROP TABLE`. В качестве результата вовращает количество строк, затронутых операцией (измененных, добавленных, удаленных и т.п.).
+ `executeQuery(String sql) -> ResultSet` - выполняет SQL-команду `SELECT`. Возвращает объект `ResultSet`, в котором содержатся результаты запроса.

[к оглавлению](#JDBC)

### Закрытие экземпляра `Statement`
Экземпляр `Statement` обычно закрывается вместо с `Connection`, из которого его достали, для этого используется в старом варианте с `finally` - вызов метода `statement.close()`, а в новом - это создание его в блоке ресурсов конструкции `try-with-resources` :

```java
Class.forName(JDBC_DRIVER);
Connection connection = DriverManager.getConnection(DATABASE_URL, USER, PASSWORD);

try (Statement statement = connection.createStatement()){
    ...
} catch (SQLException e) {
    e.printStackTrace();
}
```
После выполнения блока `try-catch` объект `statement` будет автоматически закрыт, так как он имплементирует `AutoCloseable`.

[к оглавлению](#JDBC)

## `PreparedStatement`
+ `PreparedStatement` - это интерфейс утверждения, который используется когда мы планируем переиспользовать SQL-команду множество раз. В этом ему помогает возможность динамического подставления параметров в запрос.
+ Интерфейс `PreparedStatement` наследует интерфейс `Statement`, что дает ему определенные преимущества перед обычным `Statement`. В частности, мы получаем большую гибкость при работе с динамическими аргументами.
+ `PreparedStatement` является parent-классом для `CallableStatement`.
+ Объект `PreparedStatement` получается с помощью вызова метода `connection.prepareStatement()`.

[к оглавлению](#JDBC)

### Создание экземпляра `PreparedStatement`
Создание экземпляра `PreparedStatement` :
```java
String SQL = "Update developers SET salary WHERE specialty = ?";

try (PreparedStatement preparedStatement = connection.prepareStatement(SQL)) {
    ...
} catch (SQLException e){
    e.printStackTrace();
}
```
Все параметры, отмеченные символом `?`, называются маркерами параметра. Это означает, что они должны быть переданы через параметры метода. 

Каждый параметр ссылается на свой порядковый номер в сигнатуре метода. То есть, первый маркер находится на первой позиции, второй - на второй и т.д. То есть, отсчет, в отличии от массивов, тут идет с единицы. Это связано с особенностями реляционной модели, на которой и основана работа реляционных БД.

[к оглавлению](#JDBC)

### Методы `PreparedStatement`
`PreparedStatement` имеет все те же `3` метода, что и у родителя - `Statement`, только немного измененные внутри : 
+ `execute(String sql) -> boolean`
+ `executeUpdate(String sql) -> int`
+ `executeQuery(String sql) -> ResultSet`

Также тут добавляются новые методы для динамической подстановки значений по маркерам в SQL. Вот часть из них :
+ `setString`
+ `setInt`
+ `setBigDecimal`
+ `setBoolean`
+ `setDate`
+ `setDouble`
+ `setFloat`
+ `setLong`
+ `setNull`
+ `setTime`

Все они принимают первым параметром номер маркера, начиная с `1`, в который следует подставить значения, а вторым - само значение.

[к оглавлению](#JDBC)

### Закрытие экземпляра `PreparedStatement`
`Prepared` является реализацией `AutoCloseable`, а поэтому, как и его parent - `Statement`, может закрываться двумя способами : первый - по старинке, через `finally`, где вызывается метод `preparedStatement.close()`, а второй - современный - автоматическое закрытие с `try-with-resources` :
```java
String SQL = "Update developers SET salary WHERE specialty = ?";

try (PreparedStatement preparedStatement = connection.prepareStatement(SQL)) {
   ...
} catch (SQLException e) {
    e.printStackTrace();
} 
```
После данного блока `try-catch` объект `preparedStatement` будет автоматически закрыт.

[к оглавлению](#JDBC)

## `CallableStatement`
+ `CallableStatement` используется для выполнения процедур непосредственно в самой БД.
+ `CallableStatement` расширяет интерфейс `PreparedStatement`.
+ Существует три типа параметров - IN, OUT, INOUT. `PreparedStatement` использует только IN, тогда как `CallableStatement` использует все три. Что же это за параметры :
    + IN - параметр, значение которого известно в момент создания запроса. Мы можем его назначить с помощью метода `setXXX()`.
    + OUT - параметр, значение которого возвращается SQL-запросом. Мы получаем значения из OUT с помощью метода типа `getXXX()`.
    + INOUT - параметр, который использует входные и выходные значения. Мы можем как назначит его значение с помощью метода `setXXX()`, так и получить его значение с помощью `getXXX()`.
+ Объект `CallableStatement` получается с помощью вызова метода `connection.prepareCall()`.

[к оглавлению](#JDBC)

### Создание экземпляра `CallableStatement`
Создадим процедуру в MySQL :
```sql
DELIMITER $$
DROP PROCEDURE IF EXISTS `developers`.`getDeveloperName` $$
CREATE PROCEDURE PROSELYTE_TUTORIALS.`getDeveloperName`
(IN DEVELOPER_ID INT, OUT DEVELOPER_NAME VARCHAR(50))
BEGIN
SELECT first INTO DEVELOPER_NAME
FROM developers
WHERE id = DEVELOPER_ID;

END $$

DELIMITER ;
```
В коде создание экземпляра будет выглядеть следующим образом :
```java
String SQL = "{call getDeveloperName (?, ?)}";

try (CallableStatement callableStatement = connection.prepareCall(SQL)) {
    ...
}
```
Здесь строка представляет собой процедуру с параметрами.

Схожим образом с `PreparedStatement`, мы должны установить параметры и для данного стейтмента.

Особенности использования `CallableStatement` :
+ Когда мы используем параметры типа OUT и INOUT, нам необходимо задействовать дополнительный метод `registerOutParameter()`. Этот метод устанавливает тип данных JDBC в тип данных процедуры.
+ После того, как мы вызвали процедуру, мы получаем значение из параметра OUT с помощью соответствующего метода `getXXX()`. Этот метод преобразует полученное значение из типа данных SQL в тип данных Java/.

[к оглавлению](#JDBC)

### Закрытие экземпляра `CallableStatement`
`CallableStatement` реализует `AutoCloseable`, поэтому его эклемпляр можно закрыть либо с помощью `callableStatement.close()`, либо автоматически в `try-with-resources` :
```sql
String SQL = "{call getDeveloperName (?, ?)}";

try (CallableStatement callableStatement = connection.prepareCall(SQL)) {
    ...
}
```
После окончания блока `try-with-resources` объект `callableStatement` автоматически будет закрыт.

[к оглавлению](#JDBC)

## `ResultSet`
+ `ResultSet` - это сущность, в виде которой возвращаются данные, полученные из БД.
+ Получается `ResultSet` с помощью запроса `SELECT` к БД.
+ в Java `ResultSet` - это интерфейс, который находится в пакете `java.sql`.
+ Каждый экземпляр `ResultSet` имеет указатель на текущую строку в полученном множестве.

[к оглавлению](#JDBC)

### Конфигурация `ResultSet`
`ResultSet` позволяет задать один из трех типов :
+ `ResultSet.TYPE_FORWARD_ONLY` (стоит по умолчанию) - указатель движется только вперед по множеству полученных результатов.
+ `ResultSet.TYPE_SCROLL_INTENSIVE` - указатель может двигаться вперед и назад и не чувствителен к изменениям в БД, которые сделаны другим пользователям после того, как был создан данный `ResultSet`.
+ `ResultSet.TYPE_SCROLL_SENSITIVE` - указатель может двигаться вперед и назад и чувствителен к изменениям в БД, которые сделаны другим пользователем после получения данного `ResultSet`.

Также можно сконфигурировать уровень доступа в `ResultSet` :
+ `ResultSet.CONCUR_READ_ONLY` (стоит по умолчанию) - создает экземпляр `ResultSet` только для чтения.
+ `ResultSet.CONCUR_UPDATABLE` - создает экземпляр `ResultSet`, который может менять данные.

Сконфигурировать `ResultSet` можно в методах создания стейтментов :
+ `connection.createStatement()`
+ `connection.prepareStatement()`
+ `connection.prepareCall()`

[к оглавлению](#JDBC)

### Пример конфигурации `ResultSet`

В коде создание экземпляра `ResultSet` с кастомными параметрами выглядит так :
```java
try (Statement statement = connection.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)) {
    ...
} catch (SQLException e) {
    e.printStackTrace()
}
```

[к оглавлению](#JDBC)

### Методы `ResultSet`
Все методы интерфейса `ResultSet` можно разделить на `3` группы :
+ __Методы получения данных__ - эти методы используются для просмотра данных конкретной записи, на которую ссылается указатель. Основные их две группы - это методы, которые получают данные по номеру колонки, и методы, которые получают данные по названию колонки :
    + `int getInt (int columnIndex) throws SQLException` - Возвращает номер текущего ряда с указанным индексом колонки. Индексы начинаются с 1. Т.е. первая – 1, вторая – 2 и т.д.
    + `int getInt (String columnName) throws SQLException` - Возвращает целое число в текущем ряду с колонкой с именем, переданном в параметре columnName.
    + и т.д. для остальных типов данных.
+ __Методы изменения данных__ - эти методы используются для изменения данных текущей записи. Эти изменения передаются в используемую БД :
    + Мы можем изменять данные как по имени, так и по номеру колонки :
        + `void updateString (int columnIndex, String s) throws SQLException` - Изменяет строку в указанной колонке.
        + `void updateString (String columnName, String s) throws SQLException` - Изменяет строку в колонке с указанным именем.
        + и т.д. для остальных типов данных.
    + Мы можем также работать со строками в таблице БД :
        + `void insertRow()` - Вставляет запись в таблицу БД. Может быть использован только в том случае, когда указатель ссылается на ряд для вставки.
        + `void updateRow()` - Изменяет текущий ряд в таблице БД.
        + `void deleteRow()` - Удаляет текущий ряд из таблицы БД.
+ __Методы навигации__ - эти методы используются для перемещения указателя :
    + `void beforeFirst() throws SQLException` - Перемещает указатель на место перед первым рядом.
    + `void afterLast() throws SQLException` - Перемещает указатель на место после крайнего ряда.
    + `boolean first() throws SQLException` - Перемещает указатель на первый ряд.
    + `boolean last() throws SQLException` - Перемещает указатель на крайний ряд.
    + `boolean previous() throws SQLException` - Перемещает указатель на предыдущий ряд. Возвращает false, если предыдущий ряд находится за пределами множества результатов.
    + `boolean next() throws SQLException` - Перемещает указатель на следующий ряд. Возвращает false, если следующий ряд находится за пределами множества результатов.
    + `void absolute(int row) throws SQLException` - Перемещает указатель на указанный ряд.
    + `void relative(int row) throws SQLException` - Перемещает указатель на указанное количество рядов от текущего
    + `int getRow() throws SQLException` - Возвращает номер ряда, на который в данный момент указывает курсор.
    + `void moveToInsertRow() throws SQLException` - Перемещает указатель на ряд в полученном множестве, который может быть использован для того, чтобы добавить новую запись в БД. Текущее положение указателя запоминается.
    + `void moveToCurrentRow() throws SQLExcpetion` - Возвращает указатель обратно на текущий ряд в случае, если указатель ссылается на ряд, в который в данный момент добавляются данные.

[к оглавлению](#JDBC)

### Пример получения данных из `ResultSet`
Для получения данных построчно из `ResultSet` обычно используется его метод `next()` в цикле `while` :
```java
ResultSet resultSet = statement.executeQuery(SQL);

while (resultSet.next()) {
    id = resultSet.getInt("id");
    name = resultSet.getString("name");
    specialty = resultSet.getString("specialty");
    salary = resultSet.getInt("salary");
```

[к оглавлению](#JDBC)

## Транзакции в JDBC
+ Когда мы работаем c JDBC, по умолчанию наше соединение работает в режиме `auto-commit`. Это означает, что каждый SQL-запрос будет выполнен и результаты будут сохранены в таблице БД.
+ Это удобно для простых приложений. Но если мы хотим увеличить производительность, использовать распределенные транзакции, либо интегрировать бизнес-логику, то нам необходимо выключить режим `auto-commit` для управления нашими транзакциями.
+ Транзакции дают нам возможность контролировать когда и где сохранять изменения в БД. Благодаря этому мы, например, можем объединить группу SQL-запросов в одну логическую группу, и если один из запросов не пройдет - мы отменяем всю транзакцию.
+ Для того, чтобы получить досутп к управлению транзакциями, необходимо использовать метод `setAutoCommit()` :
```java
connection.setAutoCommit(false);
``` 
+ После того, как мы выполнили необходимые нам изменения, мы должны вызвать метод `commit()` :
```java
connection.commit();
```
+ Если же мы хотим выполнить откат изменений, то нам необходимо вызвать метод `rollback()` :
```java
connection.rollback();
```
+ Начиная со спецификации JDBC 3.0 появился интерфейс `Savepoint`, который дает еще больший контроль над транзакциями. С помощью сейвпоинтов мы можем задать точку, в которую будет происходить откат в случае его надобности. Для управления этой функций есть два метода :
    + `setSavepoint(String savepointName)` - определяет новую точку сохранения и возвращает ее экземпляр.
    + `releaseSavepoint(String savepointName)` - удаляет точку сохранения.
+ Пример транзакции с `Savepoint` :
```java
...

Savepoint savepointOne = connection.setSavepoint("SavepointOne");

try {
     SQL = "INSERT INTO developer VALUES (6, 'John','C#', 2200)";
     statement.executeUpdate(SQL);
    
     SQL = "INSE INTHE developers VALUES (7, 'Ron', 'Ruby', 1900)";
     statement.executeUpdate(SQL); // тут будет ошибка

     connection.commit();
} catch (SQLException e) {
    System.out.println("SQLException. Executing rollback to savepoint...");
    connection.rollback(savepointOne);
}
```
Как видим, в данном примере выполняются `2` SQL-запроса, во втором из которых вылетит ошибка. Поскольку метод `commit()` вызывается в конце блока `try`, то транзакция будет откачена до сейвпоинта в случае неудачи.

[к оглавлению](#JDBC)

## `SQLException`
+ `SQLException` - это основное исключение, которые выбрасывается методами JDBC API.
+ `SQLException` является проверяемым исключением, а поэтому его надо либо обрабатывать в `try-catch` в DAO, либо пробрасывать в `throws`.
+ Считается хорошей практикой перехватывать `SQLException` на уровне DAO и выбрасывать кастомный непроверяемый эксепшн вместо него.
+ Методы класса `SQLException` :
    + `getMessage()` - Принимает сообщение ошибки JDBC драйвера, которая обрабатывается драйвером, либо получает номер ошибки и сообщение для ошибки базы данных.
    + `getSQLState()` - Принимает строку SQLState. Для ошибки JDBC драйвера. Этот метод не возвращает полезной информации.
    + `getErrorCode()` - Возвращает код ошибки, который связан с исключением.
    + `getNextException()` - Получает следующий экземпляр исключения в цепочке исключений.
    + `printStackTrace()` - Отображает текущее исключение и стектрейс в стандартный поток ошибок.
    + `printStackTrace(PrintStream s)` - Печатает исключение и его стектрейс в указанный поток.
    + `printStackTrace(PrintWriter w)` - Печатает исключение и его стектрейс в указанный writer.
    
[к оглавлению](#JDBC)

## Обработка пакетов (Batch)
+ _Обработка пакетов_ позволяет нам объединять связанные SQL-запросы в логические группы и посылать их одним "пакетом" в БД.
+ Таким образом, отправляя несколько SQL-запросов вместе, мы уменьшаем количество взаимодействий с БД, тем самым повышая производительность.
+ Для использования этой функции нам необходимо использовать проверить, поддерживает ли драйвер ее. Для этого нужно вызвать функцию `DatabaseMetadata.supportBatchUpdates() -> boolean`. Он вернет `true`, если функция поддерживается.
+ Интерфейсы `Statement`, `PreparedStatement` и `CallableStatement` имеют следующие методы для работы с пакетами запросов :
    + `addBatch()` - добавляет SQL-запрос в пакет.
    + `executeBatch()` - выполняет все запросы в пакете.
    + `clearBatch()` - удаляет все запросы из пакета. Возможности удалить отдельный запрос нету.
    
[к оглавлению](#JDBC)

## Порядок выполнения запросов в пакете
Порядок выполнения запросов объединенных в пакет будет следующим :
1. Создание экземпляра `Statement`, `PreparedStatement` или `CallableStatement` с помощью методов `Connection`.
2. Отключение `auto-commit`, установив `false` в методе `setAutoCommit()`.
3. Добавление необходимых `SQL-запросов` с помощью `addBatch()`.
4. Выполнение всех запросов в пакете с помощью `executeBatch()`.
5. Сохранение изменений с помощью `commit()`.

Также стоит заметить, что выполнить это можно и без пунктов 2 и 5.

[к оглавлению](#JDBC)
