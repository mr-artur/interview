# JDBC
+ [Что такое _«JDBC»_?](#Что-такое-JDBC)
+ [Для чего нужен _JDBC_?](#Для-чего-нужен-JDBC)
+ [Архитектура _JDBC_](#Архитектура-JDBC)
+ [`DriverManager`](#DriverManager)
+ [Драйверы](#Драйверы)
    + [Типы драйверов](#Типы-драйверов)
    + [Какой тип драйвера выбрать?](#Какой-тип-драйвера-выбрать?)
+ [`Connection`](#Connection)
    + [Регистрация драйвера](#Регистрация-драйвера)
    + [Передача информации о БД](#Передача-информации-о-БД)
    + [Создание соединения](#Создание-соединения)
    + [Закрытие соединения](#Закрытие-соединения)
+ [Утверждения (Statements)](#Утверждения-Statements)
    + [`Statement`](#Statement)
        + [Создание экземпляра `Statement`](#Создание-экземпляра-Statement)
        + [Методы `Statement`](#Методы-Statement)
        + [Закрытие экземпляра `Statement`](#Закрытие-экземпляра-Statement)
    + [`PreparedStatement`](#PreparedStatement)
        + [Создание экземпляра `PreparedStatement`](#Создание-экземпляра-PreparedStatement)
        + [Методы `PreparedStatement`](#Методы-PreparedStatement-)
        + [Закрытие экземпляра `PreparedStatement`](#Закрытие-экземпляра-PreparedStatement)
    + [`CallableStatement`](#CallableStatement)
        + [Создание экземпляра `CallableStatement`](#Создание-экземпляра-CallableStatement)
        + [Закрытие экземпляра `CallableStatement`](#Закрытие-экземпляра-CallableStatement)    

## Что такое _«JDBC»_?
+ _JDBC_ (Java Database Connectivity) - это стандартный API для работы с разными базами данных в языке Java.
+ Для работы с конкретной базой данных необходимо установить специальный драйвер для нее, котоырый является адаптером Java-приложения под конкретную БД.
+ _JDBC_ входит в стандартную библиотеку Java. Его классы находятся в пакетах `java.sql` и `javax.sql`.

[к оглавлению](#JDBC)

## Для чего нужен _JDBC_?
_JDBC_ решает следующие задачи :
+ Создание соединения с БД.
+ Создание _SQL_ - выражений.
+ Выполнение _SQL_ - запросов.
+ Получение данных из базы, их обновление, удаление, а также вставка новых.

[к оглавлению](#JDBC)

## Архитектура _JDBC_
+ Архитектура _JDBC_ может быть как `2` - х звенной, так и `3` - х звенной, но в общем случае она состоит из `2` - х слоев :
    + JDBC API - обеспечивает соединение приложения с JDBC Manager.
    + JDBC Driver API - обеспечивает соединение JDBC Manager с драйвером.
+ JDBC API использует менеджер драйверов и специальные драйверы БД для обеспечения подключения к базам данных.
+ JDBC Manager проверяет соответствие драйвера с конкретной БД. Он поддерживает использование нескольких драйверов одновременно для одновременной работы с несколькими БД.

Схематично JDBC можно представить в таком виде :

![alt text](https://pro-java.ru/wp-content/uploads/2015/03/JDBC-Architecture.gif)

[к оглавлению](#JDBC)

## `DriverManager`
+ `DriverManager` - это ключевая сущность JDBC, которая управляет списком драйверов БД. 
+ `DriverManager` позволяет нам указывать ему, какие драйвера необходимо загрузить в его список.
+ `DriverManager` также позволяет устанавливать соединение с базами данных с помощью вызова `DriverManager.getConnection`, который принимает в качестве аргументов параметры подключения. `DriverManager` смотрит на `URL`, переданный как аргумент, и опрашивает имеющиеся драйверы в поиске подходящего. После он устанавливает соединение с БД с помощью ПЕРВОГО подошедшего по урлу драйвера.

[к оглавлению](#JDBC)

## Драйверы
+ _Драйвер_ - это сущность, которая непосредственно отвечает за взаимодействие с опреденной БД. Работать нам с ней приходится крайне редко, так как вместо этого мы используем объекты `DriverManager`, которые управляют драйверами.
+ Именно драйвер дает нам возможность открывать соединения, выполнять `SQL` - запросы и т.п.
+ Чтобы БД могла работать с _JDBC_, ее разработчики должны написать соответствующую имплементацию интерфейса `java.sql.Driver`.

[к оглавлению](#JDBC)

## Типы драйверов
+ ___Тип 1_. JDBC - ODBC транслятор__.
    + Этот тип драйвера транслирует JDBC в установленный на каждой клиентской машине ODBC (Open Database Connectivity). Использование ODBC требует конфигурации DSN, который является целевой БД.
    + Схема работы JDBC - ODBC транслятора :
    
        ![alt text](https://i0.wp.com/proselyte.net/wp-content/uploads/2016/03/jdbc-driver-type1.jpg?resize=300%2C254&ssl=1)
    + Изначально, именно этот тип драйверов был самым используемым, так как большинство БД поддерживало только ODBC.

+ ___Тип 2_. JDBC - нативный API__.
    + В этом драйвере JDBC API преобразовывается в уникальный для каждой БД нативный C/C++ API. 
    + Его принцип работы довольно схож с драйвером первого типа.
    + Схема работы JDBC - нативный API драйвера :
    
        ![alt text](https://i0.wp.com/proselyte.net/wp-content/uploads/2016/03/jdbc-driver-type2.jpg?resize=300%2C254&ssl=1)
    + Если мы меняем БД, то нам необходимо изменить и нативный API, который будет работать с конкретной БД.
    
+ ___Тип 3_. JDBC - Драйвер на основе библиотеки Java__.
    + Этот тип драйверов использует трехзвенный подход для получения доступа к БД.
    + Для связи с промежуточным сервером используется стандартный сетевой сокет. Информация, полученная от этого сокета, транслируется промежуточным сервером в формат, который необходим конкретной БД и направляется в сервер БД.
    + Схема работы JDBC - Драйвера на основе библиотеки Java : 
        
        ![alt text](https://i2.wp.com/proselyte.net/wp-content/uploads/2016/03/jdbc-driver-type3.jpg?resize=300%2C227&ssl=1)
    + Этот подход является крайне гибким, так как нет необходимости устанавливать ПО на стороне клиента и один драйвер способен обеспечить доступ к различным БД.

+ ___Тип 4_. Чистая Java__.
    + Этот тип драйверов разработан полностью с использованием языка программирования Java и работает с БД через сокетное соединение.
    + Главное преимущество такого драйвера - это наибольшая производительность, и обычно такие драйверы предоставляются разработчиками БД.
    + Схема работы драйвера на чистой Java :
    
        ![alt text](https://i2.wp.com/proselyte.net/wp-content/uploads/2016/03/jdbc-driver-type4.jpg?resize=300%2C275&ssl=1)   
    + Еще одно преимущество такого типа драйвера - это невероятная гибкость. Нам не нужно устанавливать никакого дополнительного программного обеспечения.
    + Ярким примером такого драйвера является _MySQL Connector/J_.

[к оглавлению](#JDBC)

## Какой тип драйвера выбрать?
+ Когда мы работаем с такими БД, как MySQL, Oracle и т.д., наиболее предпочтительным будет использования драйвера типа `4`.
+ Если наше приложение использует различные виды БД, то тип `3` будет более приемлемым.
+ Если для нашей БД еще нет драйверов `3` или `4`, то мы будем вынуждены использовать драйвер под номером `2`.
+ Драйвер типа `1` обычно не используется в коммерческой разработке.   

[к оглавлению](#JDBC) 

## `Connection`
`Connection` - это тип объектов соединения с базой данных. Он создается с помощью перегруженного метода `DriverManager.getConnection()` и позволяет нам выполнять `SQL` - запросы.

Для того, чтобы установить соединение с базой банных, необходимо выполнить `3` шага :
1. Зарегистрировать JDBC драйвер.
2. Передать информацию для соединения с БД (URL, имя пользователя и пароль) - шаг фактически общий с третим.
3. Создать соединение с помощью `DriverManager.getConnection()`.

[к оглавлению](#JDBC) 

### Регистрация драйвера
Регистрацию драйвера можно осуществить `2` - мя способами :
##### 1. С помощью статического метода `DriverManager.registerDriver()`.

В коде это выглядит так :
```java
try {
    Driver driver = new com.mysql.jdbc.Driver();
    DriverManager.registerDriver(driver);
} catch (SQLException e) {
    System.out.println("Unable to load driver class.");
    e.printStackTrace();
}
```

##### 2. С помощью `Class.forName()`.

Этот способ является более распространенным. Мы используем `Class.forName()` для динамической загрузки класса драйвера в память, после чего происходит его автоматическая регистрация. 

Данный способ является более предпочтительным, так как он обеспечивает конфигурируемую и переносимую регистрацию драйверов.

В коде он выглядит так :
```java
try {
    Class.forName("com.mysql.jdbc.Driver");
} catch (ClassNotFoundException e) {
    System.out.println("Unable to load class.");
    e.printStackTrace();
}
```

[к оглавлению](#JDBC) 

### Передача информации о БД
После того, как мы зарегистрировали наш драйвер, мы можем установить соединение с помощью метода `DriverManager.getConnection()`.

Этот метод имеет `3` перегруженных варианта :
+ `getConnection(String url)`
+ `getConnection(String url, Properties props)`
+ `getConnection(String url, String user, String password)`

Как видим, каждый из этих методов требует URL нашей БД. Поэтому, нам необходимо передавать информацию о БД.

URL для разных баз данных будет различен, так же как и драйвер. Например :
+ MySQL : URL : `jdbc:mysql://hostname/databaseName`, Driver name : `jdbc:mysql://hostname/databaseName`.
+ Oracle : URL : `jdbc:oracle:thin:@hostname:portNumber/databaseName`, Driver name : `oracle.jdbc.driver.OracleDriver`.

[к оглавлению](#JDBC) 

### Создание соединения
После того, как мы зарегистрировали драйвер и передали всю необходимую информацию о БД, мы можем создать физическое соединение с БД.

Пример создания соединения с БД MySQL :
```java
String URL = "jdbc:mysql://localhost/exampledb";
String USER = "root";
String PASSWORD = "root";
Connection connection = DriverManger.getConnection(URL, USER, PASSWORD);
```

[к оглавлению](#JDBC) 

### Закрытие соединения
После того, как мы закончим программу, необходимо закрыть все соединения и освободить ресурсы. Если мы не сделаем это вручную, это сделает сборщик мусора при уничтожении объектов, которые не используются.

Но полагаться на сборщик мусора - это крайне плохая идея и дурной тон.

Можно закрыть соединение либо явно (так делали раньше в блоке `final`) :
```java
connection.close();
```
Либо более современным способом - использовать автоматическое освобождение ресурсов с помощью конструкции `try-with-resources` :
```java
try (Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD)) {
    ...
}
```

[к оглавлению](#JDBC)

## Утверждения (Statements)
Утверждения - это интерфейсы, которые помогают нам взаимодействовать с БД и реализуются каждым драйвером.

Их существует `3` :
+ `Statement` - интерфейс, который используется для доступа к БД в общих целях. Он крайне полезен, когда мы используем статические SQL - выражения во время работы программы. Этот интерфейс не принимает никаких параметров.
+ `PreparedStatement` - интерфейс, который используется в случае, когда мы планируем использовать выражения SQL множество раз. Он принимает параметры во время работы программы.
+ `CallableStatement` - интерфейс, который позволяет нам получить доступ к различным процедурам БД. Он также принимает значения во время работы программы.

[к оглавлению](#JDBC)

## `Statement`
+ `Statement` - это интерфейс, который используется для проведения операций с БД. Он является самым простым среди трех разных стейтментов, а также является parent-классом для `PreparedStatement` (тот в свою очередь parent для `CallableStatement`).
+ `Statement` обычно используется для работы со статическими SQL - запросами, которые не рассчитаны на переиспользование.

[к оглавлению](#JDBC)

### Создание экземпляра `Statement`
Прежде, чем мы сможем использовать `Statement`, нам необходимо получить его экземпляр. Для этого используется метод `Connection.createStatement()`.

В коде создание `Statement` выглядит следующим образом :
```java
try (Statement statement = connection.createStatement()){
    ...
} catch (SQLException e) {
    e.printStackTrace();
}
```

[к оглавлению](#JDBC)

### Методы `Statement`
После создания экземпляра `Statement` мы можем его использовать для выполнения SQL-запросов.

Для этой цели интерфейс `Statement` имеет три метода, которые реализуются каждой конкретной реализации JDBC драйвера :
+ `execute(String sql) -> boolean` - используется для любых SQL-запросов и возвращает `true`, если команда может вернуть набор строк (`SELECT`) и `false` для остальных операторов.
+ `executeUpdate(String sql) -> int` - выполняет такие SQL-команды, как `INSERT`, `UPDATE`, `DELETE`, `CREATE TABLE`, `DROP TABLE`. В качестве результата вовращает количество строк, затронутых операцией (измененных, добавленных, удаленных и т.п.).
+ `executeQuery(String sql) -> ResultSet` - выполняет SQL-команду `SELECT`. Возвращает объект `ResultSet`, в котором содержатся результаты запроса.

[к оглавлению](#JDBC)

### Закрытие экземпляра `Statement`
Экземпляр `Statement` обычно закрывается вместо с `Connection`, из которого его достали, для этого используется в старом варианте с `finally` - вызов метода `statement.close()`, а в новом - это создание его в блоке ресурсов конструкции `try-with-resources` :

```java
Class.forName(JDBC_DRIVER);
Connection connection = DriverManager.getConnection(DATABASE_URL, USER, PASSWORD);

try (Statement statement = connection.createStatement()){
    ...
} catch (SQLException e) {
    e.printStackTrace();
}
```
После выполнения блока `try-catch` объект `statement` будет автоматически закрыт, так как он имплементирует `AutoCloseable`.

[к оглавлению](#JDBC)

## `PreparedStatement`
+ `PreparedStatement` - это интерфейс утверждения, который используется когда мы планируем переиспользовать SQL-команду множество раз. В этом ему помогает возможность динамического подставления параметров в запрос.
+ Интерфейс `PreparedStatement` наследует интерфейс `Statement`, что дает ему определенные преимущества перед обычным `Statement`. В частности, мы получаем большую гибкость при работе с динамическими аргументами.
+ `PreparedStatement` является parent-классом для `CallableStatement`.

[к оглавлению](#JDBC)

### Создание экземпляра `PreparedStatement`
Создание экземпляра `PreparedStatement` :
```java
String SQL = "Update developers SET salary WHERE specialty = ?";

try (PreparedStatement preparedStatement = connection.prepareStatement(SQL)) {
    ...
} catch (SQLException e){
    e.printStackTrace();
}
```
Все параметры, отмеченные символом `?`, называются маркерами параметра. Это означает, что они должны быть переданы через параметры метода. 

Каждый параметр ссылается на свой порядковый номер в сигнатуре метода. То есть, первый маркер находится на первой позиции, второй - на второй и т.д. То есть, отсчет, в отличии от массивов, тут идет с единицы. Это связано с особенностями реляционной модели, на которой и основана работа реляционных БД.

[к оглавлению](#JDBC)

### Методы `PreparedStatement`
`PreparedStatement` имеет все те же `3` метода, что и у родителя - `Statement`, только немного измененные внутри : 
+ `execute(String sql) -> boolean`
+ `executeUpdate(String sql) -> int`
+ `executeQuery(String sql) -> ResultSet`

Также тут добавляются новые методы для динамической подстановки значений по маркерам в SQL. Вот часть из них :
+ `setString`
+ `setInt`
+ `setBigDecimal`
+ `setBoolean`
+ `setDate`
+ `setDouble`
+ `setFloat`
+ `setLong`
+ `setNull`
+ `setTime`

Все они принимают первым параметром номер маркера, начиная с `1`, в который следует подставить значения, а вторым - само значение.

[к оглавлению](#JDBC)

### Закрытие экземпляра `PreparedStatement`
`Prepared` является реализацией `AutoCloseable`, а поэтому, как и его parent - `Statement`, может закрываться двумя способами : первый - по старинке, через `finally`, где вызывается метод `preparedStatement.close()`, а второй - современный - автоматическое закрытие с `try-with-resources` :
```java
String SQL = "Update developers SET salary WHERE specialty = ?";

try (PreparedStatement preparedStatement = connection.prepareStatement(SQL)) {
   ...
} catch (SQLException e) {
    e.printStackTrace();
} 
```
После данного блока `try-catch` объект `preparedStatement` будет автоматически закрыт.

[к оглавлению](#JDBC)

## `CallableStatement`
+ `CallableStatement` используется для выполнения процедур непосредственно в самой БД.
+ `CallableStatement` расширяет интерфейс `PreparedStatement`.
+ Существует три типа параметров - IN, OUT, INOUT. `PreparedStatement` использует только IN, тогда как `CallableStatement` использует все три. Что же это за параметры :
    + IN - параметр, значение которого известно в момент создания запроса. Мы можем его назначить с помощью метода `setXXX()`.
    + OUT - параметр, значение которого возвращается SQL-запросом. Мы получаем значения из OUT с помощью метода типа `getXXX()`.
    + INOUT - параметр, который использует входные и выходные значения. Мы можем как назначит его значение с помощью метода `setXXX()`, так и получить его значение с помощью `getXXX()`.

[к оглавлению](#JDBC)

### Создание экземпляра `CallableStatement`
Создадим процедуру в MySQL :
```sql
DELIMITER $$
DROP PROCEDURE IF EXISTS `developers`.`getDeveloperName` $$
CREATE PROCEDURE PROSELYTE_TUTORIALS.`getDeveloperName`
(IN DEVELOPER_ID INT, OUT DEVELOPER_NAME VARCHAR(50))
BEGIN
SELECT first INTO DEVELOPER_NAME
FROM developers
WHERE id = DEVELOPER_ID;

END $$

DELIMITER ;
```
В коде создание экземпляра будет выглядеть следующим образом :
```java
String SQL = "{call getDeveloperName (?, ?)}";

try (CallableStatement callableStatement = connection.prepareCall(SQL)) {
    ...
}
```
Здесь строка представляет собой процедуру с параметрами.

Схожим образом с `PreparedStatement`, мы должны установить параметры и для данного стейтмента.

Особенности использования `CallableStatement` :
+ Когда мы используем параметры типа OUT и INOUT, нам необходимо задействовать дополнительный метод `registerOutParameter()`. Этот метод устанавливает тип данных JDBC в тип данных процедуры.
+ После того, как мы вызвали процедуру, мы получаем значение из параметра OUT с помощью соответствующего метода `getXXX()`. Этот метод преобразует полученное значение из типа данных SQL в тип данных Java/.

[к оглавлению](#JDBC)

### Закрытие экземпляра `CallableStatement`
`CallableStatement` реализует `AutoCloseable`, поэтому его эклемпляр можно закрыть либо с помощью `callableStatement.close()`, либо автоматически в `try-with-resources` :
```sql
String SQL = "{call getDeveloperName (?, ?)}";

try (CallableStatement callableStatement = connection.prepareCall(SQL)) {
    ...
}
```
После окончания блока `try-with-resources` объект `callableStatement` автоматически будет закрыт.

[к оглавлению](#JDBC)
